// -*- C++ -*-
/*
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT
 *        Nijkerk, GLD
 *        The Netherlands
 *        http://www.remedy.nl \ http://www.theaceorb.nl
 */

#ifndef __RIDL_TESTC_H_EHIJFIGA_INCLUDED__
#define __RIDL_TESTC_H_EHIJFIGA_INCLUDED__


#include /**/ "ace/pre.h"

#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/anytypecode/any.h"
#include "tao/x11/sequence_os_t.h"
#include "tao/x11/corba_ostream.h"

#include "tao/x11/versionx11.h"

#if TAOX11_MAJOR_VERSION != 1 || TAOX11_MINOR_VERSION != 2 || TAOX11_BETA_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (1.2.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from StubHeaderWriter#enter_module
namespace Deployment
{

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class Property
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline Property ();
    ~Property () = default;
    Property (const Property&) = default;
    Property (Property&&) = default;
    explicit inline Property (std::string name,
                       TAOX11_NAMESPACE::CORBA::Any value);
    inline Property& operator= (const Property& x);
    inline Property& operator= (Property&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void value (const TAOX11_NAMESPACE::CORBA::Any& _value);
    inline void value (TAOX11_NAMESPACE::CORBA::Any&& _value);
    inline const TAOX11_NAMESPACE::CORBA::Any& value () const;
    inline TAOX11_NAMESPACE::CORBA::Any& value ();

    inline void swap (Property& s);

  private:
    std::string name_;
    TAOX11_NAMESPACE::CORBA::Any value_;
  };// Property

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < Property> Properties;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class Requirement
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline Requirement ();
    ~Requirement () = default;
    Requirement (const Requirement&) = default;
    Requirement (Requirement&&) = default;
    explicit inline Requirement (std::string name,
                          std::string resourceType,
                          ::Deployment::Properties property);
    inline Requirement& operator= (const Requirement& x);
    inline Requirement& operator= (Requirement&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void resourceType (const std::string& _resourceType);
    inline void resourceType (std::string&& _resourceType);
    inline const std::string& resourceType () const;
    inline std::string& resourceType ();

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();

    inline void swap (Requirement& s);

  private:
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  };// Requirement

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < Requirement> Requirements;

  // generated from c++11/templates/cli/hdr/enum.erb
  enum class SatisfierPropertyKind : uint32_t
  {
    Quantity,
    Capacity,
    Minimum,
    Maximum,
    Attribute,
    Selection
  };// SatisfierPropertyKind

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class SatisfierProperty
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline SatisfierProperty ();
    ~SatisfierProperty () = default;
    SatisfierProperty (const SatisfierProperty&) = default;
    SatisfierProperty (SatisfierProperty&&) = default;
    explicit inline SatisfierProperty (std::string name,
                                ::Deployment::SatisfierPropertyKind kind,
                                bool dynamic,
                                TAOX11_NAMESPACE::CORBA::Any value);
    inline SatisfierProperty& operator= (const SatisfierProperty& x);
    inline SatisfierProperty& operator= (SatisfierProperty&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void kind (::Deployment::SatisfierPropertyKind _kind);
    inline ::Deployment::SatisfierPropertyKind kind () const;
    inline ::Deployment::SatisfierPropertyKind& kind ();

    inline void dynamic (bool _dynamic);
    inline bool dynamic () const;
    inline bool& dynamic ();

    inline void value (const TAOX11_NAMESPACE::CORBA::Any& _value);
    inline void value (TAOX11_NAMESPACE::CORBA::Any&& _value);
    inline const TAOX11_NAMESPACE::CORBA::Any& value () const;
    inline TAOX11_NAMESPACE::CORBA::Any& value ();

    inline void swap (SatisfierProperty& s);

  private:
    std::string name_;
    ::Deployment::SatisfierPropertyKind kind_;
    bool dynamic_;
    TAOX11_NAMESPACE::CORBA::Any value_;
  };// SatisfierProperty

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < SatisfierProperty> SatisfierProperties;
}; // namespace Deployment


// generated from StubHeaderWriter#enter_module
namespace Deployment
{

  // generated from c++11/templates/cli/hdr/enum.erb
  enum class CCMComponentPortKind : uint32_t
  {
    Facet,
    SimplexReceptacle,
    MultiplexReceptacle,
    EventEmitter,
    EventPublisher,
    EventConsumer,
    ExtendedPort,
    MirrorPort
  };// CCMComponentPortKind

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ComponentPortDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ComponentPortDescription ();
    ~ComponentPortDescription () = default;
    ComponentPortDescription (const ComponentPortDescription&) = default;
    ComponentPortDescription (ComponentPortDescription&&) = default;
    explicit inline ComponentPortDescription (std::string name,
                                       std::string specificType,
                                       ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                       bool provider,
                                       bool exclusiveProvider,
                                       bool exclusiveUser,
                                       bool optional,
                                       ::Deployment::CCMComponentPortKind kind,
                                       ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam);
    inline ComponentPortDescription& operator= (const ComponentPortDescription& x);
    inline ComponentPortDescription& operator= (ComponentPortDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void specificType (const std::string& _specificType);
    inline void specificType (std::string&& _specificType);
    inline const std::string& specificType () const;
    inline std::string& specificType ();

    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType ();

    inline void provider (bool _provider);
    inline bool provider () const;
    inline bool& provider ();

    inline void exclusiveProvider (bool _exclusiveProvider);
    inline bool exclusiveProvider () const;
    inline bool& exclusiveProvider ();

    inline void exclusiveUser (bool _exclusiveUser);
    inline bool exclusiveUser () const;
    inline bool& exclusiveUser ();

    inline void optional (bool _optional);
    inline bool optional () const;
    inline bool& optional ();

    inline void kind (::Deployment::CCMComponentPortKind _kind);
    inline ::Deployment::CCMComponentPortKind kind () const;
    inline ::Deployment::CCMComponentPortKind& kind ();

    inline void templateParam (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _templateParam);
    inline void templateParam (::TAOX11_NAMESPACE::CORBA::StringSeq&& _templateParam);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam ();

    inline void swap (ComponentPortDescription& s);

  private:
    std::string name_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    bool provider_;
    bool exclusiveProvider_;
    bool exclusiveUser_;
    bool optional_;
    ::Deployment::CCMComponentPortKind kind_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam_;
  };// ComponentPortDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ComponentPortDescription> ComponentPortDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ComponentPropertyDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ComponentPropertyDescription ();
    ~ComponentPropertyDescription () = default;
    ComponentPropertyDescription (const ComponentPropertyDescription&) = default;
    ComponentPropertyDescription (ComponentPropertyDescription&&) = default;
    explicit inline ComponentPropertyDescription (std::string name,
                                           TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type);
    inline ComponentPropertyDescription& operator= (const ComponentPropertyDescription& x);
    inline ComponentPropertyDescription& operator= (ComponentPropertyDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void type (TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type _type);
    inline TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type () const;
    inline TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type& type ();

    inline void swap (ComponentPropertyDescription& s);

  private:
    std::string name_;
    TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type_;
  };// ComponentPropertyDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ComponentPropertyDescription> ComponentPropertyDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ComponentInterfaceDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ComponentInterfaceDescription ();
    ~ComponentInterfaceDescription () = default;
    ComponentInterfaceDescription (const ComponentInterfaceDescription&) = default;
    ComponentInterfaceDescription (ComponentInterfaceDescription&&) = default;
    explicit inline ComponentInterfaceDescription (std::string label,
                                            std::string UUID,
                                            std::string specificType,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile,
                                            ::Deployment::Properties configProperty,
                                            ::Deployment::ComponentPortDescriptions port,
                                            ::Deployment::ComponentPropertyDescriptions property,
                                            ::Deployment::Properties infoProperty);
    inline ComponentInterfaceDescription& operator= (const ComponentInterfaceDescription& x);
    inline ComponentInterfaceDescription& operator= (ComponentInterfaceDescription&& x);

    inline void label (const std::string& _label);
    inline void label (std::string&& _label);
    inline const std::string& label () const;
    inline std::string& label ();

    inline void UUID (const std::string& _UUID);
    inline void UUID (std::string&& _UUID);
    inline const std::string& UUID () const;
    inline std::string& UUID ();

    inline void specificType (const std::string& _specificType);
    inline void specificType (std::string&& _specificType);
    inline const std::string& specificType () const;
    inline std::string& specificType ();

    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType ();

    inline void idlFile (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _idlFile);
    inline void idlFile (::TAOX11_NAMESPACE::CORBA::StringSeq&& _idlFile);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile ();

    inline void configProperty (const ::Deployment::Properties& _configProperty);
    inline void configProperty (::Deployment::Properties&& _configProperty);
    inline const ::Deployment::Properties& configProperty () const;
    inline ::Deployment::Properties& configProperty ();

    inline void port (const ::Deployment::ComponentPortDescriptions& _port);
    inline void port (::Deployment::ComponentPortDescriptions&& _port);
    inline const ::Deployment::ComponentPortDescriptions& port () const;
    inline ::Deployment::ComponentPortDescriptions& port ();

    inline void property (const ::Deployment::ComponentPropertyDescriptions& _property);
    inline void property (::Deployment::ComponentPropertyDescriptions&& _property);
    inline const ::Deployment::ComponentPropertyDescriptions& property () const;
    inline ::Deployment::ComponentPropertyDescriptions& property ();

    inline void infoProperty (const ::Deployment::Properties& _infoProperty);
    inline void infoProperty (::Deployment::Properties&& _infoProperty);
    inline const ::Deployment::Properties& infoProperty () const;
    inline ::Deployment::Properties& infoProperty ();

    inline void swap (ComponentInterfaceDescription& s);

  private:
    std::string label_;
    std::string UUID_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile_;
    ::Deployment::Properties configProperty_;
    ::Deployment::ComponentPortDescriptions port_;
    ::Deployment::ComponentPropertyDescriptions property_;
    ::Deployment::Properties infoProperty_;
  };// ComponentInterfaceDescription

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class MonolithicDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline MonolithicDeploymentDescription ();
    ~MonolithicDeploymentDescription () = default;
    MonolithicDeploymentDescription (const MonolithicDeploymentDescription&) = default;
    MonolithicDeploymentDescription (MonolithicDeploymentDescription&&) = default;
    explicit inline MonolithicDeploymentDescription (std::string name,
                                              ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                              ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef,
                                              ::Deployment::Properties execParameter,
                                              ::Deployment::Requirements deployRequirement);
    inline MonolithicDeploymentDescription& operator= (const MonolithicDeploymentDescription& x);
    inline MonolithicDeploymentDescription& operator= (MonolithicDeploymentDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();

    inline void artifactRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _artifactRef);
    inline void artifactRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _artifactRef);
    inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef () const;
    inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef ();

    inline void execParameter (const ::Deployment::Properties& _execParameter);
    inline void execParameter (::Deployment::Properties&& _execParameter);
    inline const ::Deployment::Properties& execParameter () const;
    inline ::Deployment::Properties& execParameter ();

    inline void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    inline void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    inline const ::Deployment::Requirements& deployRequirement () const;
    inline ::Deployment::Requirements& deployRequirement ();

    inline void swap (MonolithicDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
  };// MonolithicDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < MonolithicDeploymentDescription> MonolithicDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/enum.erb
  enum class ResourceUsageKind : uint32_t
  {
    None,
    InstanceUsesResource,
    ResourceUsesInstance,
    PortUsesResource,
    ResourceUsesPort
  };// ResourceUsageKind

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class InstanceResourceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline InstanceResourceDeploymentDescription ();
    ~InstanceResourceDeploymentDescription () = default;
    InstanceResourceDeploymentDescription (const InstanceResourceDeploymentDescription&) = default;
    InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription&&) = default;
    explicit inline InstanceResourceDeploymentDescription (::Deployment::ResourceUsageKind resourceUsage,
                                                    std::string requirementName,
                                                    std::string resourceName,
                                                    ::Deployment::Properties property);
    inline InstanceResourceDeploymentDescription& operator= (const InstanceResourceDeploymentDescription& x);
    inline InstanceResourceDeploymentDescription& operator= (InstanceResourceDeploymentDescription&& x);

    inline void resourceUsage (::Deployment::ResourceUsageKind _resourceUsage);
    inline ::Deployment::ResourceUsageKind resourceUsage () const;
    inline ::Deployment::ResourceUsageKind& resourceUsage ();

    inline void requirementName (const std::string& _requirementName);
    inline void requirementName (std::string&& _requirementName);
    inline const std::string& requirementName () const;
    inline std::string& requirementName ();

    inline void resourceName (const std::string& _resourceName);
    inline void resourceName (std::string&& _resourceName);
    inline const std::string& resourceName () const;
    inline std::string& resourceName ();

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();

    inline void swap (InstanceResourceDeploymentDescription& s);

  private:
    ::Deployment::ResourceUsageKind resourceUsage_;
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// InstanceResourceDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < InstanceResourceDeploymentDescription> InstanceResourceDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class InstanceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline InstanceDeploymentDescription ();
    ~InstanceDeploymentDescription () = default;
    InstanceDeploymentDescription (const InstanceDeploymentDescription&) = default;
    InstanceDeploymentDescription (InstanceDeploymentDescription&&) = default;
    explicit inline InstanceDeploymentDescription (std::string name,
                                            std::string node,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                            uint32_t implementationRef,
                                            ::Deployment::Properties configProperty,
                                            ::Deployment::InstanceResourceDeploymentDescriptions deployedResource,
                                            ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource);
    inline InstanceDeploymentDescription& operator= (const InstanceDeploymentDescription& x);
    inline InstanceDeploymentDescription& operator= (InstanceDeploymentDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void node (const std::string& _node);
    inline void node (std::string&& _node);
    inline const std::string& node () const;
    inline std::string& node ();

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();

    inline void implementationRef (uint32_t _implementationRef);
    inline uint32_t implementationRef () const;
    inline uint32_t& implementationRef ();

    inline void configProperty (const ::Deployment::Properties& _configProperty);
    inline void configProperty (::Deployment::Properties&& _configProperty);
    inline const ::Deployment::Properties& configProperty () const;
    inline ::Deployment::Properties& configProperty ();

    inline void deployedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedResource);
    inline void deployedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedResource);
    inline const ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource () const;
    inline ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource ();

    inline void deployedSharedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedSharedResource);
    inline void deployedSharedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedSharedResource);
    inline const ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource () const;
    inline ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource ();

    inline void swap (InstanceDeploymentDescription& s);

  private:
    std::string name_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    uint32_t implementationRef_;
    ::Deployment::Properties configProperty_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedResource_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource_;
  };// InstanceDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < InstanceDeploymentDescription> InstanceDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ComponentExternalPortEndpoint
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ComponentExternalPortEndpoint ();
    ~ComponentExternalPortEndpoint () = default;
    ComponentExternalPortEndpoint (const ComponentExternalPortEndpoint&) = default;
    ComponentExternalPortEndpoint (ComponentExternalPortEndpoint&&) = default;
    explicit inline ComponentExternalPortEndpoint (std::string portName);
    inline ComponentExternalPortEndpoint& operator= (const ComponentExternalPortEndpoint& x);
    inline ComponentExternalPortEndpoint& operator= (ComponentExternalPortEndpoint&& x);

    inline void portName (const std::string& _portName);
    inline void portName (std::string&& _portName);
    inline const std::string& portName () const;
    inline std::string& portName ();

    inline void swap (ComponentExternalPortEndpoint& s);

  private:
    std::string portName_;
  };// ComponentExternalPortEndpoint

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ComponentExternalPortEndpoint> ComponentExternalPortEndpoints;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class PlanSubcomponentPortEndpoint
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline PlanSubcomponentPortEndpoint ();
    ~PlanSubcomponentPortEndpoint () = default;
    PlanSubcomponentPortEndpoint (const PlanSubcomponentPortEndpoint&) = default;
    PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint&&) = default;
    explicit inline PlanSubcomponentPortEndpoint (std::string portName,
                                           bool provider,
                                           ::Deployment::CCMComponentPortKind kind,
                                           uint32_t instanceRef);
    inline PlanSubcomponentPortEndpoint& operator= (const PlanSubcomponentPortEndpoint& x);
    inline PlanSubcomponentPortEndpoint& operator= (PlanSubcomponentPortEndpoint&& x);

    inline void portName (const std::string& _portName);
    inline void portName (std::string&& _portName);
    inline const std::string& portName () const;
    inline std::string& portName ();

    inline void provider (bool _provider);
    inline bool provider () const;
    inline bool& provider ();

    inline void kind (::Deployment::CCMComponentPortKind _kind);
    inline ::Deployment::CCMComponentPortKind kind () const;
    inline ::Deployment::CCMComponentPortKind& kind ();

    inline void instanceRef (uint32_t _instanceRef);
    inline uint32_t instanceRef () const;
    inline uint32_t& instanceRef ();

    inline void swap (PlanSubcomponentPortEndpoint& s);

  private:
    std::string portName_;
    bool provider_;
    ::Deployment::CCMComponentPortKind kind_;
    uint32_t instanceRef_;
  };// PlanSubcomponentPortEndpoint

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < PlanSubcomponentPortEndpoint> PlanSubcomponentPortEndpoints;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ExternalReferenceEndpoint
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ExternalReferenceEndpoint ();
    ~ExternalReferenceEndpoint () = default;
    ExternalReferenceEndpoint (const ExternalReferenceEndpoint&) = default;
    ExternalReferenceEndpoint (ExternalReferenceEndpoint&&) = default;
    explicit inline ExternalReferenceEndpoint (std::string location,
                                        bool provider,
                                        std::string portName,
                                        ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType);
    inline ExternalReferenceEndpoint& operator= (const ExternalReferenceEndpoint& x);
    inline ExternalReferenceEndpoint& operator= (ExternalReferenceEndpoint&& x);

    inline void location (const std::string& _location);
    inline void location (std::string&& _location);
    inline const std::string& location () const;
    inline std::string& location ();

    inline void provider (bool _provider);
    inline bool provider () const;
    inline bool& provider ();

    inline void portName (const std::string& _portName);
    inline void portName (std::string&& _portName);
    inline const std::string& portName () const;
    inline std::string& portName ();

    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType ();

    inline void swap (ExternalReferenceEndpoint& s);

  private:
    std::string location_;
    bool provider_;
    std::string portName_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
  };// ExternalReferenceEndpoint

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ExternalReferenceEndpoint> ExternalReferenceEndpoints;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ConnectionResourceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ConnectionResourceDeploymentDescription ();
    ~ConnectionResourceDeploymentDescription () = default;
    ConnectionResourceDeploymentDescription (const ConnectionResourceDeploymentDescription&) = default;
    ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription&&) = default;
    explicit inline ConnectionResourceDeploymentDescription (std::string targetName,
                                                      std::string requirementName,
                                                      std::string resourceName,
                                                      ::Deployment::Properties property);
    inline ConnectionResourceDeploymentDescription& operator= (const ConnectionResourceDeploymentDescription& x);
    inline ConnectionResourceDeploymentDescription& operator= (ConnectionResourceDeploymentDescription&& x);

    inline void targetName (const std::string& _targetName);
    inline void targetName (std::string&& _targetName);
    inline const std::string& targetName () const;
    inline std::string& targetName ();

    inline void requirementName (const std::string& _requirementName);
    inline void requirementName (std::string&& _requirementName);
    inline const std::string& requirementName () const;
    inline std::string& requirementName ();

    inline void resourceName (const std::string& _resourceName);
    inline void resourceName (std::string&& _resourceName);
    inline const std::string& resourceName () const;
    inline std::string& resourceName ();

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();

    inline void swap (ConnectionResourceDeploymentDescription& s);

  private:
    std::string targetName_;
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// ConnectionResourceDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ConnectionResourceDeploymentDescription> ConnectionResourceDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class PlanConnectionDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline PlanConnectionDescription ();
    ~PlanConnectionDescription () = default;
    PlanConnectionDescription (const PlanConnectionDescription&) = default;
    PlanConnectionDescription (PlanConnectionDescription&&) = default;
    explicit inline PlanConnectionDescription (std::string name,
                                        ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                        ::Deployment::Requirements deployRequirement,
                                        ::Deployment::ComponentExternalPortEndpoints externalEndpoint,
                                        ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint,
                                        ::Deployment::ExternalReferenceEndpoints externalReference,
                                        ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource);
    inline PlanConnectionDescription& operator= (const PlanConnectionDescription& x);
    inline PlanConnectionDescription& operator= (PlanConnectionDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();

    inline void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    inline void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    inline const ::Deployment::Requirements& deployRequirement () const;
    inline ::Deployment::Requirements& deployRequirement ();

    inline void externalEndpoint (const ::Deployment::ComponentExternalPortEndpoints& _externalEndpoint);
    inline void externalEndpoint (::Deployment::ComponentExternalPortEndpoints&& _externalEndpoint);
    inline const ::Deployment::ComponentExternalPortEndpoints& externalEndpoint () const;
    inline ::Deployment::ComponentExternalPortEndpoints& externalEndpoint ();

    inline void internalEndpoint (const ::Deployment::PlanSubcomponentPortEndpoints& _internalEndpoint);
    inline void internalEndpoint (::Deployment::PlanSubcomponentPortEndpoints&& _internalEndpoint);
    inline const ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint () const;
    inline ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint ();

    inline void externalReference (const ::Deployment::ExternalReferenceEndpoints& _externalReference);
    inline void externalReference (::Deployment::ExternalReferenceEndpoints&& _externalReference);
    inline const ::Deployment::ExternalReferenceEndpoints& externalReference () const;
    inline ::Deployment::ExternalReferenceEndpoints& externalReference ();

    inline void deployedResource (const ::Deployment::ConnectionResourceDeploymentDescriptions& _deployedResource);
    inline void deployedResource (::Deployment::ConnectionResourceDeploymentDescriptions&& _deployedResource);
    inline const ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource () const;
    inline ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource ();

    inline void swap (PlanConnectionDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ComponentExternalPortEndpoints externalEndpoint_;
    ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint_;
    ::Deployment::ExternalReferenceEndpoints externalReference_;
    ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource_;
  };// PlanConnectionDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < PlanConnectionDescription> PlanConnectionDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class PlanSubcomponentPropertyReference
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline PlanSubcomponentPropertyReference ();
    ~PlanSubcomponentPropertyReference () = default;
    PlanSubcomponentPropertyReference (const PlanSubcomponentPropertyReference&) = default;
    PlanSubcomponentPropertyReference (PlanSubcomponentPropertyReference&&) = default;
    explicit inline PlanSubcomponentPropertyReference (std::string propertyName,
                                                uint32_t instanceRef);
    inline PlanSubcomponentPropertyReference& operator= (const PlanSubcomponentPropertyReference& x);
    inline PlanSubcomponentPropertyReference& operator= (PlanSubcomponentPropertyReference&& x);

    inline void propertyName (const std::string& _propertyName);
    inline void propertyName (std::string&& _propertyName);
    inline const std::string& propertyName () const;
    inline std::string& propertyName ();

    inline void instanceRef (uint32_t _instanceRef);
    inline uint32_t instanceRef () const;
    inline uint32_t& instanceRef ();

    inline void swap (PlanSubcomponentPropertyReference& s);

  private:
    std::string propertyName_;
    uint32_t instanceRef_;
  };// PlanSubcomponentPropertyReference

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < PlanSubcomponentPropertyReference> PlanSubcomponentPropertyReferences;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class PlanPropertyMapping
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline PlanPropertyMapping ();
    ~PlanPropertyMapping () = default;
    PlanPropertyMapping (const PlanPropertyMapping&) = default;
    PlanPropertyMapping (PlanPropertyMapping&&) = default;
    explicit inline PlanPropertyMapping (std::string name,
                                  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                  std::string externalName,
                                  ::Deployment::PlanSubcomponentPropertyReferences delegatesTo);
    inline PlanPropertyMapping& operator= (const PlanPropertyMapping& x);
    inline PlanPropertyMapping& operator= (PlanPropertyMapping&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();

    inline void externalName (const std::string& _externalName);
    inline void externalName (std::string&& _externalName);
    inline const std::string& externalName () const;
    inline std::string& externalName ();

    inline void delegatesTo (const ::Deployment::PlanSubcomponentPropertyReferences& _delegatesTo);
    inline void delegatesTo (::Deployment::PlanSubcomponentPropertyReferences&& _delegatesTo);
    inline const ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo () const;
    inline ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo ();

    inline void swap (PlanPropertyMapping& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    std::string externalName_;
    ::Deployment::PlanSubcomponentPropertyReferences delegatesTo_;
  };// PlanPropertyMapping

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < PlanPropertyMapping> PlanPropertyMappings;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ImplementationDependency
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ImplementationDependency ();
    ~ImplementationDependency () = default;
    ImplementationDependency (const ImplementationDependency&) = default;
    ImplementationDependency (ImplementationDependency&&) = default;
    explicit inline ImplementationDependency (std::string requiredType);
    inline ImplementationDependency& operator= (const ImplementationDependency& x);
    inline ImplementationDependency& operator= (ImplementationDependency&& x);

    inline void requiredType (const std::string& _requiredType);
    inline void requiredType (std::string&& _requiredType);
    inline const std::string& requiredType () const;
    inline std::string& requiredType ();

    inline void swap (ImplementationDependency& s);

  private:
    std::string requiredType_;
  };// ImplementationDependency

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ImplementationDependency> ImplementationDependencies;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ResourceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ResourceDeploymentDescription ();
    ~ResourceDeploymentDescription () = default;
    ResourceDeploymentDescription (const ResourceDeploymentDescription&) = default;
    ResourceDeploymentDescription (ResourceDeploymentDescription&&) = default;
    explicit inline ResourceDeploymentDescription (std::string requirementName,
                                            std::string resourceName,
                                            ::Deployment::Properties property);
    inline ResourceDeploymentDescription& operator= (const ResourceDeploymentDescription& x);
    inline ResourceDeploymentDescription& operator= (ResourceDeploymentDescription&& x);

    inline void requirementName (const std::string& _requirementName);
    inline void requirementName (std::string&& _requirementName);
    inline const std::string& requirementName () const;
    inline std::string& requirementName ();

    inline void resourceName (const std::string& _resourceName);
    inline void resourceName (std::string&& _resourceName);
    inline const std::string& resourceName () const;
    inline std::string& resourceName ();

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();

    inline void swap (ResourceDeploymentDescription& s);

  private:
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// ResourceDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ResourceDeploymentDescription> ResourceDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ArtifactDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ArtifactDeploymentDescription ();
    ~ArtifactDeploymentDescription () = default;
    ArtifactDeploymentDescription (const ArtifactDeploymentDescription&) = default;
    ArtifactDeploymentDescription (ArtifactDeploymentDescription&&) = default;
    explicit inline ArtifactDeploymentDescription (std::string name,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq location,
                                            std::string node,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                            ::Deployment::Properties execParameter,
                                            ::Deployment::Requirements deployRequirement,
                                            ::Deployment::ResourceDeploymentDescriptions deployedResource);
    inline ArtifactDeploymentDescription& operator= (const ArtifactDeploymentDescription& x);
    inline ArtifactDeploymentDescription& operator= (ArtifactDeploymentDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void location (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _location);
    inline void location (::TAOX11_NAMESPACE::CORBA::StringSeq&& _location);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& location () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& location ();

    inline void node (const std::string& _node);
    inline void node (std::string&& _node);
    inline const std::string& node () const;
    inline std::string& node ();

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();

    inline void execParameter (const ::Deployment::Properties& _execParameter);
    inline void execParameter (::Deployment::Properties&& _execParameter);
    inline const ::Deployment::Properties& execParameter () const;
    inline ::Deployment::Properties& execParameter ();

    inline void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    inline void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    inline const ::Deployment::Requirements& deployRequirement () const;
    inline ::Deployment::Requirements& deployRequirement ();

    inline void deployedResource (const ::Deployment::ResourceDeploymentDescriptions& _deployedResource);
    inline void deployedResource (::Deployment::ResourceDeploymentDescriptions&& _deployedResource);
    inline const ::Deployment::ResourceDeploymentDescriptions& deployedResource () const;
    inline ::Deployment::ResourceDeploymentDescriptions& deployedResource ();

    inline void swap (ArtifactDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq location_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ResourceDeploymentDescriptions deployedResource_;
  };// ArtifactDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ArtifactDeploymentDescription> ArtifactDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/enum.erb
  enum class PlanLocalityKind : uint32_t
  {
    PlanSameProcess,
    PlanDifferentProcess,
    PlanNoConstraint
  };// PlanLocalityKind

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class PlanLocality
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline PlanLocality ();
    ~PlanLocality () = default;
    PlanLocality (const PlanLocality&) = default;
    PlanLocality (PlanLocality&&) = default;
    explicit inline PlanLocality (::Deployment::PlanLocalityKind constraint,
                           ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef);
    inline PlanLocality& operator= (const PlanLocality& x);
    inline PlanLocality& operator= (PlanLocality&& x);

    inline void constraint (::Deployment::PlanLocalityKind _constraint);
    inline ::Deployment::PlanLocalityKind constraint () const;
    inline ::Deployment::PlanLocalityKind& constraint ();

    inline void constrainedInstanceRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _constrainedInstanceRef);
    inline void constrainedInstanceRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _constrainedInstanceRef);
    inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef () const;
    inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef ();

    inline void swap (PlanLocality& s);

  private:
    ::Deployment::PlanLocalityKind constraint_;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef_;
  };// PlanLocality

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < PlanLocality> PlanLocalities;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class DeploymentPlan
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline DeploymentPlan ();
    ~DeploymentPlan () = default;
    DeploymentPlan (const DeploymentPlan&) = default;
    DeploymentPlan (DeploymentPlan&&) = default;
    explicit inline DeploymentPlan (std::string label,
                             std::string UUID,
                             ::Deployment::ComponentInterfaceDescription realizes,
                             ::Deployment::MonolithicDeploymentDescriptions implementation,
                             ::Deployment::InstanceDeploymentDescriptions instance,
                             ::Deployment::PlanConnectionDescriptions connection,
                             ::Deployment::PlanPropertyMappings externalProperty,
                             ::Deployment::ImplementationDependencies dependsOn,
                             ::Deployment::ArtifactDeploymentDescriptions artifact,
                             ::Deployment::Properties infoProperty,
                             ::Deployment::PlanLocalities localityConstraint);
    inline DeploymentPlan& operator= (const DeploymentPlan& x);
    inline DeploymentPlan& operator= (DeploymentPlan&& x);

    inline void label (const std::string& _label);
    inline void label (std::string&& _label);
    inline const std::string& label () const;
    inline std::string& label ();

    inline void UUID (const std::string& _UUID);
    inline void UUID (std::string&& _UUID);
    inline const std::string& UUID () const;
    inline std::string& UUID ();

    inline void realizes (const ::Deployment::ComponentInterfaceDescription& _realizes);
    inline void realizes (::Deployment::ComponentInterfaceDescription&& _realizes);
    inline const ::Deployment::ComponentInterfaceDescription& realizes () const;
    inline ::Deployment::ComponentInterfaceDescription& realizes ();

    inline void implementation (const ::Deployment::MonolithicDeploymentDescriptions& _implementation);
    inline void implementation (::Deployment::MonolithicDeploymentDescriptions&& _implementation);
    inline const ::Deployment::MonolithicDeploymentDescriptions& implementation () const;
    inline ::Deployment::MonolithicDeploymentDescriptions& implementation ();

    inline void instance (const ::Deployment::InstanceDeploymentDescriptions& _instance);
    inline void instance (::Deployment::InstanceDeploymentDescriptions&& _instance);
    inline const ::Deployment::InstanceDeploymentDescriptions& instance () const;
    inline ::Deployment::InstanceDeploymentDescriptions& instance ();

    inline void connection (const ::Deployment::PlanConnectionDescriptions& _connection);
    inline void connection (::Deployment::PlanConnectionDescriptions&& _connection);
    inline const ::Deployment::PlanConnectionDescriptions& connection () const;
    inline ::Deployment::PlanConnectionDescriptions& connection ();

    inline void externalProperty (const ::Deployment::PlanPropertyMappings& _externalProperty);
    inline void externalProperty (::Deployment::PlanPropertyMappings&& _externalProperty);
    inline const ::Deployment::PlanPropertyMappings& externalProperty () const;
    inline ::Deployment::PlanPropertyMappings& externalProperty ();

    inline void dependsOn (const ::Deployment::ImplementationDependencies& _dependsOn);
    inline void dependsOn (::Deployment::ImplementationDependencies&& _dependsOn);
    inline const ::Deployment::ImplementationDependencies& dependsOn () const;
    inline ::Deployment::ImplementationDependencies& dependsOn ();

    inline void artifact (const ::Deployment::ArtifactDeploymentDescriptions& _artifact);
    inline void artifact (::Deployment::ArtifactDeploymentDescriptions&& _artifact);
    inline const ::Deployment::ArtifactDeploymentDescriptions& artifact () const;
    inline ::Deployment::ArtifactDeploymentDescriptions& artifact ();

    inline void infoProperty (const ::Deployment::Properties& _infoProperty);
    inline void infoProperty (::Deployment::Properties&& _infoProperty);
    inline const ::Deployment::Properties& infoProperty () const;
    inline ::Deployment::Properties& infoProperty ();

    inline void localityConstraint (const ::Deployment::PlanLocalities& _localityConstraint);
    inline void localityConstraint (::Deployment::PlanLocalities&& _localityConstraint);
    inline const ::Deployment::PlanLocalities& localityConstraint () const;
    inline ::Deployment::PlanLocalities& localityConstraint ();

    inline void swap (DeploymentPlan& s);

  private:
    std::string label_;
    std::string UUID_;
    ::Deployment::ComponentInterfaceDescription realizes_;
    ::Deployment::MonolithicDeploymentDescriptions implementation_;
    ::Deployment::InstanceDeploymentDescriptions instance_;
    ::Deployment::PlanConnectionDescriptions connection_;
    ::Deployment::PlanPropertyMappings externalProperty_;
    ::Deployment::ImplementationDependencies dependsOn_;
    ::Deployment::ArtifactDeploymentDescriptions artifact_;
    ::Deployment::Properties infoProperty_;
    ::Deployment::PlanLocalities localityConstraint_;
  };// DeploymentPlan
}; // namespace Deployment


// generated from StubHeaderWriter#enter_module
namespace Deployment
{

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ComponentPackageReference
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ComponentPackageReference ();
    ~ComponentPackageReference () = default;
    ComponentPackageReference (const ComponentPackageReference&) = default;
    ComponentPackageReference (ComponentPackageReference&&) = default;
    explicit inline ComponentPackageReference (std::string requiredUUID,
                                        std::string requiredName,
                                        ::Deployment::ComponentInterfaceDescription requiredType);
    inline ComponentPackageReference& operator= (const ComponentPackageReference& x);
    inline ComponentPackageReference& operator= (ComponentPackageReference&& x);

    inline void requiredUUID (const std::string& _requiredUUID);
    inline void requiredUUID (std::string&& _requiredUUID);
    inline const std::string& requiredUUID () const;
    inline std::string& requiredUUID ();

    inline void requiredName (const std::string& _requiredName);
    inline void requiredName (std::string&& _requiredName);
    inline const std::string& requiredName () const;
    inline std::string& requiredName ();

    inline void requiredType (const ::Deployment::ComponentInterfaceDescription& _requiredType);
    inline void requiredType (::Deployment::ComponentInterfaceDescription&& _requiredType);
    inline const ::Deployment::ComponentInterfaceDescription& requiredType () const;
    inline ::Deployment::ComponentInterfaceDescription& requiredType ();

    inline void swap (ComponentPackageReference& s);

  private:
    std::string requiredUUID_;
    std::string requiredName_;
    ::Deployment::ComponentInterfaceDescription requiredType_;
  };// ComponentPackageReference

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ComponentPackageReference> ComponentPackageReferences;

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ::Deployment::ResourceUsageKind> ResourceUsageKinds;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class ImplementationRequirement
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline ImplementationRequirement ();
    ~ImplementationRequirement () = default;
    ImplementationRequirement (const ImplementationRequirement&) = default;
    ImplementationRequirement (ImplementationRequirement&&) = default;
    explicit inline ImplementationRequirement (::Deployment::ResourceUsageKinds resourceUsage,
                                        std::string resourcePort,
                                        std::string componentPort,
                                        std::string name,
                                        std::string resourceType,
                                        ::Deployment::Properties property);
    inline ImplementationRequirement& operator= (const ImplementationRequirement& x);
    inline ImplementationRequirement& operator= (ImplementationRequirement&& x);

    inline void resourceUsage (const ::Deployment::ResourceUsageKinds& _resourceUsage);
    inline void resourceUsage (::Deployment::ResourceUsageKinds&& _resourceUsage);
    inline const ::Deployment::ResourceUsageKinds& resourceUsage () const;
    inline ::Deployment::ResourceUsageKinds& resourceUsage ();

    inline void resourcePort (const std::string& _resourcePort);
    inline void resourcePort (std::string&& _resourcePort);
    inline const std::string& resourcePort () const;
    inline std::string& resourcePort ();

    inline void componentPort (const std::string& _componentPort);
    inline void componentPort (std::string&& _componentPort);
    inline const std::string& componentPort () const;
    inline std::string& componentPort ();

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void resourceType (const std::string& _resourceType);
    inline void resourceType (std::string&& _resourceType);
    inline const std::string& resourceType () const;
    inline std::string& resourceType ();

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();

    inline void swap (ImplementationRequirement& s);

  private:
    ::Deployment::ResourceUsageKinds resourceUsage_;
    std::string resourcePort_;
    std::string componentPort_;
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  };// ImplementationRequirement

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < ImplementationRequirement> ImplementationRequirements;

  // generated from c++11/templates/cli/hdr/struct_pre.erb
  class Capability
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    inline Capability ();
    ~Capability () = default;
    Capability (const Capability&) = default;
    Capability (Capability&&) = default;
    explicit inline Capability (std::string name,
                         ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType,
                         ::Deployment::SatisfierProperties property);
    inline Capability& operator= (const Capability& x);
    inline Capability& operator= (Capability&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();

    inline void resourceType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _resourceType);
    inline void resourceType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _resourceType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType ();

    inline void property (const ::Deployment::SatisfierProperties& _property);
    inline void property (::Deployment::SatisfierProperties&& _property);
    inline const ::Deployment::SatisfierProperties& property () const;
    inline ::Deployment::SatisfierProperties& property ();

    inline void swap (Capability& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType_;
    ::Deployment::SatisfierProperties property_;
  };// Capability

  // generated from c++11/templates/cli/hdr/typedef.erb
  typedef std::vector < Capability> Capabilities;
}; // namespace Deployment


// generated from StubHeaderTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PROPERTY_TRAITS_)
#define _STRUCT_DEPLOYMENT_PROPERTY_TRAITS_
    template<>
    struct traits < ::Deployment::Property>
      : IDL::common_traits< ::Deployment::Property>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PROPERTY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::Property>
    // MD5            : 9FA54C1D0A4E5ABC4A2486AD7C463745
#if !defined(_ALIAS_9FA54C1D0A4E5ABC4A2486AD7C463745_TRAITS_DECL_)
#define _ALIAS_9FA54C1D0A4E5ABC4A2486AD7C463745_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::Properties>
      : IDL::common_traits< ::Deployment::Properties>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::Property> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_REQUIREMENT_TRAITS_)
#define _STRUCT_DEPLOYMENT_REQUIREMENT_TRAITS_
    template<>
    struct traits < ::Deployment::Requirement>
      : IDL::common_traits< ::Deployment::Requirement>
    {
    };
#endif // _STRUCT_DEPLOYMENT_REQUIREMENT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::Requirement>
    // MD5            : B5D61CF43DC976264FCA09DAEF6B439D
#if !defined(_ALIAS_B5D61CF43DC976264FCA09DAEF6B439D_TRAITS_DECL_)
#define _ALIAS_B5D61CF43DC976264FCA09DAEF6B439D_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::Requirements>
      : IDL::common_traits< ::Deployment::Requirements>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::Requirement> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::SatisfierPropertyKind>
      : IDL::common_traits< ::Deployment::SatisfierPropertyKind>
    {
    };

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_SATISFIERPROPERTY_TRAITS_)
#define _STRUCT_DEPLOYMENT_SATISFIERPROPERTY_TRAITS_
    template<>
    struct traits < ::Deployment::SatisfierProperty>
      : IDL::common_traits< ::Deployment::SatisfierProperty>
    {
    };
#endif // _STRUCT_DEPLOYMENT_SATISFIERPROPERTY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::SatisfierProperty>
    // MD5            : AAB77A9CDD8FCC93D26F3C8F9DA5CB57
#if !defined(_ALIAS_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_TRAITS_DECL_)
#define _ALIAS_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::SatisfierProperties>
      : IDL::common_traits< ::Deployment::SatisfierProperties>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::SatisfierProperty> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::CCMComponentPortKind>
      : IDL::common_traits< ::Deployment::CCMComponentPortKind>
    {
    };

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTPORTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTPORTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPortDescription>
      : IDL::common_traits< ::Deployment::ComponentPortDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTPORTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ComponentPortDescription>
    // MD5            : C5E370E71060EF02CAD31E10FF9B9A83
#if !defined(_ALIAS_C5E370E71060EF02CAD31E10FF9B9A83_TRAITS_DECL_)
#define _ALIAS_C5E370E71060EF02CAD31E10FF9B9A83_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentPortDescriptions>
      : IDL::common_traits< ::Deployment::ComponentPortDescriptions>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ComponentPortDescription> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPropertyDescription>
      : IDL::common_traits< ::Deployment::ComponentPropertyDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ComponentPropertyDescription>
    // MD5            : C38B325CAEA1E1A5249DC3C8B0654824
#if !defined(_ALIAS_C38B325CAEA1E1A5249DC3C8B0654824_TRAITS_DECL_)
#define _ALIAS_C38B325CAEA1E1A5249DC3C8B0654824_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentPropertyDescriptions>
      : IDL::common_traits< ::Deployment::ComponentPropertyDescriptions>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ComponentPropertyDescription> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTINTERFACEDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTINTERFACEDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentInterfaceDescription>
      : IDL::common_traits< ::Deployment::ComponentInterfaceDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTINTERFACEDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::MonolithicDeploymentDescription>
      : IDL::common_traits< ::Deployment::MonolithicDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::MonolithicDeploymentDescription>
    // MD5            : 80C54C15F1FCF891188F93122A3F1653
#if !defined(_ALIAS_80C54C15F1FCF891188F93122A3F1653_TRAITS_DECL_)
#define _ALIAS_80C54C15F1FCF891188F93122A3F1653_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::MonolithicDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::MonolithicDeploymentDescriptions>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::MonolithicDeploymentDescription> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::ResourceUsageKind>
      : IDL::common_traits< ::Deployment::ResourceUsageKind>
    {
    };

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::InstanceResourceDeploymentDescription>
      : IDL::common_traits< ::Deployment::InstanceResourceDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::InstanceResourceDeploymentDescription>
    // MD5            : EECAFA244583FB042136539EF2209665
#if !defined(_ALIAS_EECAFA244583FB042136539EF2209665_TRAITS_DECL_)
#define _ALIAS_EECAFA244583FB042136539EF2209665_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::InstanceResourceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::InstanceResourceDeploymentDescriptions>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::InstanceResourceDeploymentDescription> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::InstanceDeploymentDescription>
      : IDL::common_traits< ::Deployment::InstanceDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::InstanceDeploymentDescription>
    // MD5            : 5DAB54D520633DBBAAC64AB44B5264EF
#if !defined(_ALIAS_5DAB54D520633DBBAAC64AB44B5264EF_TRAITS_DECL_)
#define _ALIAS_5DAB54D520633DBBAAC64AB44B5264EF_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::InstanceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::InstanceDeploymentDescriptions>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::InstanceDeploymentDescription> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentExternalPortEndpoint>
      : IDL::common_traits< ::Deployment::ComponentExternalPortEndpoint>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ComponentExternalPortEndpoint>
    // MD5            : D55B5CF95C9426C6D2C98C3A5D478A08
#if !defined(_ALIAS_D55B5CF95C9426C6D2C98C3A5D478A08_TRAITS_DECL_)
#define _ALIAS_D55B5CF95C9426C6D2C98C3A5D478A08_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentExternalPortEndpoints>
      : IDL::common_traits< ::Deployment::ComponentExternalPortEndpoints>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ComponentExternalPortEndpoint> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::PlanSubcomponentPortEndpoint>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPortEndpoint>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanSubcomponentPortEndpoint>
    // MD5            : B166E528DC38CC7B9823B4A707AF73F7
#if !defined(_ALIAS_B166E528DC38CC7B9823B4A707AF73F7_TRAITS_DECL_)
#define _ALIAS_B166E528DC38CC7B9823B4A707AF73F7_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanSubcomponentPortEndpoints>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPortEndpoints>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_EXTERNALREFERENCEENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT_EXTERNALREFERENCEENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::ExternalReferenceEndpoint>
      : IDL::common_traits< ::Deployment::ExternalReferenceEndpoint>
    {
    };
#endif // _STRUCT_DEPLOYMENT_EXTERNALREFERENCEENDPOINT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ExternalReferenceEndpoint>
    // MD5            : 05A01CE11A8BFF9D44BAB053FE399734
#if !defined(_ALIAS_05A01CE11A8BFF9D44BAB053FE399734_TRAITS_DECL_)
#define _ALIAS_05A01CE11A8BFF9D44BAB053FE399734_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ExternalReferenceEndpoints>
      : IDL::common_traits< ::Deployment::ExternalReferenceEndpoints>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ExternalReferenceEndpoint> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ConnectionResourceDeploymentDescription>
      : IDL::common_traits< ::Deployment::ConnectionResourceDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ConnectionResourceDeploymentDescription>
    // MD5            : AF4F2101DCE0C79A0EDE886BDCAFC611
#if !defined(_ALIAS_AF4F2101DCE0C79A0EDE886BDCAFC611_TRAITS_DECL_)
#define _ALIAS_AF4F2101DCE0C79A0EDE886BDCAFC611_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ConnectionResourceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::ConnectionResourceDeploymentDescriptions>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANCONNECTIONDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANCONNECTIONDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::PlanConnectionDescription>
      : IDL::common_traits< ::Deployment::PlanConnectionDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANCONNECTIONDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanConnectionDescription>
    // MD5            : CFA31BAC8967655A8F41210E634352C1
#if !defined(_ALIAS_CFA31BAC8967655A8F41210E634352C1_TRAITS_DECL_)
#define _ALIAS_CFA31BAC8967655A8F41210E634352C1_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanConnectionDescriptions>
      : IDL::common_traits< ::Deployment::PlanConnectionDescriptions>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::PlanConnectionDescription> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_
    template<>
    struct traits < ::Deployment::PlanSubcomponentPropertyReference>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPropertyReference>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanSubcomponentPropertyReference>
    // MD5            : AEBC73EB559A636E52F4DAEA9332277F
#if !defined(_ALIAS_AEBC73EB559A636E52F4DAEA9332277F_TRAITS_DECL_)
#define _ALIAS_AEBC73EB559A636E52F4DAEA9332277F_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanSubcomponentPropertyReferences>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPropertyReferences>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::PlanSubcomponentPropertyReference> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANPROPERTYMAPPING_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANPROPERTYMAPPING_TRAITS_
    template<>
    struct traits < ::Deployment::PlanPropertyMapping>
      : IDL::common_traits< ::Deployment::PlanPropertyMapping>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANPROPERTYMAPPING_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanPropertyMapping>
    // MD5            : F12B7FF5B966394695A4C3B62A60769E
#if !defined(_ALIAS_F12B7FF5B966394695A4C3B62A60769E_TRAITS_DECL_)
#define _ALIAS_F12B7FF5B966394695A4C3B62A60769E_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanPropertyMappings>
      : IDL::common_traits< ::Deployment::PlanPropertyMappings>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::PlanPropertyMapping> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY_TRAITS_)
#define _STRUCT_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY_TRAITS_
    template<>
    struct traits < ::Deployment::ImplementationDependency>
      : IDL::common_traits< ::Deployment::ImplementationDependency>
    {
    };
#endif // _STRUCT_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ImplementationDependency>
    // MD5            : 99A76A2AEA0FB19B92F7E3C2DE89FFF6
#if !defined(_ALIAS_99A76A2AEA0FB19B92F7E3C2DE89FFF6_TRAITS_DECL_)
#define _ALIAS_99A76A2AEA0FB19B92F7E3C2DE89FFF6_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ImplementationDependencies>
      : IDL::common_traits< ::Deployment::ImplementationDependencies>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ImplementationDependency> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ResourceDeploymentDescription>
      : IDL::common_traits< ::Deployment::ResourceDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ResourceDeploymentDescription>
    // MD5            : DF993C9C6EABFC782FDDA1D9B825B8FC
#if !defined(_ALIAS_DF993C9C6EABFC782FDDA1D9B825B8FC_TRAITS_DECL_)
#define _ALIAS_DF993C9C6EABFC782FDDA1D9B825B8FC_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ResourceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::ResourceDeploymentDescriptions>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ResourceDeploymentDescription> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ArtifactDeploymentDescription>
      : IDL::common_traits< ::Deployment::ArtifactDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ArtifactDeploymentDescription>
    // MD5            : 9366314FF053E4C8C2B7FE26CA476674
#if !defined(_ALIAS_9366314FF053E4C8C2B7FE26CA476674_TRAITS_DECL_)
#define _ALIAS_9366314FF053E4C8C2B7FE26CA476674_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ArtifactDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::ArtifactDeploymentDescriptions>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ArtifactDeploymentDescription> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::PlanLocalityKind>
      : IDL::common_traits< ::Deployment::PlanLocalityKind>
    {
    };

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANLOCALITY_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANLOCALITY_TRAITS_
    template<>
    struct traits < ::Deployment::PlanLocality>
      : IDL::common_traits< ::Deployment::PlanLocality>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANLOCALITY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanLocality>
    // MD5            : DDE38066805242B88FC17943CB38328B
#if !defined(_ALIAS_DDE38066805242B88FC17943CB38328B_TRAITS_DECL_)
#define _ALIAS_DDE38066805242B88FC17943CB38328B_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanLocalities>
      : IDL::common_traits< ::Deployment::PlanLocalities>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::PlanLocality> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_DEPLOYMENTPLAN_TRAITS_)
#define _STRUCT_DEPLOYMENT_DEPLOYMENTPLAN_TRAITS_
    template<>
    struct traits < ::Deployment::DeploymentPlan>
      : IDL::common_traits< ::Deployment::DeploymentPlan>
    {
    };
#endif // _STRUCT_DEPLOYMENT_DEPLOYMENTPLAN_TRAITS_

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTPACKAGEREFERENCE_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTPACKAGEREFERENCE_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPackageReference>
      : IDL::common_traits< ::Deployment::ComponentPackageReference>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTPACKAGEREFERENCE_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ComponentPackageReference>
    // MD5            : 0C9FEC96A49604B9CC5DF59C48DE88F1
#if !defined(_ALIAS_0C9FEC96A49604B9CC5DF59C48DE88F1_TRAITS_DECL_)
#define _ALIAS_0C9FEC96A49604B9CC5DF59C48DE88F1_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentPackageReferences>
      : IDL::common_traits< ::Deployment::ComponentPackageReferences>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ComponentPackageReference> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ResourceUsageKind>
    // MD5            : 25B5A7D7E8D2341751079BEB8A44717A
#if !defined(_ALIAS_25B5A7D7E8D2341751079BEB8A44717A_TRAITS_DECL_)
#define _ALIAS_25B5A7D7E8D2341751079BEB8A44717A_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ResourceUsageKinds>
      : IDL::common_traits< ::Deployment::ResourceUsageKinds>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ResourceUsageKind> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT_TRAITS_)
#define _STRUCT_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT_TRAITS_
    template<>
    struct traits < ::Deployment::ImplementationRequirement>
      : IDL::common_traits< ::Deployment::ImplementationRequirement>
    {
    };
#endif // _STRUCT_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ImplementationRequirement>
    // MD5            : 58B3838A8CD6CA5F0D66B307C6BD6467
#if !defined(_ALIAS_58B3838A8CD6CA5F0D66B307C6BD6467_TRAITS_DECL_)
#define _ALIAS_58B3838A8CD6CA5F0D66B307C6BD6467_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ImplementationRequirements>
      : IDL::common_traits< ::Deployment::ImplementationRequirements>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::ImplementationRequirement> element_traits;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_CAPABILITY_TRAITS_)
#define _STRUCT_DEPLOYMENT_CAPABILITY_TRAITS_
    template<>
    struct traits < ::Deployment::Capability>
      : IDL::common_traits< ::Deployment::Capability>
    {
    };
#endif // _STRUCT_DEPLOYMENT_CAPABILITY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::Capability>
    // MD5            : 67A5FF62ED49ECC3F7373CDDDBC3DFAD
#if !defined(_ALIAS_67A5FF62ED49ECC3F7373CDDDBC3DFAD_TRAITS_DECL_)
#define _ALIAS_67A5FF62ED49ECC3F7373CDDDBC3DFAD_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::Capabilities>
      : IDL::common_traits< ::Deployment::Capabilities>
    {
      typedef std::false_type is_bounded;
      typedef IDL::traits< ::Deployment::Capability> element_traits;
    };

#endif
  }; // IDL
}; // TAOX11_NAMESPACE

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::Property& m1, ::Deployment::Property& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::Requirement& m1, ::Deployment::Requirement& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::SatisfierProperty& m1, ::Deployment::SatisfierProperty& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPortDescription& m1, ::Deployment::ComponentPortDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPropertyDescription& m1, ::Deployment::ComponentPropertyDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentInterfaceDescription& m1, ::Deployment::ComponentInterfaceDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::MonolithicDeploymentDescription& m1, ::Deployment::MonolithicDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::InstanceResourceDeploymentDescription& m1, ::Deployment::InstanceResourceDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::InstanceDeploymentDescription& m1, ::Deployment::InstanceDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentExternalPortEndpoint& m1, ::Deployment::ComponentExternalPortEndpoint& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanSubcomponentPortEndpoint& m1, ::Deployment::PlanSubcomponentPortEndpoint& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ExternalReferenceEndpoint& m1, ::Deployment::ExternalReferenceEndpoint& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ConnectionResourceDeploymentDescription& m1, ::Deployment::ConnectionResourceDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanConnectionDescription& m1, ::Deployment::PlanConnectionDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanSubcomponentPropertyReference& m1, ::Deployment::PlanSubcomponentPropertyReference& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanPropertyMapping& m1, ::Deployment::PlanPropertyMapping& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ImplementationDependency& m1, ::Deployment::ImplementationDependency& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ResourceDeploymentDescription& m1, ::Deployment::ResourceDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ArtifactDeploymentDescription& m1, ::Deployment::ArtifactDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanLocality& m1, ::Deployment::PlanLocality& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::DeploymentPlan& m1, ::Deployment::DeploymentPlan& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPackageReference& m1, ::Deployment::ComponentPackageReference& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ImplementationRequirement& m1, ::Deployment::ImplementationRequirement& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::Capability& m1, ::Deployment::Capability& m2);
}; // std

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::Property::Property ()
           : name_ (std::string())
           , value_ (TAOX11_NAMESPACE::CORBA::Any ())
{
}
inline Deployment::Property::Property (std::string name,
                                       TAOX11_NAMESPACE::CORBA::Any value)
           : name_ (std::move (name))
           , value_ (std::move (value))
{
}

inline void Deployment::Property::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::Property::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::Property::name () const { return this->name_; }
inline std::string& Deployment::Property::name () { return this->name_; }

inline void Deployment::Property::value (const TAOX11_NAMESPACE::CORBA::Any& _value) { this->value_ = _value; }
inline void Deployment::Property::value (TAOX11_NAMESPACE::CORBA::Any&& _value) { this->value_ = std::move (_value); }
inline const TAOX11_NAMESPACE::CORBA::Any& Deployment::Property::value () const { return this->value_; }
inline TAOX11_NAMESPACE::CORBA::Any& Deployment::Property::value () { return this->value_; }

inline ::Deployment::Property& Deployment::Property::operator= (const ::Deployment::Property& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->value_ = x.value_;
  }
  return *this;
}
inline ::Deployment::Property& Deployment::Property::operator= (::Deployment::Property&& x)
{
  this->name_ = std::move (x.name_);
  this->value_ = std::move (x.value_);
  return *this;
}

inline void Deployment::Property::swap (::Deployment::Property& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->value_, s.value_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::Requirement::Requirement ()
           : name_ (std::string())
           , resourceType_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::Requirement::Requirement (std::string name,
                                             std::string resourceType,
                                             ::Deployment::Properties property)
           : name_ (std::move (name))
           , resourceType_ (std::move (resourceType))
           , property_ (std::move (property))
{
}

inline void Deployment::Requirement::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::Requirement::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::Requirement::name () const { return this->name_; }
inline std::string& Deployment::Requirement::name () { return this->name_; }

inline void Deployment::Requirement::resourceType (const std::string& _resourceType) { this->resourceType_ = _resourceType; }
inline void Deployment::Requirement::resourceType (std::string&& _resourceType) { this->resourceType_ = std::move (_resourceType); }
inline const std::string& Deployment::Requirement::resourceType () const { return this->resourceType_; }
inline std::string& Deployment::Requirement::resourceType () { return this->resourceType_; }

inline void Deployment::Requirement::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::Requirement::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::Requirement::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::Requirement::property () { return this->property_; }

inline ::Deployment::Requirement& Deployment::Requirement::operator= (const ::Deployment::Requirement& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->resourceType_ = x.resourceType_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::Requirement& Deployment::Requirement::operator= (::Deployment::Requirement&& x)
{
  this->name_ = std::move (x.name_);
  this->resourceType_ = std::move (x.resourceType_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::Requirement::swap (::Deployment::Requirement& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::SatisfierProperty::SatisfierProperty ()
           : name_ (std::string())
           , kind_ (::Deployment::SatisfierPropertyKind::Quantity)
           , dynamic_ (false)
           , value_ (TAOX11_NAMESPACE::CORBA::Any ())
{
}
inline Deployment::SatisfierProperty::SatisfierProperty (std::string name,
                                                         ::Deployment::SatisfierPropertyKind kind,
                                                         bool dynamic,
                                                         TAOX11_NAMESPACE::CORBA::Any value)
           : name_ (std::move (name))
           , kind_ (std::move (kind))
           , dynamic_ (std::move (dynamic))
           , value_ (std::move (value))
{
}

inline void Deployment::SatisfierProperty::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::SatisfierProperty::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::SatisfierProperty::name () const { return this->name_; }
inline std::string& Deployment::SatisfierProperty::name () { return this->name_; }

inline void Deployment::SatisfierProperty::kind (::Deployment::SatisfierPropertyKind _kind) { this->kind_ = _kind; }
inline ::Deployment::SatisfierPropertyKind Deployment::SatisfierProperty::kind () const { return this->kind_; }
inline ::Deployment::SatisfierPropertyKind& Deployment::SatisfierProperty::kind () { return this->kind_; }

inline void Deployment::SatisfierProperty::dynamic (bool _dynamic) { this->dynamic_ = _dynamic; }
inline bool Deployment::SatisfierProperty::dynamic () const { return this->dynamic_; }
inline bool& Deployment::SatisfierProperty::dynamic () { return this->dynamic_; }

inline void Deployment::SatisfierProperty::value (const TAOX11_NAMESPACE::CORBA::Any& _value) { this->value_ = _value; }
inline void Deployment::SatisfierProperty::value (TAOX11_NAMESPACE::CORBA::Any&& _value) { this->value_ = std::move (_value); }
inline const TAOX11_NAMESPACE::CORBA::Any& Deployment::SatisfierProperty::value () const { return this->value_; }
inline TAOX11_NAMESPACE::CORBA::Any& Deployment::SatisfierProperty::value () { return this->value_; }

inline ::Deployment::SatisfierProperty& Deployment::SatisfierProperty::operator= (const ::Deployment::SatisfierProperty& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->kind_ = x.kind_;
    this->dynamic_ = x.dynamic_;
    this->value_ = x.value_;
  }
  return *this;
}
inline ::Deployment::SatisfierProperty& Deployment::SatisfierProperty::operator= (::Deployment::SatisfierProperty&& x)
{
  this->name_ = std::move (x.name_);
  this->kind_ = std::move (x.kind_);
  this->dynamic_ = std::move (x.dynamic_);
  this->value_ = std::move (x.value_);
  return *this;
}

inline void Deployment::SatisfierProperty::swap (::Deployment::SatisfierProperty& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->dynamic_, s.dynamic_);
  std::swap (this->value_, s.value_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentPortDescription::ComponentPortDescription ()
           : name_ (std::string())
           , specificType_ (std::string())
           , supportedType_ (std::vector < std::string> ())
           , provider_ (false)
           , exclusiveProvider_ (false)
           , exclusiveUser_ (false)
           , optional_ (false)
           , kind_ (::Deployment::CCMComponentPortKind::Facet)
           , templateParam_ (std::vector < std::string> ())
{
}
inline Deployment::ComponentPortDescription::ComponentPortDescription (std::string name,
                                                                       std::string specificType,
                                                                       ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                                                       bool provider,
                                                                       bool exclusiveProvider,
                                                                       bool exclusiveUser,
                                                                       bool optional,
                                                                       CCMComponentPortKind kind,
                                                                       ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam)
           : name_ (std::move (name))
           , specificType_ (std::move (specificType))
           , supportedType_ (std::move (supportedType))
           , provider_ (std::move (provider))
           , exclusiveProvider_ (std::move (exclusiveProvider))
           , exclusiveUser_ (std::move (exclusiveUser))
           , optional_ (std::move (optional))
           , kind_ (std::move (kind))
           , templateParam_ (std::move (templateParam))
{
}

inline void Deployment::ComponentPortDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ComponentPortDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ComponentPortDescription::name () const { return this->name_; }
inline std::string& Deployment::ComponentPortDescription::name () { return this->name_; }

inline void Deployment::ComponentPortDescription::specificType (const std::string& _specificType) { this->specificType_ = _specificType; }
inline void Deployment::ComponentPortDescription::specificType (std::string&& _specificType) { this->specificType_ = std::move (_specificType); }
inline const std::string& Deployment::ComponentPortDescription::specificType () const { return this->specificType_; }
inline std::string& Deployment::ComponentPortDescription::specificType () { return this->specificType_; }

inline void Deployment::ComponentPortDescription::supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType) { this->supportedType_ = _supportedType; }
inline void Deployment::ComponentPortDescription::supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType) { this->supportedType_ = std::move (_supportedType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::supportedType () const { return this->supportedType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::supportedType () { return this->supportedType_; }

inline void Deployment::ComponentPortDescription::provider (bool _provider) { this->provider_ = _provider; }
inline bool Deployment::ComponentPortDescription::provider () const { return this->provider_; }
inline bool& Deployment::ComponentPortDescription::provider () { return this->provider_; }

inline void Deployment::ComponentPortDescription::exclusiveProvider (bool _exclusiveProvider) { this->exclusiveProvider_ = _exclusiveProvider; }
inline bool Deployment::ComponentPortDescription::exclusiveProvider () const { return this->exclusiveProvider_; }
inline bool& Deployment::ComponentPortDescription::exclusiveProvider () { return this->exclusiveProvider_; }

inline void Deployment::ComponentPortDescription::exclusiveUser (bool _exclusiveUser) { this->exclusiveUser_ = _exclusiveUser; }
inline bool Deployment::ComponentPortDescription::exclusiveUser () const { return this->exclusiveUser_; }
inline bool& Deployment::ComponentPortDescription::exclusiveUser () { return this->exclusiveUser_; }

inline void Deployment::ComponentPortDescription::optional (bool _optional) { this->optional_ = _optional; }
inline bool Deployment::ComponentPortDescription::optional () const { return this->optional_; }
inline bool& Deployment::ComponentPortDescription::optional () { return this->optional_; }

inline void Deployment::ComponentPortDescription::kind (CCMComponentPortKind _kind) { this->kind_ = _kind; }
inline ::Deployment::CCMComponentPortKind Deployment::ComponentPortDescription::kind () const { return this->kind_; }
inline ::Deployment::CCMComponentPortKind& Deployment::ComponentPortDescription::kind () { return this->kind_; }

inline void Deployment::ComponentPortDescription::templateParam (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _templateParam) { this->templateParam_ = _templateParam; }
inline void Deployment::ComponentPortDescription::templateParam (::TAOX11_NAMESPACE::CORBA::StringSeq&& _templateParam) { this->templateParam_ = std::move (_templateParam); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::templateParam () const { return this->templateParam_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::templateParam () { return this->templateParam_; }

inline ::Deployment::ComponentPortDescription& Deployment::ComponentPortDescription::operator= (const ::Deployment::ComponentPortDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->specificType_ = x.specificType_;
    this->supportedType_ = x.supportedType_;
    this->provider_ = x.provider_;
    this->exclusiveProvider_ = x.exclusiveProvider_;
    this->exclusiveUser_ = x.exclusiveUser_;
    this->optional_ = x.optional_;
    this->kind_ = x.kind_;
    this->templateParam_ = x.templateParam_;
  }
  return *this;
}
inline ::Deployment::ComponentPortDescription& Deployment::ComponentPortDescription::operator= (::Deployment::ComponentPortDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->specificType_ = std::move (x.specificType_);
  this->supportedType_ = std::move (x.supportedType_);
  this->provider_ = std::move (x.provider_);
  this->exclusiveProvider_ = std::move (x.exclusiveProvider_);
  this->exclusiveUser_ = std::move (x.exclusiveUser_);
  this->optional_ = std::move (x.optional_);
  this->kind_ = std::move (x.kind_);
  this->templateParam_ = std::move (x.templateParam_);
  return *this;
}

inline void Deployment::ComponentPortDescription::swap (::Deployment::ComponentPortDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->specificType_, s.specificType_);
  std::swap (this->supportedType_, s.supportedType_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->exclusiveProvider_, s.exclusiveProvider_);
  std::swap (this->exclusiveUser_, s.exclusiveUser_);
  std::swap (this->optional_, s.optional_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->templateParam_, s.templateParam_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentPropertyDescription::ComponentPropertyDescription ()
           : name_ (std::string())
           , type_ (nullptr)
{
}
inline Deployment::ComponentPropertyDescription::ComponentPropertyDescription (std::string name,
                                                                               TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type)
           : name_ (std::move (name))
           , type_ (std::move (type))
{
}

inline void Deployment::ComponentPropertyDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ComponentPropertyDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ComponentPropertyDescription::name () const { return this->name_; }
inline std::string& Deployment::ComponentPropertyDescription::name () { return this->name_; }

inline void Deployment::ComponentPropertyDescription::type (TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type _type) { this->type_ = _type; }
inline TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type Deployment::ComponentPropertyDescription::type () const { return this->type_; }
inline TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type& Deployment::ComponentPropertyDescription::type () { return this->type_; }

inline ::Deployment::ComponentPropertyDescription& Deployment::ComponentPropertyDescription::operator= (const ::Deployment::ComponentPropertyDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->type_ = x.type_;
  }
  return *this;
}
inline ::Deployment::ComponentPropertyDescription& Deployment::ComponentPropertyDescription::operator= (::Deployment::ComponentPropertyDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->type_ = std::move (x.type_);
  return *this;
}

inline void Deployment::ComponentPropertyDescription::swap (::Deployment::ComponentPropertyDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->type_, s.type_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentInterfaceDescription::ComponentInterfaceDescription ()
           : label_ (std::string())
           , UUID_ (std::string())
           , specificType_ (std::string())
           , supportedType_ (std::vector < std::string> ())
           , idlFile_ (std::vector < std::string> ())
           , configProperty_ (std::vector < ::Deployment::Property> ())
           , port_ (std::vector < ::Deployment::ComponentPortDescription> ())
           , property_ (std::vector < ::Deployment::ComponentPropertyDescription> ())
           , infoProperty_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::ComponentInterfaceDescription::ComponentInterfaceDescription (std::string label,
                                                                                 std::string UUID,
                                                                                 std::string specificType,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile,
                                                                                 ::Deployment::Properties configProperty,
                                                                                 ::Deployment::ComponentPortDescriptions port,
                                                                                 ::Deployment::ComponentPropertyDescriptions property,
                                                                                 ::Deployment::Properties infoProperty)
           : label_ (std::move (label))
           , UUID_ (std::move (UUID))
           , specificType_ (std::move (specificType))
           , supportedType_ (std::move (supportedType))
           , idlFile_ (std::move (idlFile))
           , configProperty_ (std::move (configProperty))
           , port_ (std::move (port))
           , property_ (std::move (property))
           , infoProperty_ (std::move (infoProperty))
{
}

inline void Deployment::ComponentInterfaceDescription::label (const std::string& _label) { this->label_ = _label; }
inline void Deployment::ComponentInterfaceDescription::label (std::string&& _label) { this->label_ = std::move (_label); }
inline const std::string& Deployment::ComponentInterfaceDescription::label () const { return this->label_; }
inline std::string& Deployment::ComponentInterfaceDescription::label () { return this->label_; }

inline void Deployment::ComponentInterfaceDescription::UUID (const std::string& _UUID) { this->UUID_ = _UUID; }
inline void Deployment::ComponentInterfaceDescription::UUID (std::string&& _UUID) { this->UUID_ = std::move (_UUID); }
inline const std::string& Deployment::ComponentInterfaceDescription::UUID () const { return this->UUID_; }
inline std::string& Deployment::ComponentInterfaceDescription::UUID () { return this->UUID_; }

inline void Deployment::ComponentInterfaceDescription::specificType (const std::string& _specificType) { this->specificType_ = _specificType; }
inline void Deployment::ComponentInterfaceDescription::specificType (std::string&& _specificType) { this->specificType_ = std::move (_specificType); }
inline const std::string& Deployment::ComponentInterfaceDescription::specificType () const { return this->specificType_; }
inline std::string& Deployment::ComponentInterfaceDescription::specificType () { return this->specificType_; }

inline void Deployment::ComponentInterfaceDescription::supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType) { this->supportedType_ = _supportedType; }
inline void Deployment::ComponentInterfaceDescription::supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType) { this->supportedType_ = std::move (_supportedType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::supportedType () const { return this->supportedType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::supportedType () { return this->supportedType_; }

inline void Deployment::ComponentInterfaceDescription::idlFile (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _idlFile) { this->idlFile_ = _idlFile; }
inline void Deployment::ComponentInterfaceDescription::idlFile (::TAOX11_NAMESPACE::CORBA::StringSeq&& _idlFile) { this->idlFile_ = std::move (_idlFile); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::idlFile () const { return this->idlFile_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::idlFile () { return this->idlFile_; }

inline void Deployment::ComponentInterfaceDescription::configProperty (const ::Deployment::Properties& _configProperty) { this->configProperty_ = _configProperty; }
inline void Deployment::ComponentInterfaceDescription::configProperty (::Deployment::Properties&& _configProperty) { this->configProperty_ = std::move (_configProperty); }
inline const ::Deployment::Properties& Deployment::ComponentInterfaceDescription::configProperty () const { return this->configProperty_; }
inline ::Deployment::Properties& Deployment::ComponentInterfaceDescription::configProperty () { return this->configProperty_; }

inline void Deployment::ComponentInterfaceDescription::port (const ::Deployment::ComponentPortDescriptions& _port) { this->port_ = _port; }
inline void Deployment::ComponentInterfaceDescription::port (::Deployment::ComponentPortDescriptions&& _port) { this->port_ = std::move (_port); }
inline const ::Deployment::ComponentPortDescriptions& Deployment::ComponentInterfaceDescription::port () const { return this->port_; }
inline ::Deployment::ComponentPortDescriptions& Deployment::ComponentInterfaceDescription::port () { return this->port_; }

inline void Deployment::ComponentInterfaceDescription::property (const ::Deployment::ComponentPropertyDescriptions& _property) { this->property_ = _property; }
inline void Deployment::ComponentInterfaceDescription::property (::Deployment::ComponentPropertyDescriptions&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::ComponentPropertyDescriptions& Deployment::ComponentInterfaceDescription::property () const { return this->property_; }
inline ::Deployment::ComponentPropertyDescriptions& Deployment::ComponentInterfaceDescription::property () { return this->property_; }

inline void Deployment::ComponentInterfaceDescription::infoProperty (const ::Deployment::Properties& _infoProperty) { this->infoProperty_ = _infoProperty; }
inline void Deployment::ComponentInterfaceDescription::infoProperty (::Deployment::Properties&& _infoProperty) { this->infoProperty_ = std::move (_infoProperty); }
inline const ::Deployment::Properties& Deployment::ComponentInterfaceDescription::infoProperty () const { return this->infoProperty_; }
inline ::Deployment::Properties& Deployment::ComponentInterfaceDescription::infoProperty () { return this->infoProperty_; }

inline ::Deployment::ComponentInterfaceDescription& Deployment::ComponentInterfaceDescription::operator= (const ::Deployment::ComponentInterfaceDescription& x)
{
  if (this != &x) {
    this->label_ = x.label_;
    this->UUID_ = x.UUID_;
    this->specificType_ = x.specificType_;
    this->supportedType_ = x.supportedType_;
    this->idlFile_ = x.idlFile_;
    this->configProperty_ = x.configProperty_;
    this->port_ = x.port_;
    this->property_ = x.property_;
    this->infoProperty_ = x.infoProperty_;
  }
  return *this;
}
inline ::Deployment::ComponentInterfaceDescription& Deployment::ComponentInterfaceDescription::operator= (::Deployment::ComponentInterfaceDescription&& x)
{
  this->label_ = std::move (x.label_);
  this->UUID_ = std::move (x.UUID_);
  this->specificType_ = std::move (x.specificType_);
  this->supportedType_ = std::move (x.supportedType_);
  this->idlFile_ = std::move (x.idlFile_);
  this->configProperty_ = std::move (x.configProperty_);
  this->port_ = std::move (x.port_);
  this->property_ = std::move (x.property_);
  this->infoProperty_ = std::move (x.infoProperty_);
  return *this;
}

inline void Deployment::ComponentInterfaceDescription::swap (::Deployment::ComponentInterfaceDescription& s)
{
  std::swap (this->label_, s.label_);
  std::swap (this->UUID_, s.UUID_);
  std::swap (this->specificType_, s.specificType_);
  std::swap (this->supportedType_, s.supportedType_);
  std::swap (this->idlFile_, s.idlFile_);
  std::swap (this->configProperty_, s.configProperty_);
  std::swap (this->port_, s.port_);
  std::swap (this->property_, s.property_);
  std::swap (this->infoProperty_, s.infoProperty_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::MonolithicDeploymentDescription::MonolithicDeploymentDescription ()
           : name_ (std::string())
           , source_ (std::vector < std::string> ())
           , artifactRef_ (std::vector < uint32_t> ())
           , execParameter_ (std::vector < ::Deployment::Property> ())
           , deployRequirement_ (std::vector < ::Deployment::Requirement> ())
{
}
inline Deployment::MonolithicDeploymentDescription::MonolithicDeploymentDescription (std::string name,
                                                                                     ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                                                     ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef,
                                                                                     ::Deployment::Properties execParameter,
                                                                                     ::Deployment::Requirements deployRequirement)
           : name_ (std::move (name))
           , source_ (std::move (source))
           , artifactRef_ (std::move (artifactRef))
           , execParameter_ (std::move (execParameter))
           , deployRequirement_ (std::move (deployRequirement))
{
}

inline void Deployment::MonolithicDeploymentDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::MonolithicDeploymentDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::MonolithicDeploymentDescription::name () const { return this->name_; }
inline std::string& Deployment::MonolithicDeploymentDescription::name () { return this->name_; }

inline void Deployment::MonolithicDeploymentDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::MonolithicDeploymentDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::MonolithicDeploymentDescription::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::MonolithicDeploymentDescription::source () { return this->source_; }

inline void Deployment::MonolithicDeploymentDescription::artifactRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _artifactRef) { this->artifactRef_ = _artifactRef; }
inline void Deployment::MonolithicDeploymentDescription::artifactRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _artifactRef) { this->artifactRef_ = std::move (_artifactRef); }
inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::MonolithicDeploymentDescription::artifactRef () const { return this->artifactRef_; }
inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::MonolithicDeploymentDescription::artifactRef () { return this->artifactRef_; }

inline void Deployment::MonolithicDeploymentDescription::execParameter (const ::Deployment::Properties& _execParameter) { this->execParameter_ = _execParameter; }
inline void Deployment::MonolithicDeploymentDescription::execParameter (::Deployment::Properties&& _execParameter) { this->execParameter_ = std::move (_execParameter); }
inline const ::Deployment::Properties& Deployment::MonolithicDeploymentDescription::execParameter () const { return this->execParameter_; }
inline ::Deployment::Properties& Deployment::MonolithicDeploymentDescription::execParameter () { return this->execParameter_; }

inline void Deployment::MonolithicDeploymentDescription::deployRequirement (const ::Deployment::Requirements& _deployRequirement) { this->deployRequirement_ = _deployRequirement; }
inline void Deployment::MonolithicDeploymentDescription::deployRequirement (::Deployment::Requirements&& _deployRequirement) { this->deployRequirement_ = std::move (_deployRequirement); }
inline const ::Deployment::Requirements& Deployment::MonolithicDeploymentDescription::deployRequirement () const { return this->deployRequirement_; }
inline ::Deployment::Requirements& Deployment::MonolithicDeploymentDescription::deployRequirement () { return this->deployRequirement_; }

inline ::Deployment::MonolithicDeploymentDescription& Deployment::MonolithicDeploymentDescription::operator= (const ::Deployment::MonolithicDeploymentDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->source_ = x.source_;
    this->artifactRef_ = x.artifactRef_;
    this->execParameter_ = x.execParameter_;
    this->deployRequirement_ = x.deployRequirement_;
  }
  return *this;
}
inline ::Deployment::MonolithicDeploymentDescription& Deployment::MonolithicDeploymentDescription::operator= (::Deployment::MonolithicDeploymentDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->source_ = std::move (x.source_);
  this->artifactRef_ = std::move (x.artifactRef_);
  this->execParameter_ = std::move (x.execParameter_);
  this->deployRequirement_ = std::move (x.deployRequirement_);
  return *this;
}

inline void Deployment::MonolithicDeploymentDescription::swap (::Deployment::MonolithicDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->artifactRef_, s.artifactRef_);
  std::swap (this->execParameter_, s.execParameter_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription ()
           : resourceUsage_ (::Deployment::ResourceUsageKind::None)
           , requirementName_ (std::string())
           , resourceName_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription (::Deployment::ResourceUsageKind resourceUsage,
                                                                                                 std::string requirementName,
                                                                                                 std::string resourceName,
                                                                                                 ::Deployment::Properties property)
           : resourceUsage_ (std::move (resourceUsage))
           , requirementName_ (std::move (requirementName))
           , resourceName_ (std::move (resourceName))
           , property_ (std::move (property))
{
}

inline void Deployment::InstanceResourceDeploymentDescription::resourceUsage (::Deployment::ResourceUsageKind _resourceUsage) { this->resourceUsage_ = _resourceUsage; }
inline ::Deployment::ResourceUsageKind Deployment::InstanceResourceDeploymentDescription::resourceUsage () const { return this->resourceUsage_; }
inline ::Deployment::ResourceUsageKind& Deployment::InstanceResourceDeploymentDescription::resourceUsage () { return this->resourceUsage_; }

inline void Deployment::InstanceResourceDeploymentDescription::requirementName (const std::string& _requirementName) { this->requirementName_ = _requirementName; }
inline void Deployment::InstanceResourceDeploymentDescription::requirementName (std::string&& _requirementName) { this->requirementName_ = std::move (_requirementName); }
inline const std::string& Deployment::InstanceResourceDeploymentDescription::requirementName () const { return this->requirementName_; }
inline std::string& Deployment::InstanceResourceDeploymentDescription::requirementName () { return this->requirementName_; }

inline void Deployment::InstanceResourceDeploymentDescription::resourceName (const std::string& _resourceName) { this->resourceName_ = _resourceName; }
inline void Deployment::InstanceResourceDeploymentDescription::resourceName (std::string&& _resourceName) { this->resourceName_ = std::move (_resourceName); }
inline const std::string& Deployment::InstanceResourceDeploymentDescription::resourceName () const { return this->resourceName_; }
inline std::string& Deployment::InstanceResourceDeploymentDescription::resourceName () { return this->resourceName_; }

inline void Deployment::InstanceResourceDeploymentDescription::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::InstanceResourceDeploymentDescription::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::InstanceResourceDeploymentDescription::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::InstanceResourceDeploymentDescription::property () { return this->property_; }

inline ::Deployment::InstanceResourceDeploymentDescription& Deployment::InstanceResourceDeploymentDescription::operator= (const ::Deployment::InstanceResourceDeploymentDescription& x)
{
  if (this != &x) {
    this->resourceUsage_ = x.resourceUsage_;
    this->requirementName_ = x.requirementName_;
    this->resourceName_ = x.resourceName_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::InstanceResourceDeploymentDescription& Deployment::InstanceResourceDeploymentDescription::operator= (::Deployment::InstanceResourceDeploymentDescription&& x)
{
  this->resourceUsage_ = std::move (x.resourceUsage_);
  this->requirementName_ = std::move (x.requirementName_);
  this->resourceName_ = std::move (x.resourceName_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::InstanceResourceDeploymentDescription::swap (::Deployment::InstanceResourceDeploymentDescription& s)
{
  std::swap (this->resourceUsage_, s.resourceUsage_);
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::InstanceDeploymentDescription::InstanceDeploymentDescription ()
           : name_ (std::string())
           , node_ (std::string())
           , source_ (std::vector < std::string> ())
           , implementationRef_ (0)
           , configProperty_ (std::vector < ::Deployment::Property> ())
           , deployedResource_ (std::vector < ::Deployment::InstanceResourceDeploymentDescription> ())
           , deployedSharedResource_ (std::vector < ::Deployment::InstanceResourceDeploymentDescription> ())
{
}
inline Deployment::InstanceDeploymentDescription::InstanceDeploymentDescription (std::string name,
                                                                                 std::string node,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                                                 uint32_t implementationRef,
                                                                                 ::Deployment::Properties configProperty,
                                                                                 ::Deployment::InstanceResourceDeploymentDescriptions deployedResource,
                                                                                 ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource)
           : name_ (std::move (name))
           , node_ (std::move (node))
           , source_ (std::move (source))
           , implementationRef_ (std::move (implementationRef))
           , configProperty_ (std::move (configProperty))
           , deployedResource_ (std::move (deployedResource))
           , deployedSharedResource_ (std::move (deployedSharedResource))
{
}

inline void Deployment::InstanceDeploymentDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::InstanceDeploymentDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::InstanceDeploymentDescription::name () const { return this->name_; }
inline std::string& Deployment::InstanceDeploymentDescription::name () { return this->name_; }

inline void Deployment::InstanceDeploymentDescription::node (const std::string& _node) { this->node_ = _node; }
inline void Deployment::InstanceDeploymentDescription::node (std::string&& _node) { this->node_ = std::move (_node); }
inline const std::string& Deployment::InstanceDeploymentDescription::node () const { return this->node_; }
inline std::string& Deployment::InstanceDeploymentDescription::node () { return this->node_; }

inline void Deployment::InstanceDeploymentDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::InstanceDeploymentDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::InstanceDeploymentDescription::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::InstanceDeploymentDescription::source () { return this->source_; }

inline void Deployment::InstanceDeploymentDescription::implementationRef (uint32_t _implementationRef) { this->implementationRef_ = _implementationRef; }
inline uint32_t Deployment::InstanceDeploymentDescription::implementationRef () const { return this->implementationRef_; }
inline uint32_t& Deployment::InstanceDeploymentDescription::implementationRef () { return this->implementationRef_; }

inline void Deployment::InstanceDeploymentDescription::configProperty (const ::Deployment::Properties& _configProperty) { this->configProperty_ = _configProperty; }
inline void Deployment::InstanceDeploymentDescription::configProperty (::Deployment::Properties&& _configProperty) { this->configProperty_ = std::move (_configProperty); }
inline const ::Deployment::Properties& Deployment::InstanceDeploymentDescription::configProperty () const { return this->configProperty_; }
inline ::Deployment::Properties& Deployment::InstanceDeploymentDescription::configProperty () { return this->configProperty_; }

inline void Deployment::InstanceDeploymentDescription::deployedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedResource) { this->deployedResource_ = _deployedResource; }
inline void Deployment::InstanceDeploymentDescription::deployedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedResource) { this->deployedResource_ = std::move (_deployedResource); }
inline const ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedResource () const { return this->deployedResource_; }
inline ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedResource () { return this->deployedResource_; }

inline void Deployment::InstanceDeploymentDescription::deployedSharedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedSharedResource) { this->deployedSharedResource_ = _deployedSharedResource; }
inline void Deployment::InstanceDeploymentDescription::deployedSharedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedSharedResource) { this->deployedSharedResource_ = std::move (_deployedSharedResource); }
inline const ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedSharedResource () const { return this->deployedSharedResource_; }
inline ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedSharedResource () { return this->deployedSharedResource_; }

inline ::Deployment::InstanceDeploymentDescription& Deployment::InstanceDeploymentDescription::operator= (const ::Deployment::InstanceDeploymentDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->node_ = x.node_;
    this->source_ = x.source_;
    this->implementationRef_ = x.implementationRef_;
    this->configProperty_ = x.configProperty_;
    this->deployedResource_ = x.deployedResource_;
    this->deployedSharedResource_ = x.deployedSharedResource_;
  }
  return *this;
}
inline ::Deployment::InstanceDeploymentDescription& Deployment::InstanceDeploymentDescription::operator= (::Deployment::InstanceDeploymentDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->node_ = std::move (x.node_);
  this->source_ = std::move (x.source_);
  this->implementationRef_ = std::move (x.implementationRef_);
  this->configProperty_ = std::move (x.configProperty_);
  this->deployedResource_ = std::move (x.deployedResource_);
  this->deployedSharedResource_ = std::move (x.deployedSharedResource_);
  return *this;
}

inline void Deployment::InstanceDeploymentDescription::swap (::Deployment::InstanceDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->node_, s.node_);
  std::swap (this->source_, s.source_);
  std::swap (this->implementationRef_, s.implementationRef_);
  std::swap (this->configProperty_, s.configProperty_);
  std::swap (this->deployedResource_, s.deployedResource_);
  std::swap (this->deployedSharedResource_, s.deployedSharedResource_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentExternalPortEndpoint::ComponentExternalPortEndpoint ()
           : portName_ (std::string())
{
}
inline Deployment::ComponentExternalPortEndpoint::ComponentExternalPortEndpoint (std::string portName)
           : portName_ (std::move (portName))
{
}

inline void Deployment::ComponentExternalPortEndpoint::portName (const std::string& _portName) { this->portName_ = _portName; }
inline void Deployment::ComponentExternalPortEndpoint::portName (std::string&& _portName) { this->portName_ = std::move (_portName); }
inline const std::string& Deployment::ComponentExternalPortEndpoint::portName () const { return this->portName_; }
inline std::string& Deployment::ComponentExternalPortEndpoint::portName () { return this->portName_; }

inline ::Deployment::ComponentExternalPortEndpoint& Deployment::ComponentExternalPortEndpoint::operator= (const ::Deployment::ComponentExternalPortEndpoint& x)
{
  if (this != &x) {
    this->portName_ = x.portName_;
  }
  return *this;
}
inline ::Deployment::ComponentExternalPortEndpoint& Deployment::ComponentExternalPortEndpoint::operator= (::Deployment::ComponentExternalPortEndpoint&& x)
{
  this->portName_ = std::move (x.portName_);
  return *this;
}

inline void Deployment::ComponentExternalPortEndpoint::swap (::Deployment::ComponentExternalPortEndpoint& s)
{
  std::swap (this->portName_, s.portName_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint ()
           : portName_ (std::string())
           , provider_ (false)
           , kind_ (::Deployment::CCMComponentPortKind::Facet)
           , instanceRef_ (0)
{
}
inline Deployment::PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint (std::string portName,
                                                                               bool provider,
                                                                               ::Deployment::CCMComponentPortKind kind,
                                                                               uint32_t instanceRef)
           : portName_ (std::move (portName))
           , provider_ (std::move (provider))
           , kind_ (std::move (kind))
           , instanceRef_ (std::move (instanceRef))
{
}

inline void Deployment::PlanSubcomponentPortEndpoint::portName (const std::string& _portName) { this->portName_ = _portName; }
inline void Deployment::PlanSubcomponentPortEndpoint::portName (std::string&& _portName) { this->portName_ = std::move (_portName); }
inline const std::string& Deployment::PlanSubcomponentPortEndpoint::portName () const { return this->portName_; }
inline std::string& Deployment::PlanSubcomponentPortEndpoint::portName () { return this->portName_; }

inline void Deployment::PlanSubcomponentPortEndpoint::provider (bool _provider) { this->provider_ = _provider; }
inline bool Deployment::PlanSubcomponentPortEndpoint::provider () const { return this->provider_; }
inline bool& Deployment::PlanSubcomponentPortEndpoint::provider () { return this->provider_; }

inline void Deployment::PlanSubcomponentPortEndpoint::kind (::Deployment::CCMComponentPortKind _kind) { this->kind_ = _kind; }
inline ::Deployment::CCMComponentPortKind Deployment::PlanSubcomponentPortEndpoint::kind () const { return this->kind_; }
inline ::Deployment::CCMComponentPortKind& Deployment::PlanSubcomponentPortEndpoint::kind () { return this->kind_; }

inline void Deployment::PlanSubcomponentPortEndpoint::instanceRef (uint32_t _instanceRef) { this->instanceRef_ = _instanceRef; }
inline uint32_t Deployment::PlanSubcomponentPortEndpoint::instanceRef () const { return this->instanceRef_; }
inline uint32_t& Deployment::PlanSubcomponentPortEndpoint::instanceRef () { return this->instanceRef_; }

inline ::Deployment::PlanSubcomponentPortEndpoint& Deployment::PlanSubcomponentPortEndpoint::operator= (const ::Deployment::PlanSubcomponentPortEndpoint& x)
{
  if (this != &x) {
    this->portName_ = x.portName_;
    this->provider_ = x.provider_;
    this->kind_ = x.kind_;
    this->instanceRef_ = x.instanceRef_;
  }
  return *this;
}
inline ::Deployment::PlanSubcomponentPortEndpoint& Deployment::PlanSubcomponentPortEndpoint::operator= (::Deployment::PlanSubcomponentPortEndpoint&& x)
{
  this->portName_ = std::move (x.portName_);
  this->provider_ = std::move (x.provider_);
  this->kind_ = std::move (x.kind_);
  this->instanceRef_ = std::move (x.instanceRef_);
  return *this;
}

inline void Deployment::PlanSubcomponentPortEndpoint::swap (::Deployment::PlanSubcomponentPortEndpoint& s)
{
  std::swap (this->portName_, s.portName_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->instanceRef_, s.instanceRef_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ExternalReferenceEndpoint::ExternalReferenceEndpoint ()
           : location_ (std::string())
           , provider_ (false)
           , portName_ (std::string())
           , supportedType_ (std::vector < std::string> ())
{
}
inline Deployment::ExternalReferenceEndpoint::ExternalReferenceEndpoint (std::string location,
                                                                         bool provider,
                                                                         std::string portName,
                                                                         ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType)
           : location_ (std::move (location))
           , provider_ (std::move (provider))
           , portName_ (std::move (portName))
           , supportedType_ (std::move (supportedType))
{
}

inline void Deployment::ExternalReferenceEndpoint::location (const std::string& _location) { this->location_ = _location; }
inline void Deployment::ExternalReferenceEndpoint::location (std::string&& _location) { this->location_ = std::move (_location); }
inline const std::string& Deployment::ExternalReferenceEndpoint::location () const { return this->location_; }
inline std::string& Deployment::ExternalReferenceEndpoint::location () { return this->location_; }

inline void Deployment::ExternalReferenceEndpoint::provider (bool _provider) { this->provider_ = _provider; }
inline bool Deployment::ExternalReferenceEndpoint::provider () const { return this->provider_; }
inline bool& Deployment::ExternalReferenceEndpoint::provider () { return this->provider_; }

inline void Deployment::ExternalReferenceEndpoint::portName (const std::string& _portName) { this->portName_ = _portName; }
inline void Deployment::ExternalReferenceEndpoint::portName (std::string&& _portName) { this->portName_ = std::move (_portName); }
inline const std::string& Deployment::ExternalReferenceEndpoint::portName () const { return this->portName_; }
inline std::string& Deployment::ExternalReferenceEndpoint::portName () { return this->portName_; }

inline void Deployment::ExternalReferenceEndpoint::supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType) { this->supportedType_ = _supportedType; }
inline void Deployment::ExternalReferenceEndpoint::supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType) { this->supportedType_ = std::move (_supportedType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ExternalReferenceEndpoint::supportedType () const { return this->supportedType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ExternalReferenceEndpoint::supportedType () { return this->supportedType_; }

inline ::Deployment::ExternalReferenceEndpoint& Deployment::ExternalReferenceEndpoint::operator= (const ::Deployment::ExternalReferenceEndpoint& x)
{
  if (this != &x) {
    this->location_ = x.location_;
    this->provider_ = x.provider_;
    this->portName_ = x.portName_;
    this->supportedType_ = x.supportedType_;
  }
  return *this;
}
inline ::Deployment::ExternalReferenceEndpoint& Deployment::ExternalReferenceEndpoint::operator= (::Deployment::ExternalReferenceEndpoint&& x)
{
  this->location_ = std::move (x.location_);
  this->provider_ = std::move (x.provider_);
  this->portName_ = std::move (x.portName_);
  this->supportedType_ = std::move (x.supportedType_);
  return *this;
}

inline void Deployment::ExternalReferenceEndpoint::swap (::Deployment::ExternalReferenceEndpoint& s)
{
  std::swap (this->location_, s.location_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->portName_, s.portName_);
  std::swap (this->supportedType_, s.supportedType_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription ()
           : targetName_ (std::string())
           , requirementName_ (std::string())
           , resourceName_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription (std::string targetName,
                                                                                                     std::string requirementName,
                                                                                                     std::string resourceName,
                                                                                                     ::Deployment::Properties property)
           : targetName_ (std::move (targetName))
           , requirementName_ (std::move (requirementName))
           , resourceName_ (std::move (resourceName))
           , property_ (std::move (property))
{
}

inline void Deployment::ConnectionResourceDeploymentDescription::targetName (const std::string& _targetName) { this->targetName_ = _targetName; }
inline void Deployment::ConnectionResourceDeploymentDescription::targetName (std::string&& _targetName) { this->targetName_ = std::move (_targetName); }
inline const std::string& Deployment::ConnectionResourceDeploymentDescription::targetName () const { return this->targetName_; }
inline std::string& Deployment::ConnectionResourceDeploymentDescription::targetName () { return this->targetName_; }

inline void Deployment::ConnectionResourceDeploymentDescription::requirementName (const std::string& _requirementName) { this->requirementName_ = _requirementName; }
inline void Deployment::ConnectionResourceDeploymentDescription::requirementName (std::string&& _requirementName) { this->requirementName_ = std::move (_requirementName); }
inline const std::string& Deployment::ConnectionResourceDeploymentDescription::requirementName () const { return this->requirementName_; }
inline std::string& Deployment::ConnectionResourceDeploymentDescription::requirementName () { return this->requirementName_; }

inline void Deployment::ConnectionResourceDeploymentDescription::resourceName (const std::string& _resourceName) { this->resourceName_ = _resourceName; }
inline void Deployment::ConnectionResourceDeploymentDescription::resourceName (std::string&& _resourceName) { this->resourceName_ = std::move (_resourceName); }
inline const std::string& Deployment::ConnectionResourceDeploymentDescription::resourceName () const { return this->resourceName_; }
inline std::string& Deployment::ConnectionResourceDeploymentDescription::resourceName () { return this->resourceName_; }

inline void Deployment::ConnectionResourceDeploymentDescription::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::ConnectionResourceDeploymentDescription::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::ConnectionResourceDeploymentDescription::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::ConnectionResourceDeploymentDescription::property () { return this->property_; }

inline ::Deployment::ConnectionResourceDeploymentDescription& Deployment::ConnectionResourceDeploymentDescription::operator= (const ::Deployment::ConnectionResourceDeploymentDescription& x)
{
  if (this != &x) {
    this->targetName_ = x.targetName_;
    this->requirementName_ = x.requirementName_;
    this->resourceName_ = x.resourceName_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::ConnectionResourceDeploymentDescription& Deployment::ConnectionResourceDeploymentDescription::operator= (::Deployment::ConnectionResourceDeploymentDescription&& x)
{
  this->targetName_ = std::move (x.targetName_);
  this->requirementName_ = std::move (x.requirementName_);
  this->resourceName_ = std::move (x.resourceName_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::ConnectionResourceDeploymentDescription::swap (::Deployment::ConnectionResourceDeploymentDescription& s)
{
  std::swap (this->targetName_, s.targetName_);
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanConnectionDescription::PlanConnectionDescription ()
           : name_ (std::string())
           , source_ (std::vector < std::string> ())
           , deployRequirement_ (std::vector < ::Deployment::Requirement> ())
           , externalEndpoint_ (std::vector < ::Deployment::ComponentExternalPortEndpoint> ())
           , internalEndpoint_ (std::vector < ::Deployment::PlanSubcomponentPortEndpoint> ())
           , externalReference_ (std::vector < ::Deployment::ExternalReferenceEndpoint> ())
           , deployedResource_ (std::vector < ::Deployment::ConnectionResourceDeploymentDescription> ())
{
}
inline Deployment::PlanConnectionDescription::PlanConnectionDescription (std::string name,
                                                                         ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                                         ::Deployment::Requirements deployRequirement,
                                                                         ::Deployment::ComponentExternalPortEndpoints externalEndpoint,
                                                                         ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint,
                                                                         ::Deployment::ExternalReferenceEndpoints externalReference,
                                                                         ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource)
           : name_ (std::move (name))
           , source_ (std::move (source))
           , deployRequirement_ (std::move (deployRequirement))
           , externalEndpoint_ (std::move (externalEndpoint))
           , internalEndpoint_ (std::move (internalEndpoint))
           , externalReference_ (std::move (externalReference))
           , deployedResource_ (std::move (deployedResource))
{
}

inline void Deployment::PlanConnectionDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::PlanConnectionDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::PlanConnectionDescription::name () const { return this->name_; }
inline std::string& Deployment::PlanConnectionDescription::name () { return this->name_; }

inline void Deployment::PlanConnectionDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::PlanConnectionDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanConnectionDescription::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanConnectionDescription::source () { return this->source_; }

inline void Deployment::PlanConnectionDescription::deployRequirement (const ::Deployment::Requirements& _deployRequirement) { this->deployRequirement_ = _deployRequirement; }
inline void Deployment::PlanConnectionDescription::deployRequirement (::Deployment::Requirements&& _deployRequirement) { this->deployRequirement_ = std::move (_deployRequirement); }
inline const ::Deployment::Requirements& Deployment::PlanConnectionDescription::deployRequirement () const { return this->deployRequirement_; }
inline ::Deployment::Requirements& Deployment::PlanConnectionDescription::deployRequirement () { return this->deployRequirement_; }

inline void Deployment::PlanConnectionDescription::externalEndpoint (const ::Deployment::ComponentExternalPortEndpoints& _externalEndpoint) { this->externalEndpoint_ = _externalEndpoint; }
inline void Deployment::PlanConnectionDescription::externalEndpoint (::Deployment::ComponentExternalPortEndpoints&& _externalEndpoint) { this->externalEndpoint_ = std::move (_externalEndpoint); }
inline const ::Deployment::ComponentExternalPortEndpoints& Deployment::PlanConnectionDescription::externalEndpoint () const { return this->externalEndpoint_; }
inline ::Deployment::ComponentExternalPortEndpoints& Deployment::PlanConnectionDescription::externalEndpoint () { return this->externalEndpoint_; }

inline void Deployment::PlanConnectionDescription::internalEndpoint (const ::Deployment::PlanSubcomponentPortEndpoints& _internalEndpoint) { this->internalEndpoint_ = _internalEndpoint; }
inline void Deployment::PlanConnectionDescription::internalEndpoint (::Deployment::PlanSubcomponentPortEndpoints&& _internalEndpoint) { this->internalEndpoint_ = std::move (_internalEndpoint); }
inline const ::Deployment::PlanSubcomponentPortEndpoints& Deployment::PlanConnectionDescription::internalEndpoint () const { return this->internalEndpoint_; }
inline ::Deployment::PlanSubcomponentPortEndpoints& Deployment::PlanConnectionDescription::internalEndpoint () { return this->internalEndpoint_; }

inline void Deployment::PlanConnectionDescription::externalReference (const ::Deployment::ExternalReferenceEndpoints& _externalReference) { this->externalReference_ = _externalReference; }
inline void Deployment::PlanConnectionDescription::externalReference (::Deployment::ExternalReferenceEndpoints&& _externalReference) { this->externalReference_ = std::move (_externalReference); }
inline const ::Deployment::ExternalReferenceEndpoints& Deployment::PlanConnectionDescription::externalReference () const { return this->externalReference_; }
inline ::Deployment::ExternalReferenceEndpoints& Deployment::PlanConnectionDescription::externalReference () { return this->externalReference_; }

inline void Deployment::PlanConnectionDescription::deployedResource (const ::Deployment::ConnectionResourceDeploymentDescriptions& _deployedResource) { this->deployedResource_ = _deployedResource; }
inline void Deployment::PlanConnectionDescription::deployedResource (::Deployment::ConnectionResourceDeploymentDescriptions&& _deployedResource) { this->deployedResource_ = std::move (_deployedResource); }
inline const ::Deployment::ConnectionResourceDeploymentDescriptions& Deployment::PlanConnectionDescription::deployedResource () const { return this->deployedResource_; }
inline ::Deployment::ConnectionResourceDeploymentDescriptions& Deployment::PlanConnectionDescription::deployedResource () { return this->deployedResource_; }

inline ::Deployment::PlanConnectionDescription& Deployment::PlanConnectionDescription::operator= (const ::Deployment::PlanConnectionDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->source_ = x.source_;
    this->deployRequirement_ = x.deployRequirement_;
    this->externalEndpoint_ = x.externalEndpoint_;
    this->internalEndpoint_ = x.internalEndpoint_;
    this->externalReference_ = x.externalReference_;
    this->deployedResource_ = x.deployedResource_;
  }
  return *this;
}
inline ::Deployment::PlanConnectionDescription& Deployment::PlanConnectionDescription::operator= (::Deployment::PlanConnectionDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->source_ = std::move (x.source_);
  this->deployRequirement_ = std::move (x.deployRequirement_);
  this->externalEndpoint_ = std::move (x.externalEndpoint_);
  this->internalEndpoint_ = std::move (x.internalEndpoint_);
  this->externalReference_ = std::move (x.externalReference_);
  this->deployedResource_ = std::move (x.deployedResource_);
  return *this;
}

inline void Deployment::PlanConnectionDescription::swap (::Deployment::PlanConnectionDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
  std::swap (this->externalEndpoint_, s.externalEndpoint_);
  std::swap (this->internalEndpoint_, s.internalEndpoint_);
  std::swap (this->externalReference_, s.externalReference_);
  std::swap (this->deployedResource_, s.deployedResource_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanSubcomponentPropertyReference::PlanSubcomponentPropertyReference ()
           : propertyName_ (std::string())
           , instanceRef_ (0)
{
}
inline Deployment::PlanSubcomponentPropertyReference::PlanSubcomponentPropertyReference (std::string propertyName,
                                                                                         uint32_t instanceRef)
           : propertyName_ (std::move (propertyName))
           , instanceRef_ (std::move (instanceRef))
{
}

inline void Deployment::PlanSubcomponentPropertyReference::propertyName (const std::string& _propertyName) { this->propertyName_ = _propertyName; }
inline void Deployment::PlanSubcomponentPropertyReference::propertyName (std::string&& _propertyName) { this->propertyName_ = std::move (_propertyName); }
inline const std::string& Deployment::PlanSubcomponentPropertyReference::propertyName () const { return this->propertyName_; }
inline std::string& Deployment::PlanSubcomponentPropertyReference::propertyName () { return this->propertyName_; }

inline void Deployment::PlanSubcomponentPropertyReference::instanceRef (uint32_t _instanceRef) { this->instanceRef_ = _instanceRef; }
inline uint32_t Deployment::PlanSubcomponentPropertyReference::instanceRef () const { return this->instanceRef_; }
inline uint32_t& Deployment::PlanSubcomponentPropertyReference::instanceRef () { return this->instanceRef_; }

inline ::Deployment::PlanSubcomponentPropertyReference& Deployment::PlanSubcomponentPropertyReference::operator= (const ::Deployment::PlanSubcomponentPropertyReference& x)
{
  if (this != &x) {
    this->propertyName_ = x.propertyName_;
    this->instanceRef_ = x.instanceRef_;
  }
  return *this;
}
inline ::Deployment::PlanSubcomponentPropertyReference& Deployment::PlanSubcomponentPropertyReference::operator= (::Deployment::PlanSubcomponentPropertyReference&& x)
{
  this->propertyName_ = std::move (x.propertyName_);
  this->instanceRef_ = std::move (x.instanceRef_);
  return *this;
}

inline void Deployment::PlanSubcomponentPropertyReference::swap (::Deployment::PlanSubcomponentPropertyReference& s)
{
  std::swap (this->propertyName_, s.propertyName_);
  std::swap (this->instanceRef_, s.instanceRef_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanPropertyMapping::PlanPropertyMapping ()
           : name_ (std::string())
           , source_ (std::vector < std::string> ())
           , externalName_ (std::string())
           , delegatesTo_ (std::vector < ::Deployment::PlanSubcomponentPropertyReference> ())
{
}
inline Deployment::PlanPropertyMapping::PlanPropertyMapping (std::string name,
                                                             ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                             std::string externalName,
                                                             ::Deployment::PlanSubcomponentPropertyReferences delegatesTo)
           : name_ (std::move (name))
           , source_ (std::move (source))
           , externalName_ (std::move (externalName))
           , delegatesTo_ (std::move (delegatesTo))
{
}

inline void Deployment::PlanPropertyMapping::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::PlanPropertyMapping::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::PlanPropertyMapping::name () const { return this->name_; }
inline std::string& Deployment::PlanPropertyMapping::name () { return this->name_; }

inline void Deployment::PlanPropertyMapping::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::PlanPropertyMapping::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanPropertyMapping::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanPropertyMapping::source () { return this->source_; }

inline void Deployment::PlanPropertyMapping::externalName (const std::string& _externalName) { this->externalName_ = _externalName; }
inline void Deployment::PlanPropertyMapping::externalName (std::string&& _externalName) { this->externalName_ = std::move (_externalName); }
inline const std::string& Deployment::PlanPropertyMapping::externalName () const { return this->externalName_; }
inline std::string& Deployment::PlanPropertyMapping::externalName () { return this->externalName_; }

inline void Deployment::PlanPropertyMapping::delegatesTo (const ::Deployment::PlanSubcomponentPropertyReferences& _delegatesTo) { this->delegatesTo_ = _delegatesTo; }
inline void Deployment::PlanPropertyMapping::delegatesTo (::Deployment::PlanSubcomponentPropertyReferences&& _delegatesTo) { this->delegatesTo_ = std::move (_delegatesTo); }
inline const ::Deployment::PlanSubcomponentPropertyReferences& Deployment::PlanPropertyMapping::delegatesTo () const { return this->delegatesTo_; }
inline ::Deployment::PlanSubcomponentPropertyReferences& Deployment::PlanPropertyMapping::delegatesTo () { return this->delegatesTo_; }

inline ::Deployment::PlanPropertyMapping& Deployment::PlanPropertyMapping::operator= (const ::Deployment::PlanPropertyMapping& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->source_ = x.source_;
    this->externalName_ = x.externalName_;
    this->delegatesTo_ = x.delegatesTo_;
  }
  return *this;
}
inline ::Deployment::PlanPropertyMapping& Deployment::PlanPropertyMapping::operator= (::Deployment::PlanPropertyMapping&& x)
{
  this->name_ = std::move (x.name_);
  this->source_ = std::move (x.source_);
  this->externalName_ = std::move (x.externalName_);
  this->delegatesTo_ = std::move (x.delegatesTo_);
  return *this;
}

inline void Deployment::PlanPropertyMapping::swap (::Deployment::PlanPropertyMapping& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->externalName_, s.externalName_);
  std::swap (this->delegatesTo_, s.delegatesTo_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ImplementationDependency::ImplementationDependency ()
           : requiredType_ (std::string())
{
}
inline Deployment::ImplementationDependency::ImplementationDependency (std::string requiredType)
           : requiredType_ (std::move (requiredType))
{
}

inline void Deployment::ImplementationDependency::requiredType (const std::string& _requiredType) { this->requiredType_ = _requiredType; }
inline void Deployment::ImplementationDependency::requiredType (std::string&& _requiredType) { this->requiredType_ = std::move (_requiredType); }
inline const std::string& Deployment::ImplementationDependency::requiredType () const { return this->requiredType_; }
inline std::string& Deployment::ImplementationDependency::requiredType () { return this->requiredType_; }

inline ::Deployment::ImplementationDependency& Deployment::ImplementationDependency::operator= (const ::Deployment::ImplementationDependency& x)
{
  if (this != &x) {
    this->requiredType_ = x.requiredType_;
  }
  return *this;
}
inline ::Deployment::ImplementationDependency& Deployment::ImplementationDependency::operator= (::Deployment::ImplementationDependency&& x)
{
  this->requiredType_ = std::move (x.requiredType_);
  return *this;
}

inline void Deployment::ImplementationDependency::swap (::Deployment::ImplementationDependency& s)
{
  std::swap (this->requiredType_, s.requiredType_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ResourceDeploymentDescription::ResourceDeploymentDescription ()
           : requirementName_ (std::string())
           , resourceName_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::ResourceDeploymentDescription::ResourceDeploymentDescription (std::string requirementName,
                                                                                 std::string resourceName,
                                                                                 ::Deployment::Properties property)
           : requirementName_ (std::move (requirementName))
           , resourceName_ (std::move (resourceName))
           , property_ (std::move (property))
{
}

inline void Deployment::ResourceDeploymentDescription::requirementName (const std::string& _requirementName) { this->requirementName_ = _requirementName; }
inline void Deployment::ResourceDeploymentDescription::requirementName (std::string&& _requirementName) { this->requirementName_ = std::move (_requirementName); }
inline const std::string& Deployment::ResourceDeploymentDescription::requirementName () const { return this->requirementName_; }
inline std::string& Deployment::ResourceDeploymentDescription::requirementName () { return this->requirementName_; }

inline void Deployment::ResourceDeploymentDescription::resourceName (const std::string& _resourceName) { this->resourceName_ = _resourceName; }
inline void Deployment::ResourceDeploymentDescription::resourceName (std::string&& _resourceName) { this->resourceName_ = std::move (_resourceName); }
inline const std::string& Deployment::ResourceDeploymentDescription::resourceName () const { return this->resourceName_; }
inline std::string& Deployment::ResourceDeploymentDescription::resourceName () { return this->resourceName_; }

inline void Deployment::ResourceDeploymentDescription::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::ResourceDeploymentDescription::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::ResourceDeploymentDescription::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::ResourceDeploymentDescription::property () { return this->property_; }

inline ::Deployment::ResourceDeploymentDescription& Deployment::ResourceDeploymentDescription::operator= (const ::Deployment::ResourceDeploymentDescription& x)
{
  if (this != &x) {
    this->requirementName_ = x.requirementName_;
    this->resourceName_ = x.resourceName_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::ResourceDeploymentDescription& Deployment::ResourceDeploymentDescription::operator= (::Deployment::ResourceDeploymentDescription&& x)
{
  this->requirementName_ = std::move (x.requirementName_);
  this->resourceName_ = std::move (x.resourceName_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::ResourceDeploymentDescription::swap (::Deployment::ResourceDeploymentDescription& s)
{
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ArtifactDeploymentDescription::ArtifactDeploymentDescription ()
           : name_ (std::string())
           , location_ (std::vector < std::string> ())
           , node_ (std::string())
           , source_ (std::vector < std::string> ())
           , execParameter_ (std::vector < ::Deployment::Property> ())
           , deployRequirement_ (std::vector < ::Deployment::Requirement> ())
           , deployedResource_ (std::vector < ::Deployment::ResourceDeploymentDescription> ())
{
}
inline Deployment::ArtifactDeploymentDescription::ArtifactDeploymentDescription (std::string name,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq location,
                                                                                 std::string node,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                                                 ::Deployment::Properties execParameter,
                                                                                 ::Deployment::Requirements deployRequirement,
                                                                                 ::Deployment::ResourceDeploymentDescriptions deployedResource)
           : name_ (std::move (name))
           , location_ (std::move (location))
           , node_ (std::move (node))
           , source_ (std::move (source))
           , execParameter_ (std::move (execParameter))
           , deployRequirement_ (std::move (deployRequirement))
           , deployedResource_ (std::move (deployedResource))
{
}

inline void Deployment::ArtifactDeploymentDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ArtifactDeploymentDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ArtifactDeploymentDescription::name () const { return this->name_; }
inline std::string& Deployment::ArtifactDeploymentDescription::name () { return this->name_; }

inline void Deployment::ArtifactDeploymentDescription::location (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _location) { this->location_ = _location; }
inline void Deployment::ArtifactDeploymentDescription::location (::TAOX11_NAMESPACE::CORBA::StringSeq&& _location) { this->location_ = std::move (_location); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::location () const { return this->location_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::location () { return this->location_; }

inline void Deployment::ArtifactDeploymentDescription::node (const std::string& _node) { this->node_ = _node; }
inline void Deployment::ArtifactDeploymentDescription::node (std::string&& _node) { this->node_ = std::move (_node); }
inline const std::string& Deployment::ArtifactDeploymentDescription::node () const { return this->node_; }
inline std::string& Deployment::ArtifactDeploymentDescription::node () { return this->node_; }

inline void Deployment::ArtifactDeploymentDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::ArtifactDeploymentDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::source () { return this->source_; }

inline void Deployment::ArtifactDeploymentDescription::execParameter (const ::Deployment::Properties& _execParameter) { this->execParameter_ = _execParameter; }
inline void Deployment::ArtifactDeploymentDescription::execParameter (::Deployment::Properties&& _execParameter) { this->execParameter_ = std::move (_execParameter); }
inline const ::Deployment::Properties& Deployment::ArtifactDeploymentDescription::execParameter () const { return this->execParameter_; }
inline ::Deployment::Properties& Deployment::ArtifactDeploymentDescription::execParameter () { return this->execParameter_; }

inline void Deployment::ArtifactDeploymentDescription::deployRequirement (const ::Deployment::Requirements& _deployRequirement) { this->deployRequirement_ = _deployRequirement; }
inline void Deployment::ArtifactDeploymentDescription::deployRequirement (::Deployment::Requirements&& _deployRequirement) { this->deployRequirement_ = std::move (_deployRequirement); }
inline const ::Deployment::Requirements& Deployment::ArtifactDeploymentDescription::deployRequirement () const { return this->deployRequirement_; }
inline ::Deployment::Requirements& Deployment::ArtifactDeploymentDescription::deployRequirement () { return this->deployRequirement_; }

inline void Deployment::ArtifactDeploymentDescription::deployedResource (const ::Deployment::ResourceDeploymentDescriptions& _deployedResource) { this->deployedResource_ = _deployedResource; }
inline void Deployment::ArtifactDeploymentDescription::deployedResource (::Deployment::ResourceDeploymentDescriptions&& _deployedResource) { this->deployedResource_ = std::move (_deployedResource); }
inline const ::Deployment::ResourceDeploymentDescriptions& Deployment::ArtifactDeploymentDescription::deployedResource () const { return this->deployedResource_; }
inline ::Deployment::ResourceDeploymentDescriptions& Deployment::ArtifactDeploymentDescription::deployedResource () { return this->deployedResource_; }

inline ::Deployment::ArtifactDeploymentDescription& Deployment::ArtifactDeploymentDescription::operator= (const ::Deployment::ArtifactDeploymentDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->location_ = x.location_;
    this->node_ = x.node_;
    this->source_ = x.source_;
    this->execParameter_ = x.execParameter_;
    this->deployRequirement_ = x.deployRequirement_;
    this->deployedResource_ = x.deployedResource_;
  }
  return *this;
}
inline ::Deployment::ArtifactDeploymentDescription& Deployment::ArtifactDeploymentDescription::operator= (::Deployment::ArtifactDeploymentDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->location_ = std::move (x.location_);
  this->node_ = std::move (x.node_);
  this->source_ = std::move (x.source_);
  this->execParameter_ = std::move (x.execParameter_);
  this->deployRequirement_ = std::move (x.deployRequirement_);
  this->deployedResource_ = std::move (x.deployedResource_);
  return *this;
}

inline void Deployment::ArtifactDeploymentDescription::swap (::Deployment::ArtifactDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->location_, s.location_);
  std::swap (this->node_, s.node_);
  std::swap (this->source_, s.source_);
  std::swap (this->execParameter_, s.execParameter_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
  std::swap (this->deployedResource_, s.deployedResource_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanLocality::PlanLocality ()
           : constraint_ (::Deployment::PlanLocalityKind::PlanSameProcess)
           , constrainedInstanceRef_ (std::vector < uint32_t> ())
{
}
inline Deployment::PlanLocality::PlanLocality (::Deployment::PlanLocalityKind constraint,
                                               ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef)
           : constraint_ (std::move (constraint))
           , constrainedInstanceRef_ (std::move (constrainedInstanceRef))
{
}

inline void Deployment::PlanLocality::constraint (::Deployment::PlanLocalityKind _constraint) { this->constraint_ = _constraint; }
inline ::Deployment::PlanLocalityKind Deployment::PlanLocality::constraint () const { return this->constraint_; }
inline ::Deployment::PlanLocalityKind& Deployment::PlanLocality::constraint () { return this->constraint_; }

inline void Deployment::PlanLocality::constrainedInstanceRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _constrainedInstanceRef) { this->constrainedInstanceRef_ = _constrainedInstanceRef; }
inline void Deployment::PlanLocality::constrainedInstanceRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _constrainedInstanceRef) { this->constrainedInstanceRef_ = std::move (_constrainedInstanceRef); }
inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::PlanLocality::constrainedInstanceRef () const { return this->constrainedInstanceRef_; }
inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::PlanLocality::constrainedInstanceRef () { return this->constrainedInstanceRef_; }

inline ::Deployment::PlanLocality& Deployment::PlanLocality::operator= (const ::Deployment::PlanLocality& x)
{
  if (this != &x) {
    this->constraint_ = x.constraint_;
    this->constrainedInstanceRef_ = x.constrainedInstanceRef_;
  }
  return *this;
}
inline ::Deployment::PlanLocality& Deployment::PlanLocality::operator= (::Deployment::PlanLocality&& x)
{
  this->constraint_ = std::move (x.constraint_);
  this->constrainedInstanceRef_ = std::move (x.constrainedInstanceRef_);
  return *this;
}

inline void Deployment::PlanLocality::swap (::Deployment::PlanLocality& s)
{
  std::swap (this->constraint_, s.constraint_);
  std::swap (this->constrainedInstanceRef_, s.constrainedInstanceRef_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::DeploymentPlan::DeploymentPlan ()
           : label_ (std::string())
           , UUID_ (std::string())
           , realizes_ (::Deployment::ComponentInterfaceDescription ())
           , implementation_ (std::vector < ::Deployment::MonolithicDeploymentDescription> ())
           , instance_ (std::vector < ::Deployment::InstanceDeploymentDescription> ())
           , connection_ (std::vector < ::Deployment::PlanConnectionDescription> ())
           , externalProperty_ (std::vector < ::Deployment::PlanPropertyMapping> ())
           , dependsOn_ (std::vector < ::Deployment::ImplementationDependency> ())
           , artifact_ (std::vector < ::Deployment::ArtifactDeploymentDescription> ())
           , infoProperty_ (std::vector < ::Deployment::Property> ())
           , localityConstraint_ (std::vector < ::Deployment::PlanLocality> ())
{
}
inline Deployment::DeploymentPlan::DeploymentPlan (std::string label,
                                                   std::string UUID,
                                                   ::Deployment::ComponentInterfaceDescription realizes,
                                                   ::Deployment::MonolithicDeploymentDescriptions implementation,
                                                   ::Deployment::InstanceDeploymentDescriptions instance,
                                                   ::Deployment::PlanConnectionDescriptions connection,
                                                   ::Deployment::PlanPropertyMappings externalProperty,
                                                   ::Deployment::ImplementationDependencies dependsOn,
                                                   ::Deployment::ArtifactDeploymentDescriptions artifact,
                                                   ::Deployment::Properties infoProperty,
                                                   ::Deployment::PlanLocalities localityConstraint)
           : label_ (std::move (label))
           , UUID_ (std::move (UUID))
           , realizes_ (std::move (realizes))
           , implementation_ (std::move (implementation))
           , instance_ (std::move (instance))
           , connection_ (std::move (connection))
           , externalProperty_ (std::move (externalProperty))
           , dependsOn_ (std::move (dependsOn))
           , artifact_ (std::move (artifact))
           , infoProperty_ (std::move (infoProperty))
           , localityConstraint_ (std::move (localityConstraint))
{
}

inline void Deployment::DeploymentPlan::label (const std::string& _label) { this->label_ = _label; }
inline void Deployment::DeploymentPlan::label (std::string&& _label) { this->label_ = std::move (_label); }
inline const std::string& Deployment::DeploymentPlan::label () const { return this->label_; }
inline std::string& Deployment::DeploymentPlan::label () { return this->label_; }

inline void Deployment::DeploymentPlan::UUID (const std::string& _UUID) { this->UUID_ = _UUID; }
inline void Deployment::DeploymentPlan::UUID (std::string&& _UUID) { this->UUID_ = std::move (_UUID); }
inline const std::string& Deployment::DeploymentPlan::UUID () const { return this->UUID_; }
inline std::string& Deployment::DeploymentPlan::UUID () { return this->UUID_; }

inline void Deployment::DeploymentPlan::realizes (const ::Deployment::ComponentInterfaceDescription& _realizes) { this->realizes_ = _realizes; }
inline void Deployment::DeploymentPlan::realizes (::Deployment::ComponentInterfaceDescription&& _realizes) { this->realizes_ = std::move (_realizes); }
inline const ::Deployment::ComponentInterfaceDescription& Deployment::DeploymentPlan::realizes () const { return this->realizes_; }
inline ::Deployment::ComponentInterfaceDescription& Deployment::DeploymentPlan::realizes () { return this->realizes_; }

inline void Deployment::DeploymentPlan::implementation (const ::Deployment::MonolithicDeploymentDescriptions& _implementation) { this->implementation_ = _implementation; }
inline void Deployment::DeploymentPlan::implementation (::Deployment::MonolithicDeploymentDescriptions&& _implementation) { this->implementation_ = std::move (_implementation); }
inline const ::Deployment::MonolithicDeploymentDescriptions& Deployment::DeploymentPlan::implementation () const { return this->implementation_; }
inline ::Deployment::MonolithicDeploymentDescriptions& Deployment::DeploymentPlan::implementation () { return this->implementation_; }

inline void Deployment::DeploymentPlan::instance (const ::Deployment::InstanceDeploymentDescriptions& _instance) { this->instance_ = _instance; }
inline void Deployment::DeploymentPlan::instance (::Deployment::InstanceDeploymentDescriptions&& _instance) { this->instance_ = std::move (_instance); }
inline const ::Deployment::InstanceDeploymentDescriptions& Deployment::DeploymentPlan::instance () const { return this->instance_; }
inline ::Deployment::InstanceDeploymentDescriptions& Deployment::DeploymentPlan::instance () { return this->instance_; }

inline void Deployment::DeploymentPlan::connection (const ::Deployment::PlanConnectionDescriptions& _connection) { this->connection_ = _connection; }
inline void Deployment::DeploymentPlan::connection (::Deployment::PlanConnectionDescriptions&& _connection) { this->connection_ = std::move (_connection); }
inline const ::Deployment::PlanConnectionDescriptions& Deployment::DeploymentPlan::connection () const { return this->connection_; }
inline ::Deployment::PlanConnectionDescriptions& Deployment::DeploymentPlan::connection () { return this->connection_; }

inline void Deployment::DeploymentPlan::externalProperty (const ::Deployment::PlanPropertyMappings& _externalProperty) { this->externalProperty_ = _externalProperty; }
inline void Deployment::DeploymentPlan::externalProperty (::Deployment::PlanPropertyMappings&& _externalProperty) { this->externalProperty_ = std::move (_externalProperty); }
inline const ::Deployment::PlanPropertyMappings& Deployment::DeploymentPlan::externalProperty () const { return this->externalProperty_; }
inline ::Deployment::PlanPropertyMappings& Deployment::DeploymentPlan::externalProperty () { return this->externalProperty_; }

inline void Deployment::DeploymentPlan::dependsOn (const ::Deployment::ImplementationDependencies& _dependsOn) { this->dependsOn_ = _dependsOn; }
inline void Deployment::DeploymentPlan::dependsOn (::Deployment::ImplementationDependencies&& _dependsOn) { this->dependsOn_ = std::move (_dependsOn); }
inline const ::Deployment::ImplementationDependencies& Deployment::DeploymentPlan::dependsOn () const { return this->dependsOn_; }
inline ::Deployment::ImplementationDependencies& Deployment::DeploymentPlan::dependsOn () { return this->dependsOn_; }

inline void Deployment::DeploymentPlan::artifact (const ::Deployment::ArtifactDeploymentDescriptions& _artifact) { this->artifact_ = _artifact; }
inline void Deployment::DeploymentPlan::artifact (::Deployment::ArtifactDeploymentDescriptions&& _artifact) { this->artifact_ = std::move (_artifact); }
inline const ::Deployment::ArtifactDeploymentDescriptions& Deployment::DeploymentPlan::artifact () const { return this->artifact_; }
inline ::Deployment::ArtifactDeploymentDescriptions& Deployment::DeploymentPlan::artifact () { return this->artifact_; }

inline void Deployment::DeploymentPlan::infoProperty (const ::Deployment::Properties& _infoProperty) { this->infoProperty_ = _infoProperty; }
inline void Deployment::DeploymentPlan::infoProperty (::Deployment::Properties&& _infoProperty) { this->infoProperty_ = std::move (_infoProperty); }
inline const ::Deployment::Properties& Deployment::DeploymentPlan::infoProperty () const { return this->infoProperty_; }
inline ::Deployment::Properties& Deployment::DeploymentPlan::infoProperty () { return this->infoProperty_; }

inline void Deployment::DeploymentPlan::localityConstraint (const ::Deployment::PlanLocalities& _localityConstraint) { this->localityConstraint_ = _localityConstraint; }
inline void Deployment::DeploymentPlan::localityConstraint (::Deployment::PlanLocalities&& _localityConstraint) { this->localityConstraint_ = std::move (_localityConstraint); }
inline const ::Deployment::PlanLocalities& Deployment::DeploymentPlan::localityConstraint () const { return this->localityConstraint_; }
inline ::Deployment::PlanLocalities& Deployment::DeploymentPlan::localityConstraint () { return this->localityConstraint_; }

inline ::Deployment::DeploymentPlan& Deployment::DeploymentPlan::operator= (const ::Deployment::DeploymentPlan& x)
{
  if (this != &x) {
    this->label_ = x.label_;
    this->UUID_ = x.UUID_;
    this->realizes_ = x.realizes_;
    this->implementation_ = x.implementation_;
    this->instance_ = x.instance_;
    this->connection_ = x.connection_;
    this->externalProperty_ = x.externalProperty_;
    this->dependsOn_ = x.dependsOn_;
    this->artifact_ = x.artifact_;
    this->infoProperty_ = x.infoProperty_;
    this->localityConstraint_ = x.localityConstraint_;
  }
  return *this;
}
inline ::Deployment::DeploymentPlan& Deployment::DeploymentPlan::operator= (::Deployment::DeploymentPlan&& x)
{
  this->label_ = std::move (x.label_);
  this->UUID_ = std::move (x.UUID_);
  this->realizes_ = std::move (x.realizes_);
  this->implementation_ = std::move (x.implementation_);
  this->instance_ = std::move (x.instance_);
  this->connection_ = std::move (x.connection_);
  this->externalProperty_ = std::move (x.externalProperty_);
  this->dependsOn_ = std::move (x.dependsOn_);
  this->artifact_ = std::move (x.artifact_);
  this->infoProperty_ = std::move (x.infoProperty_);
  this->localityConstraint_ = std::move (x.localityConstraint_);
  return *this;
}

inline void Deployment::DeploymentPlan::swap (::Deployment::DeploymentPlan& s)
{
  std::swap (this->label_, s.label_);
  std::swap (this->UUID_, s.UUID_);
  std::swap (this->realizes_, s.realizes_);
  std::swap (this->implementation_, s.implementation_);
  std::swap (this->instance_, s.instance_);
  std::swap (this->connection_, s.connection_);
  std::swap (this->externalProperty_, s.externalProperty_);
  std::swap (this->dependsOn_, s.dependsOn_);
  std::swap (this->artifact_, s.artifact_);
  std::swap (this->infoProperty_, s.infoProperty_);
  std::swap (this->localityConstraint_, s.localityConstraint_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentPackageReference::ComponentPackageReference ()
           : requiredUUID_ (std::string())
           , requiredName_ (std::string())
           , requiredType_ (::Deployment::ComponentInterfaceDescription ())
{
}
inline Deployment::ComponentPackageReference::ComponentPackageReference (std::string requiredUUID,
                                                                         std::string requiredName,
                                                                         ::Deployment::ComponentInterfaceDescription requiredType)
           : requiredUUID_ (std::move (requiredUUID))
           , requiredName_ (std::move (requiredName))
           , requiredType_ (std::move (requiredType))
{
}

inline void Deployment::ComponentPackageReference::requiredUUID (const std::string& _requiredUUID) { this->requiredUUID_ = _requiredUUID; }
inline void Deployment::ComponentPackageReference::requiredUUID (std::string&& _requiredUUID) { this->requiredUUID_ = std::move (_requiredUUID); }
inline const std::string& Deployment::ComponentPackageReference::requiredUUID () const { return this->requiredUUID_; }
inline std::string& Deployment::ComponentPackageReference::requiredUUID () { return this->requiredUUID_; }

inline void Deployment::ComponentPackageReference::requiredName (const std::string& _requiredName) { this->requiredName_ = _requiredName; }
inline void Deployment::ComponentPackageReference::requiredName (std::string&& _requiredName) { this->requiredName_ = std::move (_requiredName); }
inline const std::string& Deployment::ComponentPackageReference::requiredName () const { return this->requiredName_; }
inline std::string& Deployment::ComponentPackageReference::requiredName () { return this->requiredName_; }

inline void Deployment::ComponentPackageReference::requiredType (const ::Deployment::ComponentInterfaceDescription& _requiredType) { this->requiredType_ = _requiredType; }
inline void Deployment::ComponentPackageReference::requiredType (::Deployment::ComponentInterfaceDescription&& _requiredType) { this->requiredType_ = std::move (_requiredType); }
inline const ::Deployment::ComponentInterfaceDescription& Deployment::ComponentPackageReference::requiredType () const { return this->requiredType_; }
inline ::Deployment::ComponentInterfaceDescription& Deployment::ComponentPackageReference::requiredType () { return this->requiredType_; }

inline ::Deployment::ComponentPackageReference& Deployment::ComponentPackageReference::operator= (const ::Deployment::ComponentPackageReference& x)
{
  if (this != &x) {
    this->requiredUUID_ = x.requiredUUID_;
    this->requiredName_ = x.requiredName_;
    this->requiredType_ = x.requiredType_;
  }
  return *this;
}
inline ::Deployment::ComponentPackageReference& Deployment::ComponentPackageReference::operator= (::Deployment::ComponentPackageReference&& x)
{
  this->requiredUUID_ = std::move (x.requiredUUID_);
  this->requiredName_ = std::move (x.requiredName_);
  this->requiredType_ = std::move (x.requiredType_);
  return *this;
}

inline void Deployment::ComponentPackageReference::swap (::Deployment::ComponentPackageReference& s)
{
  std::swap (this->requiredUUID_, s.requiredUUID_);
  std::swap (this->requiredName_, s.requiredName_);
  std::swap (this->requiredType_, s.requiredType_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ImplementationRequirement::ImplementationRequirement ()
           : resourceUsage_ (std::vector < ::Deployment::ResourceUsageKind> ())
           , resourcePort_ (std::string())
           , componentPort_ (std::string())
           , name_ (std::string())
           , resourceType_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::ImplementationRequirement::ImplementationRequirement (::Deployment::ResourceUsageKinds resourceUsage,
                                                                         std::string resourcePort,
                                                                         std::string componentPort,
                                                                         std::string name,
                                                                         std::string resourceType,
                                                                         ::Deployment::Properties property)
           : resourceUsage_ (std::move (resourceUsage))
           , resourcePort_ (std::move (resourcePort))
           , componentPort_ (std::move (componentPort))
           , name_ (std::move (name))
           , resourceType_ (std::move (resourceType))
           , property_ (std::move (property))
{
}

inline void Deployment::ImplementationRequirement::resourceUsage (const ::Deployment::ResourceUsageKinds& _resourceUsage) { this->resourceUsage_ = _resourceUsage; }
inline void Deployment::ImplementationRequirement::resourceUsage (::Deployment::ResourceUsageKinds&& _resourceUsage) { this->resourceUsage_ = std::move (_resourceUsage); }
inline const ::Deployment::ResourceUsageKinds& Deployment::ImplementationRequirement::resourceUsage () const { return this->resourceUsage_; }
inline ::Deployment::ResourceUsageKinds& Deployment::ImplementationRequirement::resourceUsage () { return this->resourceUsage_; }

inline void Deployment::ImplementationRequirement::resourcePort (const std::string& _resourcePort) { this->resourcePort_ = _resourcePort; }
inline void Deployment::ImplementationRequirement::resourcePort (std::string&& _resourcePort) { this->resourcePort_ = std::move (_resourcePort); }
inline const std::string& Deployment::ImplementationRequirement::resourcePort () const { return this->resourcePort_; }
inline std::string& Deployment::ImplementationRequirement::resourcePort () { return this->resourcePort_; }

inline void Deployment::ImplementationRequirement::componentPort (const std::string& _componentPort) { this->componentPort_ = _componentPort; }
inline void Deployment::ImplementationRequirement::componentPort (std::string&& _componentPort) { this->componentPort_ = std::move (_componentPort); }
inline const std::string& Deployment::ImplementationRequirement::componentPort () const { return this->componentPort_; }
inline std::string& Deployment::ImplementationRequirement::componentPort () { return this->componentPort_; }

inline void Deployment::ImplementationRequirement::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ImplementationRequirement::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ImplementationRequirement::name () const { return this->name_; }
inline std::string& Deployment::ImplementationRequirement::name () { return this->name_; }

inline void Deployment::ImplementationRequirement::resourceType (const std::string& _resourceType) { this->resourceType_ = _resourceType; }
inline void Deployment::ImplementationRequirement::resourceType (std::string&& _resourceType) { this->resourceType_ = std::move (_resourceType); }
inline const std::string& Deployment::ImplementationRequirement::resourceType () const { return this->resourceType_; }
inline std::string& Deployment::ImplementationRequirement::resourceType () { return this->resourceType_; }

inline void Deployment::ImplementationRequirement::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::ImplementationRequirement::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::ImplementationRequirement::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::ImplementationRequirement::property () { return this->property_; }

inline ::Deployment::ImplementationRequirement& Deployment::ImplementationRequirement::operator= (const ::Deployment::ImplementationRequirement& x)
{
  if (this != &x) {
    this->resourceUsage_ = x.resourceUsage_;
    this->resourcePort_ = x.resourcePort_;
    this->componentPort_ = x.componentPort_;
    this->name_ = x.name_;
    this->resourceType_ = x.resourceType_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::ImplementationRequirement& Deployment::ImplementationRequirement::operator= (::Deployment::ImplementationRequirement&& x)
{
  this->resourceUsage_ = std::move (x.resourceUsage_);
  this->resourcePort_ = std::move (x.resourcePort_);
  this->componentPort_ = std::move (x.componentPort_);
  this->name_ = std::move (x.name_);
  this->resourceType_ = std::move (x.resourceType_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::ImplementationRequirement::swap (::Deployment::ImplementationRequirement& s)
{
  std::swap (this->resourceUsage_, s.resourceUsage_);
  std::swap (this->resourcePort_, s.resourcePort_);
  std::swap (this->componentPort_, s.componentPort_);
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::Capability::Capability ()
           : name_ (std::string())
           , resourceType_ (std::vector < std::string> ())
           , property_ (std::vector < ::Deployment::SatisfierProperty> ())
{
}
inline Deployment::Capability::Capability (std::string name,
                                           ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType,
                                           ::Deployment::SatisfierProperties property)
           : name_ (std::move (name))
           , resourceType_ (std::move (resourceType))
           , property_ (std::move (property))
{
}

inline void Deployment::Capability::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::Capability::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::Capability::name () const { return this->name_; }
inline std::string& Deployment::Capability::name () { return this->name_; }

inline void Deployment::Capability::resourceType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _resourceType) { this->resourceType_ = _resourceType; }
inline void Deployment::Capability::resourceType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _resourceType) { this->resourceType_ = std::move (_resourceType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::Capability::resourceType () const { return this->resourceType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::Capability::resourceType () { return this->resourceType_; }

inline void Deployment::Capability::property (const ::Deployment::SatisfierProperties& _property) { this->property_ = _property; }
inline void Deployment::Capability::property (::Deployment::SatisfierProperties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::SatisfierProperties& Deployment::Capability::property () const { return this->property_; }
inline ::Deployment::SatisfierProperties& Deployment::Capability::property () { return this->property_; }

inline ::Deployment::Capability& Deployment::Capability::operator= (const ::Deployment::Capability& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->resourceType_ = x.resourceType_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::Capability& Deployment::Capability::operator= (::Deployment::Capability&& x)
{
  this->name_ = std::move (x.name_);
  this->resourceType_ = std::move (x.resourceType_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::Capability::swap (::Deployment::Capability& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Property& m1, ::Deployment::Property& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Requirement& m1, ::Deployment::Requirement& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::SatisfierProperty& m1, ::Deployment::SatisfierProperty& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPortDescription& m1, ::Deployment::ComponentPortDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPropertyDescription& m1, ::Deployment::ComponentPropertyDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentInterfaceDescription& m1, ::Deployment::ComponentInterfaceDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::MonolithicDeploymentDescription& m1, ::Deployment::MonolithicDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::InstanceResourceDeploymentDescription& m1, ::Deployment::InstanceResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::InstanceDeploymentDescription& m1, ::Deployment::InstanceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentExternalPortEndpoint& m1, ::Deployment::ComponentExternalPortEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanSubcomponentPortEndpoint& m1, ::Deployment::PlanSubcomponentPortEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ExternalReferenceEndpoint& m1, ::Deployment::ExternalReferenceEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ConnectionResourceDeploymentDescription& m1, ::Deployment::ConnectionResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanConnectionDescription& m1, ::Deployment::PlanConnectionDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanSubcomponentPropertyReference& m1, ::Deployment::PlanSubcomponentPropertyReference& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanPropertyMapping& m1, ::Deployment::PlanPropertyMapping& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ImplementationDependency& m1, ::Deployment::ImplementationDependency& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ResourceDeploymentDescription& m1, ::Deployment::ResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ArtifactDeploymentDescription& m1, ::Deployment::ArtifactDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanLocality& m1, ::Deployment::PlanLocality& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::DeploymentPlan& m1, ::Deployment::DeploymentPlan& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPackageReference& m1, ::Deployment::ComponentPackageReference& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ImplementationRequirement& m1, ::Deployment::ImplementationRequirement& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Capability& m1, ::Deployment::Capability& m2)
  {
    m1.swap (m2);
  }
}; // std

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::Property&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::Property>
// MD5            : 9FA54C1D0A4E5ABC4A2486AD7C463745
#if !defined (_ALIAS_OSTREAM_9FA54C1D0A4E5ABC4A2486AD7C463745_DECL_)
#define _ALIAS_OSTREAM_9FA54C1D0A4E5ABC4A2486AD7C463745_DECL_

std::ostream&
taox11_print_Deployment_Properties (
    std::ostream& strm ,
    const ::Deployment::Properties& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::Properties& _v)
{
  strm << "std::vector < ::Deployment::Property>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_9FA54C1D0A4E5ABC4A2486AD7C463745_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::Requirement&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::Requirement>
// MD5            : B5D61CF43DC976264FCA09DAEF6B439D
#if !defined (_ALIAS_OSTREAM_B5D61CF43DC976264FCA09DAEF6B439D_DECL_)
#define _ALIAS_OSTREAM_B5D61CF43DC976264FCA09DAEF6B439D_DECL_

std::ostream&
taox11_print_Deployment_Requirements (
    std::ostream& strm ,
    const ::Deployment::Requirements& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::Requirements& _v)
{
  strm << "std::vector < ::Deployment::Requirement>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_B5D61CF43DC976264FCA09DAEF6B439D_DECL_

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::SatisfierPropertyKind _enumerator)
{
  switch (_enumerator) {
    case Deployment::SatisfierPropertyKind::Quantity: return strm << "Deployment::SatisfierPropertyKind::Quantity"; break;
    case Deployment::SatisfierPropertyKind::Capacity: return strm << "Deployment::SatisfierPropertyKind::Capacity"; break;
    case Deployment::SatisfierPropertyKind::Minimum: return strm << "Deployment::SatisfierPropertyKind::Minimum"; break;
    case Deployment::SatisfierPropertyKind::Maximum: return strm << "Deployment::SatisfierPropertyKind::Maximum"; break;
    case Deployment::SatisfierPropertyKind::Attribute: return strm << "Deployment::SatisfierPropertyKind::Attribute"; break;
    case Deployment::SatisfierPropertyKind::Selection: return strm << "Deployment::SatisfierPropertyKind::Selection"; break;
    default: return strm;
  }
}

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::SatisfierProperty&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::SatisfierProperty>
// MD5            : AAB77A9CDD8FCC93D26F3C8F9DA5CB57
#if !defined (_ALIAS_OSTREAM_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_DECL_)
#define _ALIAS_OSTREAM_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_DECL_

std::ostream&
taox11_print_Deployment_SatisfierProperties (
    std::ostream& strm ,
    const ::Deployment::SatisfierProperties& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::SatisfierProperties& _v)
{
  strm << "std::vector < ::Deployment::SatisfierProperty>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_DECL_

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::CCMComponentPortKind _enumerator)
{
  switch (_enumerator) {
    case Deployment::CCMComponentPortKind::Facet: return strm << "Deployment::CCMComponentPortKind::Facet"; break;
    case Deployment::CCMComponentPortKind::SimplexReceptacle: return strm << "Deployment::CCMComponentPortKind::SimplexReceptacle"; break;
    case Deployment::CCMComponentPortKind::MultiplexReceptacle: return strm << "Deployment::CCMComponentPortKind::MultiplexReceptacle"; break;
    case Deployment::CCMComponentPortKind::EventEmitter: return strm << "Deployment::CCMComponentPortKind::EventEmitter"; break;
    case Deployment::CCMComponentPortKind::EventPublisher: return strm << "Deployment::CCMComponentPortKind::EventPublisher"; break;
    case Deployment::CCMComponentPortKind::EventConsumer: return strm << "Deployment::CCMComponentPortKind::EventConsumer"; break;
    case Deployment::CCMComponentPortKind::ExtendedPort: return strm << "Deployment::CCMComponentPortKind::ExtendedPort"; break;
    case Deployment::CCMComponentPortKind::MirrorPort: return strm << "Deployment::CCMComponentPortKind::MirrorPort"; break;
    default: return strm;
  }
}

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ComponentPortDescription&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ComponentPortDescription>
// MD5            : C5E370E71060EF02CAD31E10FF9B9A83
#if !defined (_ALIAS_OSTREAM_C5E370E71060EF02CAD31E10FF9B9A83_DECL_)
#define _ALIAS_OSTREAM_C5E370E71060EF02CAD31E10FF9B9A83_DECL_

std::ostream&
taox11_print_Deployment_ComponentPortDescriptions (
    std::ostream& strm ,
    const ::Deployment::ComponentPortDescriptions& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPortDescriptions& _v)
{
  strm << "std::vector < ::Deployment::ComponentPortDescription>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_C5E370E71060EF02CAD31E10FF9B9A83_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ComponentPropertyDescription&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ComponentPropertyDescription>
// MD5            : C38B325CAEA1E1A5249DC3C8B0654824
#if !defined (_ALIAS_OSTREAM_C38B325CAEA1E1A5249DC3C8B0654824_DECL_)
#define _ALIAS_OSTREAM_C38B325CAEA1E1A5249DC3C8B0654824_DECL_

std::ostream&
taox11_print_Deployment_ComponentPropertyDescriptions (
    std::ostream& strm ,
    const ::Deployment::ComponentPropertyDescriptions& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPropertyDescriptions& _v)
{
  strm << "std::vector < ::Deployment::ComponentPropertyDescription>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_C38B325CAEA1E1A5249DC3C8B0654824_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ComponentInterfaceDescription&);

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::MonolithicDeploymentDescription&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::MonolithicDeploymentDescription>
// MD5            : 80C54C15F1FCF891188F93122A3F1653
#if !defined (_ALIAS_OSTREAM_80C54C15F1FCF891188F93122A3F1653_DECL_)
#define _ALIAS_OSTREAM_80C54C15F1FCF891188F93122A3F1653_DECL_

std::ostream&
taox11_print_Deployment_MonolithicDeploymentDescriptions (
    std::ostream& strm ,
    const ::Deployment::MonolithicDeploymentDescriptions& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::MonolithicDeploymentDescriptions& _v)
{
  strm << "std::vector < ::Deployment::MonolithicDeploymentDescription>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_80C54C15F1FCF891188F93122A3F1653_DECL_

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::ResourceUsageKind _enumerator)
{
  switch (_enumerator) {
    case Deployment::ResourceUsageKind::None: return strm << "Deployment::ResourceUsageKind::None"; break;
    case Deployment::ResourceUsageKind::InstanceUsesResource: return strm << "Deployment::ResourceUsageKind::InstanceUsesResource"; break;
    case Deployment::ResourceUsageKind::ResourceUsesInstance: return strm << "Deployment::ResourceUsageKind::ResourceUsesInstance"; break;
    case Deployment::ResourceUsageKind::PortUsesResource: return strm << "Deployment::ResourceUsageKind::PortUsesResource"; break;
    case Deployment::ResourceUsageKind::ResourceUsesPort: return strm << "Deployment::ResourceUsageKind::ResourceUsesPort"; break;
    default: return strm;
  }
}

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::InstanceResourceDeploymentDescription&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::InstanceResourceDeploymentDescription>
// MD5            : EECAFA244583FB042136539EF2209665
#if !defined (_ALIAS_OSTREAM_EECAFA244583FB042136539EF2209665_DECL_)
#define _ALIAS_OSTREAM_EECAFA244583FB042136539EF2209665_DECL_

std::ostream&
taox11_print_Deployment_InstanceResourceDeploymentDescriptions (
    std::ostream& strm ,
    const ::Deployment::InstanceResourceDeploymentDescriptions& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceResourceDeploymentDescriptions& _v)
{
  strm << "std::vector < ::Deployment::InstanceResourceDeploymentDescription>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_EECAFA244583FB042136539EF2209665_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::InstanceDeploymentDescription&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::InstanceDeploymentDescription>
// MD5            : 5DAB54D520633DBBAAC64AB44B5264EF
#if !defined (_ALIAS_OSTREAM_5DAB54D520633DBBAAC64AB44B5264EF_DECL_)
#define _ALIAS_OSTREAM_5DAB54D520633DBBAAC64AB44B5264EF_DECL_

std::ostream&
taox11_print_Deployment_InstanceDeploymentDescriptions (
    std::ostream& strm ,
    const ::Deployment::InstanceDeploymentDescriptions& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceDeploymentDescriptions& _v)
{
  strm << "std::vector < ::Deployment::InstanceDeploymentDescription>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_5DAB54D520633DBBAAC64AB44B5264EF_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ComponentExternalPortEndpoint&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ComponentExternalPortEndpoint>
// MD5            : D55B5CF95C9426C6D2C98C3A5D478A08
#if !defined (_ALIAS_OSTREAM_D55B5CF95C9426C6D2C98C3A5D478A08_DECL_)
#define _ALIAS_OSTREAM_D55B5CF95C9426C6D2C98C3A5D478A08_DECL_

std::ostream&
taox11_print_Deployment_ComponentExternalPortEndpoints (
    std::ostream& strm ,
    const ::Deployment::ComponentExternalPortEndpoints& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentExternalPortEndpoints& _v)
{
  strm << "std::vector < ::Deployment::ComponentExternalPortEndpoint>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_D55B5CF95C9426C6D2C98C3A5D478A08_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::PlanSubcomponentPortEndpoint&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanSubcomponentPortEndpoint>
// MD5            : B166E528DC38CC7B9823B4A707AF73F7
#if !defined (_ALIAS_OSTREAM_B166E528DC38CC7B9823B4A707AF73F7_DECL_)
#define _ALIAS_OSTREAM_B166E528DC38CC7B9823B4A707AF73F7_DECL_

std::ostream&
taox11_print_Deployment_PlanSubcomponentPortEndpoints (
    std::ostream& strm ,
    const ::Deployment::PlanSubcomponentPortEndpoints& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPortEndpoints& _v)
{
  strm << "std::vector < ::Deployment::PlanSubcomponentPortEndpoint>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_B166E528DC38CC7B9823B4A707AF73F7_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ExternalReferenceEndpoint&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ExternalReferenceEndpoint>
// MD5            : 05A01CE11A8BFF9D44BAB053FE399734
#if !defined (_ALIAS_OSTREAM_05A01CE11A8BFF9D44BAB053FE399734_DECL_)
#define _ALIAS_OSTREAM_05A01CE11A8BFF9D44BAB053FE399734_DECL_

std::ostream&
taox11_print_Deployment_ExternalReferenceEndpoints (
    std::ostream& strm ,
    const ::Deployment::ExternalReferenceEndpoints& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ExternalReferenceEndpoints& _v)
{
  strm << "std::vector < ::Deployment::ExternalReferenceEndpoint>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_05A01CE11A8BFF9D44BAB053FE399734_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ConnectionResourceDeploymentDescription&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ConnectionResourceDeploymentDescription>
// MD5            : AF4F2101DCE0C79A0EDE886BDCAFC611
#if !defined (_ALIAS_OSTREAM_AF4F2101DCE0C79A0EDE886BDCAFC611_DECL_)
#define _ALIAS_OSTREAM_AF4F2101DCE0C79A0EDE886BDCAFC611_DECL_

std::ostream&
taox11_print_Deployment_ConnectionResourceDeploymentDescriptions (
    std::ostream& strm ,
    const ::Deployment::ConnectionResourceDeploymentDescriptions& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ConnectionResourceDeploymentDescriptions& _v)
{
  strm << "std::vector < ::Deployment::ConnectionResourceDeploymentDescription>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_AF4F2101DCE0C79A0EDE886BDCAFC611_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::PlanConnectionDescription&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanConnectionDescription>
// MD5            : CFA31BAC8967655A8F41210E634352C1
#if !defined (_ALIAS_OSTREAM_CFA31BAC8967655A8F41210E634352C1_DECL_)
#define _ALIAS_OSTREAM_CFA31BAC8967655A8F41210E634352C1_DECL_

std::ostream&
taox11_print_Deployment_PlanConnectionDescriptions (
    std::ostream& strm ,
    const ::Deployment::PlanConnectionDescriptions& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanConnectionDescriptions& _v)
{
  strm << "std::vector < ::Deployment::PlanConnectionDescription>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_CFA31BAC8967655A8F41210E634352C1_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::PlanSubcomponentPropertyReference&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanSubcomponentPropertyReference>
// MD5            : AEBC73EB559A636E52F4DAEA9332277F
#if !defined (_ALIAS_OSTREAM_AEBC73EB559A636E52F4DAEA9332277F_DECL_)
#define _ALIAS_OSTREAM_AEBC73EB559A636E52F4DAEA9332277F_DECL_

std::ostream&
taox11_print_Deployment_PlanSubcomponentPropertyReferences (
    std::ostream& strm ,
    const ::Deployment::PlanSubcomponentPropertyReferences& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPropertyReferences& _v)
{
  strm << "std::vector < ::Deployment::PlanSubcomponentPropertyReference>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_AEBC73EB559A636E52F4DAEA9332277F_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::PlanPropertyMapping&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanPropertyMapping>
// MD5            : F12B7FF5B966394695A4C3B62A60769E
#if !defined (_ALIAS_OSTREAM_F12B7FF5B966394695A4C3B62A60769E_DECL_)
#define _ALIAS_OSTREAM_F12B7FF5B966394695A4C3B62A60769E_DECL_

std::ostream&
taox11_print_Deployment_PlanPropertyMappings (
    std::ostream& strm ,
    const ::Deployment::PlanPropertyMappings& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanPropertyMappings& _v)
{
  strm << "std::vector < ::Deployment::PlanPropertyMapping>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_F12B7FF5B966394695A4C3B62A60769E_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ImplementationDependency&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ImplementationDependency>
// MD5            : 99A76A2AEA0FB19B92F7E3C2DE89FFF6
#if !defined (_ALIAS_OSTREAM_99A76A2AEA0FB19B92F7E3C2DE89FFF6_DECL_)
#define _ALIAS_OSTREAM_99A76A2AEA0FB19B92F7E3C2DE89FFF6_DECL_

std::ostream&
taox11_print_Deployment_ImplementationDependencies (
    std::ostream& strm ,
    const ::Deployment::ImplementationDependencies& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationDependencies& _v)
{
  strm << "std::vector < ::Deployment::ImplementationDependency>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_99A76A2AEA0FB19B92F7E3C2DE89FFF6_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ResourceDeploymentDescription&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ResourceDeploymentDescription>
// MD5            : DF993C9C6EABFC782FDDA1D9B825B8FC
#if !defined (_ALIAS_OSTREAM_DF993C9C6EABFC782FDDA1D9B825B8FC_DECL_)
#define _ALIAS_OSTREAM_DF993C9C6EABFC782FDDA1D9B825B8FC_DECL_

std::ostream&
taox11_print_Deployment_ResourceDeploymentDescriptions (
    std::ostream& strm ,
    const ::Deployment::ResourceDeploymentDescriptions& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ResourceDeploymentDescriptions& _v)
{
  strm << "std::vector < ::Deployment::ResourceDeploymentDescription>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_DF993C9C6EABFC782FDDA1D9B825B8FC_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ArtifactDeploymentDescription&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ArtifactDeploymentDescription>
// MD5            : 9366314FF053E4C8C2B7FE26CA476674
#if !defined (_ALIAS_OSTREAM_9366314FF053E4C8C2B7FE26CA476674_DECL_)
#define _ALIAS_OSTREAM_9366314FF053E4C8C2B7FE26CA476674_DECL_

std::ostream&
taox11_print_Deployment_ArtifactDeploymentDescriptions (
    std::ostream& strm ,
    const ::Deployment::ArtifactDeploymentDescriptions& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ArtifactDeploymentDescriptions& _v)
{
  strm << "std::vector < ::Deployment::ArtifactDeploymentDescription>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_9366314FF053E4C8C2B7FE26CA476674_DECL_

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::PlanLocalityKind _enumerator)
{
  switch (_enumerator) {
    case Deployment::PlanLocalityKind::PlanSameProcess: return strm << "Deployment::PlanLocalityKind::PlanSameProcess"; break;
    case Deployment::PlanLocalityKind::PlanDifferentProcess: return strm << "Deployment::PlanLocalityKind::PlanDifferentProcess"; break;
    case Deployment::PlanLocalityKind::PlanNoConstraint: return strm << "Deployment::PlanLocalityKind::PlanNoConstraint"; break;
    default: return strm;
  }
}

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::PlanLocality&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanLocality>
// MD5            : DDE38066805242B88FC17943CB38328B
#if !defined (_ALIAS_OSTREAM_DDE38066805242B88FC17943CB38328B_DECL_)
#define _ALIAS_OSTREAM_DDE38066805242B88FC17943CB38328B_DECL_

std::ostream&
taox11_print_Deployment_PlanLocalities (
    std::ostream& strm ,
    const ::Deployment::PlanLocalities& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanLocalities& _v)
{
  strm << "std::vector < ::Deployment::PlanLocality>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_DDE38066805242B88FC17943CB38328B_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::DeploymentPlan&);

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ComponentPackageReference&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ComponentPackageReference>
// MD5            : 0C9FEC96A49604B9CC5DF59C48DE88F1
#if !defined (_ALIAS_OSTREAM_0C9FEC96A49604B9CC5DF59C48DE88F1_DECL_)
#define _ALIAS_OSTREAM_0C9FEC96A49604B9CC5DF59C48DE88F1_DECL_

std::ostream&
taox11_print_Deployment_ComponentPackageReferences (
    std::ostream& strm ,
    const ::Deployment::ComponentPackageReferences& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPackageReferences& _v)
{
  strm << "std::vector < ::Deployment::ComponentPackageReference>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_0C9FEC96A49604B9CC5DF59C48DE88F1_DECL_

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ResourceUsageKind>
// MD5            : 25B5A7D7E8D2341751079BEB8A44717A
#if !defined (_ALIAS_OSTREAM_25B5A7D7E8D2341751079BEB8A44717A_DECL_)
#define _ALIAS_OSTREAM_25B5A7D7E8D2341751079BEB8A44717A_DECL_

std::ostream&
taox11_print_Deployment_ResourceUsageKinds (
    std::ostream& strm ,
    const ::Deployment::ResourceUsageKinds& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ResourceUsageKinds& _v)
{
  strm << "std::vector < ::Deployment::ResourceUsageKind>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_25B5A7D7E8D2341751079BEB8A44717A_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::ImplementationRequirement&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ImplementationRequirement>
// MD5            : 58B3838A8CD6CA5F0D66B307C6BD6467
#if !defined (_ALIAS_OSTREAM_58B3838A8CD6CA5F0D66B307C6BD6467_DECL_)
#define _ALIAS_OSTREAM_58B3838A8CD6CA5F0D66B307C6BD6467_DECL_

std::ostream&
taox11_print_Deployment_ImplementationRequirements (
    std::ostream& strm ,
    const ::Deployment::ImplementationRequirements& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationRequirements& _v)
{
  strm << "std::vector < ::Deployment::ImplementationRequirement>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_58B3838A8CD6CA5F0D66B307C6BD6467_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::Deployment::Capability&);

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::Capability>
// MD5            : 67A5FF62ED49ECC3F7373CDDDBC3DFAD
#if !defined (_ALIAS_OSTREAM_67A5FF62ED49ECC3F7373CDDDBC3DFAD_DECL_)
#define _ALIAS_OSTREAM_67A5FF62ED49ECC3F7373CDDDBC3DFAD_DECL_

std::ostream&
taox11_print_Deployment_Capabilities (
    std::ostream& strm ,
    const ::Deployment::Capabilities& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::Capabilities& _v)
{
  strm << "std::vector < ::Deployment::Capability>";
  return taox11_print_sequence (strm, _v);
}

#endif // _ALIAS_OSTREAM_67A5FF62ED49ECC3F7373CDDDBC3DFAD_DECL_

// generated from c++11/templates/cli/hdr/post.erb
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testCP.h"
#endif

#include /**/ "ace/post.h"

#endif // __RIDL_TESTC_H_EHIJFIGA_INCLUDED__

// -*- END -*-
