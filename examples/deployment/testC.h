// -*- C++ -*-
/*
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT
 *        Nijkerk, GLD
 *        The Netherlands
 *        http://www.remedy.nl \ http://www.theaceorb.nl
 */

#ifndef __RIDL_TESTC_H_INCLUDED__
#define __RIDL_TESTC_H_INCLUDED__

#include /**/ "ace/pre.h"

#include "tao/x11/stddef.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"

using namespace TAOX11_NAMESPACE;

// generated from StubHeaderWriter#enter_module
namespace Deployment
{

  // generated from c++/cli_hdr/struct_pre.erb
  class Property
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    Property (void);
    ~Property (void) = default;
    Property (const Property&) = default;
    Property (Property&&) = default;
    explicit Property (std::string name,
                       TAOX11_NAMESPACE::CORBA::Any value);
    Property& operator= (const Property& x);
    Property& operator= (Property&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void value (const TAOX11_NAMESPACE::CORBA::Any& _value);
    void value (TAOX11_NAMESPACE::CORBA::Any&& _value);
    const TAOX11_NAMESPACE::CORBA::Any& value (void) const;
    TAOX11_NAMESPACE::CORBA::Any& value (void);

    void swap (Property& s);

  private:
    std::string name_;
    TAOX11_NAMESPACE::CORBA::Any value_;
  }; // Property

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < Property> Properties;

  // generated from c++/cli_hdr/struct_pre.erb
  class Requirement
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    Requirement (void);
    ~Requirement (void) = default;
    Requirement (const Requirement&) = default;
    Requirement (Requirement&&) = default;
    explicit Requirement (std::string name,
                          std::string resourceType,
                          ::Deployment::Properties property);
    Requirement& operator= (const Requirement& x);
    Requirement& operator= (Requirement&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void resourceType (const std::string& _resourceType);
    void resourceType (std::string&& _resourceType);
    const std::string& resourceType (void) const;
    std::string& resourceType (void);

    void property (const ::Deployment::Properties& _property);
    void property (::Deployment::Properties&& _property);
    const ::Deployment::Properties& property (void) const;
    ::Deployment::Properties& property (void);

    void swap (Requirement& s);

  private:
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  }; // Requirement

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < Requirement> Requirements;

  // generated from c++/cli_hdr/enum.erb
  enum class SatisfierPropertyKind : uint32_t
  {
    Quantity,
    Capacity,
    Minimum,
    Maximum,
    Attribute,
    Selection
  }; // SatisfierPropertyKind

  // generated from c++/cli_hdr/struct_pre.erb
  class SatisfierProperty
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    SatisfierProperty (void);
    ~SatisfierProperty (void) = default;
    SatisfierProperty (const SatisfierProperty&) = default;
    SatisfierProperty (SatisfierProperty&&) = default;
    explicit SatisfierProperty (std::string name,
                                ::Deployment::SatisfierPropertyKind kind,
                                bool dynamic,
                                TAOX11_NAMESPACE::CORBA::Any value);
    SatisfierProperty& operator= (const SatisfierProperty& x);
    SatisfierProperty& operator= (SatisfierProperty&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void kind (::Deployment::SatisfierPropertyKind _kind);
    ::Deployment::SatisfierPropertyKind kind (void) const;
    ::Deployment::SatisfierPropertyKind& kind (void);

    void dynamic (bool _dynamic);
    bool dynamic (void) const;
    bool& dynamic (void);

    void value (const TAOX11_NAMESPACE::CORBA::Any& _value);
    void value (TAOX11_NAMESPACE::CORBA::Any&& _value);
    const TAOX11_NAMESPACE::CORBA::Any& value (void) const;
    TAOX11_NAMESPACE::CORBA::Any& value (void);

    void swap (SatisfierProperty& s);

  private:
    std::string name_;
    ::Deployment::SatisfierPropertyKind kind_;
    bool dynamic_;
    TAOX11_NAMESPACE::CORBA::Any value_;
  }; // SatisfierProperty

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < SatisfierProperty> SatisfierProperties;

  // generated from c++/cli_hdr/enum.erb
  enum class CCMComponentPortKind : uint32_t
  {
    Facet,
    SimplexReceptacle,
    MultiplexReceptacle,
    EventEmitter,
    EventPublisher,
    EventConsumer,
    ExtendedPort,
    MirrorPort
  }; // CCMComponentPortKind

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentPortDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ComponentPortDescription (void);
    ~ComponentPortDescription (void) = default;
    ComponentPortDescription (const ComponentPortDescription&) = default;
    ComponentPortDescription (ComponentPortDescription&&) = default;
    explicit ComponentPortDescription (std::string name,
                                       std::string specificType,
                                       ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                       bool provider,
                                       bool exclusiveProvider,
                                       bool exclusiveUser,
                                       bool optional,
                                       ::Deployment::CCMComponentPortKind kind,
                                       ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam);
    ComponentPortDescription& operator= (const ComponentPortDescription& x);
    ComponentPortDescription& operator= (ComponentPortDescription&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void specificType (const std::string& _specificType);
    void specificType (std::string&& _specificType);
    const std::string& specificType (void) const;
    std::string& specificType (void);

    void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void);

    void provider (bool _provider);
    bool provider (void) const;
    bool& provider (void);

    void exclusiveProvider (bool _exclusiveProvider);
    bool exclusiveProvider (void) const;
    bool& exclusiveProvider (void);

    void exclusiveUser (bool _exclusiveUser);
    bool exclusiveUser (void) const;
    bool& exclusiveUser (void);

    void optional (bool _optional);
    bool optional (void) const;
    bool& optional (void);

    void kind (::Deployment::CCMComponentPortKind _kind);
    ::Deployment::CCMComponentPortKind kind (void) const;
    ::Deployment::CCMComponentPortKind& kind (void);

    void templateParam (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _templateParam);
    void templateParam (::TAOX11_NAMESPACE::CORBA::StringSeq&& _templateParam);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam (void);

    void swap (ComponentPortDescription& s);

  private:
    std::string name_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    bool provider_;
    bool exclusiveProvider_;
    bool exclusiveUser_;
    bool optional_;
    ::Deployment::CCMComponentPortKind kind_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam_;
  }; // ComponentPortDescription

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ComponentPortDescription> ComponentPortDescriptions;

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentPropertyDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ComponentPropertyDescription (void);
    ~ComponentPropertyDescription (void) = default;
    ComponentPropertyDescription (const ComponentPropertyDescription&) = default;
    ComponentPropertyDescription (ComponentPropertyDescription&&) = default;
    explicit ComponentPropertyDescription (std::string name,
                                           TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> type);
    ComponentPropertyDescription& operator= (const ComponentPropertyDescription& x);
    ComponentPropertyDescription& operator= (ComponentPropertyDescription&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void type (TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> _type);
    TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> type (void) const;
    TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode>& type (void);

    void swap (ComponentPropertyDescription& s);

  private:
    std::string name_;
    TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> type_;
  }; // ComponentPropertyDescription

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ComponentPropertyDescription> ComponentPropertyDescriptions;

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentInterfaceDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ComponentInterfaceDescription (void);
    ~ComponentInterfaceDescription (void) = default;
    ComponentInterfaceDescription (const ComponentInterfaceDescription&) = default;
    ComponentInterfaceDescription (ComponentInterfaceDescription&&) = default;
    explicit ComponentInterfaceDescription (std::string label,
                                            std::string UUID,
                                            std::string specificType,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile,
                                            ::Deployment::Properties configProperty,
                                            ::Deployment::ComponentPortDescriptions port,
                                            ::Deployment::ComponentPropertyDescriptions property,
                                            ::Deployment::Properties infoProperty);
    ComponentInterfaceDescription& operator= (const ComponentInterfaceDescription& x);
    ComponentInterfaceDescription& operator= (ComponentInterfaceDescription&& x);

    void label (const std::string& _label);
    void label (std::string&& _label);
    const std::string& label (void) const;
    std::string& label (void);

    void UUID (const std::string& _UUID);
    void UUID (std::string&& _UUID);
    const std::string& UUID (void) const;
    std::string& UUID (void);

    void specificType (const std::string& _specificType);
    void specificType (std::string&& _specificType);
    const std::string& specificType (void) const;
    std::string& specificType (void);

    void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void);

    void idlFile (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _idlFile);
    void idlFile (::TAOX11_NAMESPACE::CORBA::StringSeq&& _idlFile);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile (void);

    void configProperty (const ::Deployment::Properties& _configProperty);
    void configProperty (::Deployment::Properties&& _configProperty);
    const ::Deployment::Properties& configProperty (void) const;
    ::Deployment::Properties& configProperty (void);

    void port (const ::Deployment::ComponentPortDescriptions& _port);
    void port (::Deployment::ComponentPortDescriptions&& _port);
    const ::Deployment::ComponentPortDescriptions& port (void) const;
    ::Deployment::ComponentPortDescriptions& port (void);

    void property (const ::Deployment::ComponentPropertyDescriptions& _property);
    void property (::Deployment::ComponentPropertyDescriptions&& _property);
    const ::Deployment::ComponentPropertyDescriptions& property (void) const;
    ::Deployment::ComponentPropertyDescriptions& property (void);

    void infoProperty (const ::Deployment::Properties& _infoProperty);
    void infoProperty (::Deployment::Properties&& _infoProperty);
    const ::Deployment::Properties& infoProperty (void) const;
    ::Deployment::Properties& infoProperty (void);

    void swap (ComponentInterfaceDescription& s);

  private:
    std::string label_;
    std::string UUID_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile_;
    ::Deployment::Properties configProperty_;
    ::Deployment::ComponentPortDescriptions port_;
    ::Deployment::ComponentPropertyDescriptions property_;
    ::Deployment::Properties infoProperty_;
  }; // ComponentInterfaceDescription

  // generated from c++/cli_hdr/struct_pre.erb
  class MonolithicDeploymentDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    MonolithicDeploymentDescription (void);
    ~MonolithicDeploymentDescription (void) = default;
    MonolithicDeploymentDescription (const MonolithicDeploymentDescription&) = default;
    MonolithicDeploymentDescription (MonolithicDeploymentDescription&&) = default;
    explicit MonolithicDeploymentDescription (std::string name,
                                              ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                              ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef,
                                              ::Deployment::Properties execParameter,
                                              ::Deployment::Requirements deployRequirement);
    MonolithicDeploymentDescription& operator= (const MonolithicDeploymentDescription& x);
    MonolithicDeploymentDescription& operator= (MonolithicDeploymentDescription&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    void artifactRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _artifactRef);
    void artifactRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _artifactRef);
    const ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef (void) const;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef (void);

    void execParameter (const ::Deployment::Properties& _execParameter);
    void execParameter (::Deployment::Properties&& _execParameter);
    const ::Deployment::Properties& execParameter (void) const;
    ::Deployment::Properties& execParameter (void);

    void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    const ::Deployment::Requirements& deployRequirement (void) const;
    ::Deployment::Requirements& deployRequirement (void);

    void swap (MonolithicDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
  }; // MonolithicDeploymentDescription

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < MonolithicDeploymentDescription> MonolithicDeploymentDescriptions;

  // generated from c++/cli_hdr/enum.erb
  enum class ResourceUsageKind : uint32_t
  {
    None,
    InstanceUsesResource,
    ResourceUsesInstance,
    PortUsesResource,
    ResourceUsesPort
  }; // ResourceUsageKind

  // generated from c++/cli_hdr/struct_pre.erb
  class InstanceResourceDeploymentDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    InstanceResourceDeploymentDescription (void);
    ~InstanceResourceDeploymentDescription (void) = default;
    InstanceResourceDeploymentDescription (const InstanceResourceDeploymentDescription&) = default;
    InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription&&) = default;
    explicit InstanceResourceDeploymentDescription (::Deployment::ResourceUsageKind resourceUsage,
                                                    std::string requirementName,
                                                    std::string resourceName,
                                                    ::Deployment::Properties property);
    InstanceResourceDeploymentDescription& operator= (const InstanceResourceDeploymentDescription& x);
    InstanceResourceDeploymentDescription& operator= (InstanceResourceDeploymentDescription&& x);

    void resourceUsage (::Deployment::ResourceUsageKind _resourceUsage);
    ::Deployment::ResourceUsageKind resourceUsage (void) const;
    ::Deployment::ResourceUsageKind& resourceUsage (void);

    void requirementName (const std::string& _requirementName);
    void requirementName (std::string&& _requirementName);
    const std::string& requirementName (void) const;
    std::string& requirementName (void);

    void resourceName (const std::string& _resourceName);
    void resourceName (std::string&& _resourceName);
    const std::string& resourceName (void) const;
    std::string& resourceName (void);

    void property (const ::Deployment::Properties& _property);
    void property (::Deployment::Properties&& _property);
    const ::Deployment::Properties& property (void) const;
    ::Deployment::Properties& property (void);

    void swap (InstanceResourceDeploymentDescription& s);

  private:
    ::Deployment::ResourceUsageKind resourceUsage_;
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  }; // InstanceResourceDeploymentDescription

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < InstanceResourceDeploymentDescription> InstanceResourceDeploymentDescriptions;

  // generated from c++/cli_hdr/struct_pre.erb
  class InstanceDeploymentDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    InstanceDeploymentDescription (void);
    ~InstanceDeploymentDescription (void) = default;
    InstanceDeploymentDescription (const InstanceDeploymentDescription&) = default;
    InstanceDeploymentDescription (InstanceDeploymentDescription&&) = default;
    explicit InstanceDeploymentDescription (std::string name,
                                            std::string node,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                            uint32_t implementationRef,
                                            ::Deployment::Properties configProperty,
                                            ::Deployment::InstanceResourceDeploymentDescriptions deployedResource,
                                            ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource);
    InstanceDeploymentDescription& operator= (const InstanceDeploymentDescription& x);
    InstanceDeploymentDescription& operator= (InstanceDeploymentDescription&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void node (const std::string& _node);
    void node (std::string&& _node);
    const std::string& node (void) const;
    std::string& node (void);

    void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    void implementationRef (uint32_t _implementationRef);
    uint32_t implementationRef (void) const;
    uint32_t& implementationRef (void);

    void configProperty (const ::Deployment::Properties& _configProperty);
    void configProperty (::Deployment::Properties&& _configProperty);
    const ::Deployment::Properties& configProperty (void) const;
    ::Deployment::Properties& configProperty (void);

    void deployedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedResource);
    void deployedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedResource);
    const ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource (void) const;
    ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource (void);

    void deployedSharedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedSharedResource);
    void deployedSharedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedSharedResource);
    const ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource (void) const;
    ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource (void);

    void swap (InstanceDeploymentDescription& s);

  private:
    std::string name_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    uint32_t implementationRef_;
    ::Deployment::Properties configProperty_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedResource_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource_;
  }; // InstanceDeploymentDescription

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < InstanceDeploymentDescription> InstanceDeploymentDescriptions;

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentExternalPortEndpoint
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ComponentExternalPortEndpoint (void);
    ~ComponentExternalPortEndpoint (void) = default;
    ComponentExternalPortEndpoint (const ComponentExternalPortEndpoint&) = default;
    ComponentExternalPortEndpoint (ComponentExternalPortEndpoint&&) = default;
    explicit ComponentExternalPortEndpoint (std::string portName);
    ComponentExternalPortEndpoint& operator= (const ComponentExternalPortEndpoint& x);
    ComponentExternalPortEndpoint& operator= (ComponentExternalPortEndpoint&& x);

    void portName (const std::string& _portName);
    void portName (std::string&& _portName);
    const std::string& portName (void) const;
    std::string& portName (void);

    void swap (ComponentExternalPortEndpoint& s);

  private:
    std::string portName_;
  }; // ComponentExternalPortEndpoint

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ComponentExternalPortEndpoint> ComponentExternalPortEndpoints;

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanSubcomponentPortEndpoint
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    PlanSubcomponentPortEndpoint (void);
    ~PlanSubcomponentPortEndpoint (void) = default;
    PlanSubcomponentPortEndpoint (const PlanSubcomponentPortEndpoint&) = default;
    PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint&&) = default;
    explicit PlanSubcomponentPortEndpoint (std::string portName,
                                           bool provider,
                                           ::Deployment::CCMComponentPortKind kind,
                                           uint32_t instanceRef);
    PlanSubcomponentPortEndpoint& operator= (const PlanSubcomponentPortEndpoint& x);
    PlanSubcomponentPortEndpoint& operator= (PlanSubcomponentPortEndpoint&& x);

    void portName (const std::string& _portName);
    void portName (std::string&& _portName);
    const std::string& portName (void) const;
    std::string& portName (void);

    void provider (bool _provider);
    bool provider (void) const;
    bool& provider (void);

    void kind (::Deployment::CCMComponentPortKind _kind);
    ::Deployment::CCMComponentPortKind kind (void) const;
    ::Deployment::CCMComponentPortKind& kind (void);

    void instanceRef (uint32_t _instanceRef);
    uint32_t instanceRef (void) const;
    uint32_t& instanceRef (void);

    void swap (PlanSubcomponentPortEndpoint& s);

  private:
    std::string portName_;
    bool provider_;
    ::Deployment::CCMComponentPortKind kind_;
    uint32_t instanceRef_;
  }; // PlanSubcomponentPortEndpoint

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanSubcomponentPortEndpoint> PlanSubcomponentPortEndpoints;

  // generated from c++/cli_hdr/struct_pre.erb
  class ExternalReferenceEndpoint
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ExternalReferenceEndpoint (void);
    ~ExternalReferenceEndpoint (void) = default;
    ExternalReferenceEndpoint (const ExternalReferenceEndpoint&) = default;
    ExternalReferenceEndpoint (ExternalReferenceEndpoint&&) = default;
    explicit ExternalReferenceEndpoint (std::string location,
                                        bool provider,
                                        std::string portName,
                                        ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType);
    ExternalReferenceEndpoint& operator= (const ExternalReferenceEndpoint& x);
    ExternalReferenceEndpoint& operator= (ExternalReferenceEndpoint&& x);

    void location (const std::string& _location);
    void location (std::string&& _location);
    const std::string& location (void) const;
    std::string& location (void);

    void provider (bool _provider);
    bool provider (void) const;
    bool& provider (void);

    void portName (const std::string& _portName);
    void portName (std::string&& _portName);
    const std::string& portName (void) const;
    std::string& portName (void);

    void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void);

    void swap (ExternalReferenceEndpoint& s);

  private:
    std::string location_;
    bool provider_;
    std::string portName_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
  }; // ExternalReferenceEndpoint

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ExternalReferenceEndpoint> ExternalReferenceEndpoints;

  // generated from c++/cli_hdr/struct_pre.erb
  class ConnectionResourceDeploymentDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ConnectionResourceDeploymentDescription (void);
    ~ConnectionResourceDeploymentDescription (void) = default;
    ConnectionResourceDeploymentDescription (const ConnectionResourceDeploymentDescription&) = default;
    ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription&&) = default;
    explicit ConnectionResourceDeploymentDescription (std::string targetName,
                                                      std::string requirementName,
                                                      std::string resourceName,
                                                      ::Deployment::Properties property);
    ConnectionResourceDeploymentDescription& operator= (const ConnectionResourceDeploymentDescription& x);
    ConnectionResourceDeploymentDescription& operator= (ConnectionResourceDeploymentDescription&& x);

    void targetName (const std::string& _targetName);
    void targetName (std::string&& _targetName);
    const std::string& targetName (void) const;
    std::string& targetName (void);

    void requirementName (const std::string& _requirementName);
    void requirementName (std::string&& _requirementName);
    const std::string& requirementName (void) const;
    std::string& requirementName (void);

    void resourceName (const std::string& _resourceName);
    void resourceName (std::string&& _resourceName);
    const std::string& resourceName (void) const;
    std::string& resourceName (void);

    void property (const ::Deployment::Properties& _property);
    void property (::Deployment::Properties&& _property);
    const ::Deployment::Properties& property (void) const;
    ::Deployment::Properties& property (void);

    void swap (ConnectionResourceDeploymentDescription& s);

  private:
    std::string targetName_;
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  }; // ConnectionResourceDeploymentDescription

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ConnectionResourceDeploymentDescription> ConnectionResourceDeploymentDescriptions;

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanConnectionDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    PlanConnectionDescription (void);
    ~PlanConnectionDescription (void) = default;
    PlanConnectionDescription (const PlanConnectionDescription&) = default;
    PlanConnectionDescription (PlanConnectionDescription&&) = default;
    explicit PlanConnectionDescription (std::string name,
                                        ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                        ::Deployment::Requirements deployRequirement,
                                        ::Deployment::ComponentExternalPortEndpoints externalEndpoint,
                                        ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint,
                                        ::Deployment::ExternalReferenceEndpoints externalReference,
                                        ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource);
    PlanConnectionDescription& operator= (const PlanConnectionDescription& x);
    PlanConnectionDescription& operator= (PlanConnectionDescription&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    const ::Deployment::Requirements& deployRequirement (void) const;
    ::Deployment::Requirements& deployRequirement (void);

    void externalEndpoint (const ::Deployment::ComponentExternalPortEndpoints& _externalEndpoint);
    void externalEndpoint (::Deployment::ComponentExternalPortEndpoints&& _externalEndpoint);
    const ::Deployment::ComponentExternalPortEndpoints& externalEndpoint (void) const;
    ::Deployment::ComponentExternalPortEndpoints& externalEndpoint (void);

    void internalEndpoint (const ::Deployment::PlanSubcomponentPortEndpoints& _internalEndpoint);
    void internalEndpoint (::Deployment::PlanSubcomponentPortEndpoints&& _internalEndpoint);
    const ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint (void) const;
    ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint (void);

    void externalReference (const ::Deployment::ExternalReferenceEndpoints& _externalReference);
    void externalReference (::Deployment::ExternalReferenceEndpoints&& _externalReference);
    const ::Deployment::ExternalReferenceEndpoints& externalReference (void) const;
    ::Deployment::ExternalReferenceEndpoints& externalReference (void);

    void deployedResource (const ::Deployment::ConnectionResourceDeploymentDescriptions& _deployedResource);
    void deployedResource (::Deployment::ConnectionResourceDeploymentDescriptions&& _deployedResource);
    const ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource (void) const;
    ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource (void);

    void swap (PlanConnectionDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ComponentExternalPortEndpoints externalEndpoint_;
    ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint_;
    ::Deployment::ExternalReferenceEndpoints externalReference_;
    ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource_;
  }; // PlanConnectionDescription

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanConnectionDescription> PlanConnectionDescriptions;

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanSubcomponentPropertyReference
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    PlanSubcomponentPropertyReference (void);
    ~PlanSubcomponentPropertyReference (void) = default;
    PlanSubcomponentPropertyReference (const PlanSubcomponentPropertyReference&) = default;
    PlanSubcomponentPropertyReference (PlanSubcomponentPropertyReference&&) = default;
    explicit PlanSubcomponentPropertyReference (std::string propertyName,
                                                uint32_t instanceRef);
    PlanSubcomponentPropertyReference& operator= (const PlanSubcomponentPropertyReference& x);
    PlanSubcomponentPropertyReference& operator= (PlanSubcomponentPropertyReference&& x);

    void propertyName (const std::string& _propertyName);
    void propertyName (std::string&& _propertyName);
    const std::string& propertyName (void) const;
    std::string& propertyName (void);

    void instanceRef (uint32_t _instanceRef);
    uint32_t instanceRef (void) const;
    uint32_t& instanceRef (void);

    void swap (PlanSubcomponentPropertyReference& s);

  private:
    std::string propertyName_;
    uint32_t instanceRef_;
  }; // PlanSubcomponentPropertyReference

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanSubcomponentPropertyReference> PlanSubcomponentPropertyReferences;

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanPropertyMapping
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    PlanPropertyMapping (void);
    ~PlanPropertyMapping (void) = default;
    PlanPropertyMapping (const PlanPropertyMapping&) = default;
    PlanPropertyMapping (PlanPropertyMapping&&) = default;
    explicit PlanPropertyMapping (std::string name,
                                  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                  std::string externalName,
                                  ::Deployment::PlanSubcomponentPropertyReferences delegatesTo);
    PlanPropertyMapping& operator= (const PlanPropertyMapping& x);
    PlanPropertyMapping& operator= (PlanPropertyMapping&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    void externalName (const std::string& _externalName);
    void externalName (std::string&& _externalName);
    const std::string& externalName (void) const;
    std::string& externalName (void);

    void delegatesTo (const ::Deployment::PlanSubcomponentPropertyReferences& _delegatesTo);
    void delegatesTo (::Deployment::PlanSubcomponentPropertyReferences&& _delegatesTo);
    const ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo (void) const;
    ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo (void);

    void swap (PlanPropertyMapping& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    std::string externalName_;
    ::Deployment::PlanSubcomponentPropertyReferences delegatesTo_;
  }; // PlanPropertyMapping

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanPropertyMapping> PlanPropertyMappings;

  // generated from c++/cli_hdr/struct_pre.erb
  class ImplementationDependency
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ImplementationDependency (void);
    ~ImplementationDependency (void) = default;
    ImplementationDependency (const ImplementationDependency&) = default;
    ImplementationDependency (ImplementationDependency&&) = default;
    explicit ImplementationDependency (std::string requiredType);
    ImplementationDependency& operator= (const ImplementationDependency& x);
    ImplementationDependency& operator= (ImplementationDependency&& x);

    void requiredType (const std::string& _requiredType);
    void requiredType (std::string&& _requiredType);
    const std::string& requiredType (void) const;
    std::string& requiredType (void);

    void swap (ImplementationDependency& s);

  private:
    std::string requiredType_;
  }; // ImplementationDependency

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ImplementationDependency> ImplementationDependencies;

  // generated from c++/cli_hdr/struct_pre.erb
  class ResourceDeploymentDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ResourceDeploymentDescription (void);
    ~ResourceDeploymentDescription (void) = default;
    ResourceDeploymentDescription (const ResourceDeploymentDescription&) = default;
    ResourceDeploymentDescription (ResourceDeploymentDescription&&) = default;
    explicit ResourceDeploymentDescription (std::string requirementName,
                                            std::string resourceName,
                                            ::Deployment::Properties property);
    ResourceDeploymentDescription& operator= (const ResourceDeploymentDescription& x);
    ResourceDeploymentDescription& operator= (ResourceDeploymentDescription&& x);

    void requirementName (const std::string& _requirementName);
    void requirementName (std::string&& _requirementName);
    const std::string& requirementName (void) const;
    std::string& requirementName (void);

    void resourceName (const std::string& _resourceName);
    void resourceName (std::string&& _resourceName);
    const std::string& resourceName (void) const;
    std::string& resourceName (void);

    void property (const ::Deployment::Properties& _property);
    void property (::Deployment::Properties&& _property);
    const ::Deployment::Properties& property (void) const;
    ::Deployment::Properties& property (void);

    void swap (ResourceDeploymentDescription& s);

  private:
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  }; // ResourceDeploymentDescription

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ResourceDeploymentDescription> ResourceDeploymentDescriptions;

  // generated from c++/cli_hdr/struct_pre.erb
  class ArtifactDeploymentDescription
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ArtifactDeploymentDescription (void);
    ~ArtifactDeploymentDescription (void) = default;
    ArtifactDeploymentDescription (const ArtifactDeploymentDescription&) = default;
    ArtifactDeploymentDescription (ArtifactDeploymentDescription&&) = default;
    explicit ArtifactDeploymentDescription (std::string name,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq location,
                                            std::string node,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                            ::Deployment::Properties execParameter,
                                            ::Deployment::Requirements deployRequirement,
                                            ::Deployment::ResourceDeploymentDescriptions deployedResource);
    ArtifactDeploymentDescription& operator= (const ArtifactDeploymentDescription& x);
    ArtifactDeploymentDescription& operator= (ArtifactDeploymentDescription&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void location (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _location);
    void location (::TAOX11_NAMESPACE::CORBA::StringSeq&& _location);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& location (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& location (void);

    void node (const std::string& _node);
    void node (std::string&& _node);
    const std::string& node (void) const;
    std::string& node (void);

    void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    void execParameter (const ::Deployment::Properties& _execParameter);
    void execParameter (::Deployment::Properties&& _execParameter);
    const ::Deployment::Properties& execParameter (void) const;
    ::Deployment::Properties& execParameter (void);

    void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    const ::Deployment::Requirements& deployRequirement (void) const;
    ::Deployment::Requirements& deployRequirement (void);

    void deployedResource (const ::Deployment::ResourceDeploymentDescriptions& _deployedResource);
    void deployedResource (::Deployment::ResourceDeploymentDescriptions&& _deployedResource);
    const ::Deployment::ResourceDeploymentDescriptions& deployedResource (void) const;
    ::Deployment::ResourceDeploymentDescriptions& deployedResource (void);

    void swap (ArtifactDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq location_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ResourceDeploymentDescriptions deployedResource_;
  }; // ArtifactDeploymentDescription

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ArtifactDeploymentDescription> ArtifactDeploymentDescriptions;

  // generated from c++/cli_hdr/enum.erb
  enum class PlanLocalityKind : uint32_t
  {
    PlanSameProcess,
    PlanDifferentProcess,
    PlanNoConstraint
  }; // PlanLocalityKind

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanLocality
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    PlanLocality (void);
    ~PlanLocality (void) = default;
    PlanLocality (const PlanLocality&) = default;
    PlanLocality (PlanLocality&&) = default;
    explicit PlanLocality (::Deployment::PlanLocalityKind constraint,
                           ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef);
    PlanLocality& operator= (const PlanLocality& x);
    PlanLocality& operator= (PlanLocality&& x);

    void constraint (::Deployment::PlanLocalityKind _constraint);
    ::Deployment::PlanLocalityKind constraint (void) const;
    ::Deployment::PlanLocalityKind& constraint (void);

    void constrainedInstanceRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _constrainedInstanceRef);
    void constrainedInstanceRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _constrainedInstanceRef);
    const ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef (void) const;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef (void);

    void swap (PlanLocality& s);

  private:
    ::Deployment::PlanLocalityKind constraint_;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef_;
  }; // PlanLocality

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanLocality> PlanLocalities;

  // generated from c++/cli_hdr/struct_pre.erb
  class DeploymentPlan
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    DeploymentPlan (void);
    ~DeploymentPlan (void) = default;
    DeploymentPlan (const DeploymentPlan&) = default;
    DeploymentPlan (DeploymentPlan&&) = default;
    explicit DeploymentPlan (std::string label,
                             std::string UUID,
                             ::Deployment::ComponentInterfaceDescription realizes,
                             ::Deployment::MonolithicDeploymentDescriptions implementation,
                             ::Deployment::InstanceDeploymentDescriptions instance,
                             ::Deployment::PlanConnectionDescriptions connection,
                             ::Deployment::PlanPropertyMappings externalProperty,
                             ::Deployment::ImplementationDependencies dependsOn,
                             ::Deployment::ArtifactDeploymentDescriptions artifact,
                             ::Deployment::Properties infoProperty,
                             ::Deployment::PlanLocalities localityConstraint);
    DeploymentPlan& operator= (const DeploymentPlan& x);
    DeploymentPlan& operator= (DeploymentPlan&& x);

    void label (const std::string& _label);
    void label (std::string&& _label);
    const std::string& label (void) const;
    std::string& label (void);

    void UUID (const std::string& _UUID);
    void UUID (std::string&& _UUID);
    const std::string& UUID (void) const;
    std::string& UUID (void);

    void realizes (const ::Deployment::ComponentInterfaceDescription& _realizes);
    void realizes (::Deployment::ComponentInterfaceDescription&& _realizes);
    const ::Deployment::ComponentInterfaceDescription& realizes (void) const;
    ::Deployment::ComponentInterfaceDescription& realizes (void);

    void implementation (const ::Deployment::MonolithicDeploymentDescriptions& _implementation);
    void implementation (::Deployment::MonolithicDeploymentDescriptions&& _implementation);
    const ::Deployment::MonolithicDeploymentDescriptions& implementation (void) const;
    ::Deployment::MonolithicDeploymentDescriptions& implementation (void);

    void instance (const ::Deployment::InstanceDeploymentDescriptions& _instance);
    void instance (::Deployment::InstanceDeploymentDescriptions&& _instance);
    const ::Deployment::InstanceDeploymentDescriptions& instance (void) const;
    ::Deployment::InstanceDeploymentDescriptions& instance (void);

    void connection (const ::Deployment::PlanConnectionDescriptions& _connection);
    void connection (::Deployment::PlanConnectionDescriptions&& _connection);
    const ::Deployment::PlanConnectionDescriptions& connection (void) const;
    ::Deployment::PlanConnectionDescriptions& connection (void);

    void externalProperty (const ::Deployment::PlanPropertyMappings& _externalProperty);
    void externalProperty (::Deployment::PlanPropertyMappings&& _externalProperty);
    const ::Deployment::PlanPropertyMappings& externalProperty (void) const;
    ::Deployment::PlanPropertyMappings& externalProperty (void);

    void dependsOn (const ::Deployment::ImplementationDependencies& _dependsOn);
    void dependsOn (::Deployment::ImplementationDependencies&& _dependsOn);
    const ::Deployment::ImplementationDependencies& dependsOn (void) const;
    ::Deployment::ImplementationDependencies& dependsOn (void);

    void artifact (const ::Deployment::ArtifactDeploymentDescriptions& _artifact);
    void artifact (::Deployment::ArtifactDeploymentDescriptions&& _artifact);
    const ::Deployment::ArtifactDeploymentDescriptions& artifact (void) const;
    ::Deployment::ArtifactDeploymentDescriptions& artifact (void);

    void infoProperty (const ::Deployment::Properties& _infoProperty);
    void infoProperty (::Deployment::Properties&& _infoProperty);
    const ::Deployment::Properties& infoProperty (void) const;
    ::Deployment::Properties& infoProperty (void);

    void localityConstraint (const ::Deployment::PlanLocalities& _localityConstraint);
    void localityConstraint (::Deployment::PlanLocalities&& _localityConstraint);
    const ::Deployment::PlanLocalities& localityConstraint (void) const;
    ::Deployment::PlanLocalities& localityConstraint (void);

    void swap (DeploymentPlan& s);

  private:
    std::string label_;
    std::string UUID_;
    ::Deployment::ComponentInterfaceDescription realizes_;
    ::Deployment::MonolithicDeploymentDescriptions implementation_;
    ::Deployment::InstanceDeploymentDescriptions instance_;
    ::Deployment::PlanConnectionDescriptions connection_;
    ::Deployment::PlanPropertyMappings externalProperty_;
    ::Deployment::ImplementationDependencies dependsOn_;
    ::Deployment::ArtifactDeploymentDescriptions artifact_;
    ::Deployment::Properties infoProperty_;
    ::Deployment::PlanLocalities localityConstraint_;
  }; // DeploymentPlan

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentPackageReference
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ComponentPackageReference (void);
    ~ComponentPackageReference (void) = default;
    ComponentPackageReference (const ComponentPackageReference&) = default;
    ComponentPackageReference (ComponentPackageReference&&) = default;
    explicit ComponentPackageReference (std::string requiredUUID,
                                        std::string requiredName,
                                        ::Deployment::ComponentInterfaceDescription requiredType);
    ComponentPackageReference& operator= (const ComponentPackageReference& x);
    ComponentPackageReference& operator= (ComponentPackageReference&& x);

    void requiredUUID (const std::string& _requiredUUID);
    void requiredUUID (std::string&& _requiredUUID);
    const std::string& requiredUUID (void) const;
    std::string& requiredUUID (void);

    void requiredName (const std::string& _requiredName);
    void requiredName (std::string&& _requiredName);
    const std::string& requiredName (void) const;
    std::string& requiredName (void);

    void requiredType (const ::Deployment::ComponentInterfaceDescription& _requiredType);
    void requiredType (::Deployment::ComponentInterfaceDescription&& _requiredType);
    const ::Deployment::ComponentInterfaceDescription& requiredType (void) const;
    ::Deployment::ComponentInterfaceDescription& requiredType (void);

    void swap (ComponentPackageReference& s);

  private:
    std::string requiredUUID_;
    std::string requiredName_;
    ::Deployment::ComponentInterfaceDescription requiredType_;
  }; // ComponentPackageReference

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ComponentPackageReference> ComponentPackageReferences;

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ResourceUsageKind> ResourceUsageKinds;

  // generated from c++/cli_hdr/struct_pre.erb
  class ImplementationRequirement
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    ImplementationRequirement (void);
    ~ImplementationRequirement (void) = default;
    ImplementationRequirement (const ImplementationRequirement&) = default;
    ImplementationRequirement (ImplementationRequirement&&) = default;
    explicit ImplementationRequirement (::Deployment::ResourceUsageKinds resourceUsage,
                                        std::string resourcePort,
                                        std::string componentPort,
                                        std::string name,
                                        std::string resourceType,
                                        ::Deployment::Properties property);
    ImplementationRequirement& operator= (const ImplementationRequirement& x);
    ImplementationRequirement& operator= (ImplementationRequirement&& x);

    void resourceUsage (const ::Deployment::ResourceUsageKinds& _resourceUsage);
    void resourceUsage (::Deployment::ResourceUsageKinds&& _resourceUsage);
    const ::Deployment::ResourceUsageKinds& resourceUsage (void) const;
    ::Deployment::ResourceUsageKinds& resourceUsage (void);

    void resourcePort (const std::string& _resourcePort);
    void resourcePort (std::string&& _resourcePort);
    const std::string& resourcePort (void) const;
    std::string& resourcePort (void);

    void componentPort (const std::string& _componentPort);
    void componentPort (std::string&& _componentPort);
    const std::string& componentPort (void) const;
    std::string& componentPort (void);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void resourceType (const std::string& _resourceType);
    void resourceType (std::string&& _resourceType);
    const std::string& resourceType (void) const;
    std::string& resourceType (void);

    void property (const ::Deployment::Properties& _property);
    void property (::Deployment::Properties&& _property);
    const ::Deployment::Properties& property (void) const;
    ::Deployment::Properties& property (void);

    void swap (ImplementationRequirement& s);

  private:
    ::Deployment::ResourceUsageKinds resourceUsage_;
    std::string resourcePort_;
    std::string componentPort_;
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  }; // ImplementationRequirement

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ImplementationRequirement> ImplementationRequirements;

  // generated from c++/cli_hdr/struct_pre.erb
  class Capability
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    Capability (void);
    ~Capability (void) = default;
    Capability (const Capability&) = default;
    Capability (Capability&&) = default;
    explicit Capability (std::string name,
                         ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType,
                         ::Deployment::SatisfierProperties property);
    Capability& operator= (const Capability& x);
    Capability& operator= (Capability&& x);

    void name (const std::string& _name);
    void name (std::string&& _name);
    const std::string& name (void) const;
    std::string& name (void);

    void resourceType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _resourceType);
    void resourceType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _resourceType);
    const ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType (void) const;
    ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType (void);

    void property (const ::Deployment::SatisfierProperties& _property);
    void property (::Deployment::SatisfierProperties&& _property);
    const ::Deployment::SatisfierProperties& property (void) const;
    ::Deployment::SatisfierProperties& property (void);

    void swap (Capability& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType_;
    ::Deployment::SatisfierProperties property_;
  }; // Capability

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < Capability> Capabilities;
}; // namespace Deployment


// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::Property& m1, ::Deployment::Property& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::Requirement& m1, ::Deployment::Requirement& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::SatisfierProperty& m1, ::Deployment::SatisfierProperty& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPortDescription& m1, ::Deployment::ComponentPortDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPropertyDescription& m1, ::Deployment::ComponentPropertyDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentInterfaceDescription& m1, ::Deployment::ComponentInterfaceDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::MonolithicDeploymentDescription& m1, ::Deployment::MonolithicDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::InstanceResourceDeploymentDescription& m1, ::Deployment::InstanceResourceDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::InstanceDeploymentDescription& m1, ::Deployment::InstanceDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentExternalPortEndpoint& m1, ::Deployment::ComponentExternalPortEndpoint& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanSubcomponentPortEndpoint& m1, ::Deployment::PlanSubcomponentPortEndpoint& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ExternalReferenceEndpoint& m1, ::Deployment::ExternalReferenceEndpoint& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ConnectionResourceDeploymentDescription& m1, ::Deployment::ConnectionResourceDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanConnectionDescription& m1, ::Deployment::PlanConnectionDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanSubcomponentPropertyReference& m1, ::Deployment::PlanSubcomponentPropertyReference& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanPropertyMapping& m1, ::Deployment::PlanPropertyMapping& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ImplementationDependency& m1, ::Deployment::ImplementationDependency& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ResourceDeploymentDescription& m1, ::Deployment::ResourceDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ArtifactDeploymentDescription& m1, ::Deployment::ArtifactDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanLocality& m1, ::Deployment::PlanLocality& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::DeploymentPlan& m1, ::Deployment::DeploymentPlan& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPackageReference& m1, ::Deployment::ComponentPackageReference& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ImplementationRequirement& m1, ::Deployment::ImplementationRequirement& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::Capability& m1, ::Deployment::Capability& m2);
}; // std

// generated from c++/cli_hdr/inline.erb
#include "testC.inl"

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Property& m1, ::Deployment::Property& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Requirement& m1, ::Deployment::Requirement& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::SatisfierProperty& m1, ::Deployment::SatisfierProperty& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPortDescription& m1, ::Deployment::ComponentPortDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPropertyDescription& m1, ::Deployment::ComponentPropertyDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentInterfaceDescription& m1, ::Deployment::ComponentInterfaceDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::MonolithicDeploymentDescription& m1, ::Deployment::MonolithicDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::InstanceResourceDeploymentDescription& m1, ::Deployment::InstanceResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::InstanceDeploymentDescription& m1, ::Deployment::InstanceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentExternalPortEndpoint& m1, ::Deployment::ComponentExternalPortEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanSubcomponentPortEndpoint& m1, ::Deployment::PlanSubcomponentPortEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ExternalReferenceEndpoint& m1, ::Deployment::ExternalReferenceEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ConnectionResourceDeploymentDescription& m1, ::Deployment::ConnectionResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanConnectionDescription& m1, ::Deployment::PlanConnectionDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanSubcomponentPropertyReference& m1, ::Deployment::PlanSubcomponentPropertyReference& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanPropertyMapping& m1, ::Deployment::PlanPropertyMapping& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ImplementationDependency& m1, ::Deployment::ImplementationDependency& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ResourceDeploymentDescription& m1, ::Deployment::ResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ArtifactDeploymentDescription& m1, ::Deployment::ArtifactDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanLocality& m1, ::Deployment::PlanLocality& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::DeploymentPlan& m1, ::Deployment::DeploymentPlan& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPackageReference& m1, ::Deployment::ComponentPackageReference& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ImplementationRequirement& m1, ::Deployment::ImplementationRequirement& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Capability& m1, ::Deployment::Capability& m2)
  {
    m1.swap (m2);
  }
}; // std

// generated from c++/cli_hdr/post.erb
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testP.h"
#endif

#include /**/ "ace/post.h"

#endif // __RIDL_TESTC_H_INCLUDED__

// -*- END -*-
