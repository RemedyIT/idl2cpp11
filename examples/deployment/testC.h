// -*- C++ -*-
/*
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT
 *        Nijkerk, GLD
 *        The Netherlands
 *        http://www.remedy.nl \ http://www.theaceorb.nl
 */

#ifndef __RIDL_TESTC_H_INCLUDED__
#define __RIDL_TESTC_H_INCLUDED__


#include /**/ "ace/pre.h"

#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/anytypecode/any.h"
#include "tao/x11/corba_ostream.h"

using namespace TAOX11_NAMESPACE;

// generated from StubHeaderWriter#enter_module
namespace Deployment
{

  // generated from c++/cli_hdr/struct_pre.erb
  class Property final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline Property (void);
    ~Property (void) = default;
    Property (const Property&) = default;
    Property (Property&&) = default;
    explicit inline Property (std::string name,
                       TAOX11_NAMESPACE::CORBA::Any value);
    inline Property& operator= (const Property& x);
    inline Property& operator= (Property&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void value (const TAOX11_NAMESPACE::CORBA::Any& _value);
    inline void value (TAOX11_NAMESPACE::CORBA::Any&& _value);
    inline const TAOX11_NAMESPACE::CORBA::Any& value (void) const;
    inline TAOX11_NAMESPACE::CORBA::Any& value (void);

    inline void swap (Property& s);

  private:
    std::string name_;
    TAOX11_NAMESPACE::CORBA::Any value_;
  };// Property
  typedef Property Property_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < Property> Properties;
  struct Properties_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class Requirement final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline Requirement (void);
    ~Requirement (void) = default;
    Requirement (const Requirement&) = default;
    Requirement (Requirement&&) = default;
    explicit inline Requirement (std::string name,
                          std::string resourceType,
                          ::Deployment::Properties property);
    inline Requirement& operator= (const Requirement& x);
    inline Requirement& operator= (Requirement&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void resourceType (const std::string& _resourceType);
    inline void resourceType (std::string&& _resourceType);
    inline const std::string& resourceType (void) const;
    inline std::string& resourceType (void);

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property (void) const;
    inline ::Deployment::Properties& property (void);

    inline void swap (Requirement& s);

  private:
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  };// Requirement
  typedef Requirement Requirement_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < Requirement> Requirements;
  struct Requirements_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/enum.erb
  enum class SatisfierPropertyKind : uint32_t
  {
    Quantity,
    Capacity,
    Minimum,
    Maximum,
    Attribute,
    Selection
  };// SatisfierPropertyKind
  typedef SatisfierPropertyKind SatisfierPropertyKind_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/struct_pre.erb
  class SatisfierProperty final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline SatisfierProperty (void);
    ~SatisfierProperty (void) = default;
    SatisfierProperty (const SatisfierProperty&) = default;
    SatisfierProperty (SatisfierProperty&&) = default;
    explicit inline SatisfierProperty (std::string name,
                                ::Deployment::SatisfierPropertyKind kind,
                                bool dynamic,
                                TAOX11_NAMESPACE::CORBA::Any value);
    inline SatisfierProperty& operator= (const SatisfierProperty& x);
    inline SatisfierProperty& operator= (SatisfierProperty&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void kind (::Deployment::SatisfierPropertyKind _kind);
    inline ::Deployment::SatisfierPropertyKind kind (void) const;
    inline ::Deployment::SatisfierPropertyKind& kind (void);

    inline void dynamic (bool _dynamic);
    inline bool dynamic (void) const;
    inline bool& dynamic (void);

    inline void value (const TAOX11_NAMESPACE::CORBA::Any& _value);
    inline void value (TAOX11_NAMESPACE::CORBA::Any&& _value);
    inline const TAOX11_NAMESPACE::CORBA::Any& value (void) const;
    inline TAOX11_NAMESPACE::CORBA::Any& value (void);

    inline void swap (SatisfierProperty& s);

  private:
    std::string name_;
    ::Deployment::SatisfierPropertyKind kind_;
    bool dynamic_;
    TAOX11_NAMESPACE::CORBA::Any value_;
  };// SatisfierProperty
  typedef SatisfierProperty SatisfierProperty_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < SatisfierProperty> SatisfierProperties;
  struct SatisfierProperties_idl_t {}; // IDL traits type-id
}; // namespace Deployment


// generated from StubHeaderWriter#enter_module
namespace Deployment
{

  // generated from c++/cli_hdr/enum.erb
  enum class CCMComponentPortKind : uint32_t
  {
    Facet,
    SimplexReceptacle,
    MultiplexReceptacle,
    EventEmitter,
    EventPublisher,
    EventConsumer,
    ExtendedPort,
    MirrorPort
  };// CCMComponentPortKind
  typedef CCMComponentPortKind CCMComponentPortKind_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentPortDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ComponentPortDescription (void);
    ~ComponentPortDescription (void) = default;
    ComponentPortDescription (const ComponentPortDescription&) = default;
    ComponentPortDescription (ComponentPortDescription&&) = default;
    explicit inline ComponentPortDescription (std::string name,
                                       std::string specificType,
                                       ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                       bool provider,
                                       bool exclusiveProvider,
                                       bool exclusiveUser,
                                       bool optional,
                                       ::Deployment::CCMComponentPortKind kind,
                                       ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam);
    inline ComponentPortDescription& operator= (const ComponentPortDescription& x);
    inline ComponentPortDescription& operator= (ComponentPortDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void specificType (const std::string& _specificType);
    inline void specificType (std::string&& _specificType);
    inline const std::string& specificType (void) const;
    inline std::string& specificType (void);

    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void);

    inline void provider (bool _provider);
    inline bool provider (void) const;
    inline bool& provider (void);

    inline void exclusiveProvider (bool _exclusiveProvider);
    inline bool exclusiveProvider (void) const;
    inline bool& exclusiveProvider (void);

    inline void exclusiveUser (bool _exclusiveUser);
    inline bool exclusiveUser (void) const;
    inline bool& exclusiveUser (void);

    inline void optional (bool _optional);
    inline bool optional (void) const;
    inline bool& optional (void);

    inline void kind (::Deployment::CCMComponentPortKind _kind);
    inline ::Deployment::CCMComponentPortKind kind (void) const;
    inline ::Deployment::CCMComponentPortKind& kind (void);

    inline void templateParam (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _templateParam);
    inline void templateParam (::TAOX11_NAMESPACE::CORBA::StringSeq&& _templateParam);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam (void);

    inline void swap (ComponentPortDescription& s);

  private:
    std::string name_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    bool provider_;
    bool exclusiveProvider_;
    bool exclusiveUser_;
    bool optional_;
    ::Deployment::CCMComponentPortKind kind_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam_;
  };// ComponentPortDescription
  typedef ComponentPortDescription ComponentPortDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ComponentPortDescription> ComponentPortDescriptions;
  struct ComponentPortDescriptions_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentPropertyDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ComponentPropertyDescription (void);
    ~ComponentPropertyDescription (void) = default;
    ComponentPropertyDescription (const ComponentPropertyDescription&) = default;
    ComponentPropertyDescription (ComponentPropertyDescription&&) = default;
    explicit inline ComponentPropertyDescription (std::string name,
                                           TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> type);
    inline ComponentPropertyDescription& operator= (const ComponentPropertyDescription& x);
    inline ComponentPropertyDescription& operator= (ComponentPropertyDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void type (TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> _type);
    inline TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> type (void) const;
    inline TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode>& type (void);

    inline void swap (ComponentPropertyDescription& s);

  private:
    std::string name_;
    TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> type_;
  };// ComponentPropertyDescription
  typedef ComponentPropertyDescription ComponentPropertyDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ComponentPropertyDescription> ComponentPropertyDescriptions;
  struct ComponentPropertyDescriptions_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentInterfaceDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ComponentInterfaceDescription (void);
    ~ComponentInterfaceDescription (void) = default;
    ComponentInterfaceDescription (const ComponentInterfaceDescription&) = default;
    ComponentInterfaceDescription (ComponentInterfaceDescription&&) = default;
    explicit inline ComponentInterfaceDescription (std::string label,
                                            std::string UUID,
                                            std::string specificType,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile,
                                            ::Deployment::Properties configProperty,
                                            ::Deployment::ComponentPortDescriptions port,
                                            ::Deployment::ComponentPropertyDescriptions property,
                                            ::Deployment::Properties infoProperty);
    inline ComponentInterfaceDescription& operator= (const ComponentInterfaceDescription& x);
    inline ComponentInterfaceDescription& operator= (ComponentInterfaceDescription&& x);

    inline void label (const std::string& _label);
    inline void label (std::string&& _label);
    inline const std::string& label (void) const;
    inline std::string& label (void);

    inline void UUID (const std::string& _UUID);
    inline void UUID (std::string&& _UUID);
    inline const std::string& UUID (void) const;
    inline std::string& UUID (void);

    inline void specificType (const std::string& _specificType);
    inline void specificType (std::string&& _specificType);
    inline const std::string& specificType (void) const;
    inline std::string& specificType (void);

    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void);

    inline void idlFile (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _idlFile);
    inline void idlFile (::TAOX11_NAMESPACE::CORBA::StringSeq&& _idlFile);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile (void);

    inline void configProperty (const ::Deployment::Properties& _configProperty);
    inline void configProperty (::Deployment::Properties&& _configProperty);
    inline const ::Deployment::Properties& configProperty (void) const;
    inline ::Deployment::Properties& configProperty (void);

    inline void port (const ::Deployment::ComponentPortDescriptions& _port);
    inline void port (::Deployment::ComponentPortDescriptions&& _port);
    inline const ::Deployment::ComponentPortDescriptions& port (void) const;
    inline ::Deployment::ComponentPortDescriptions& port (void);

    inline void property (const ::Deployment::ComponentPropertyDescriptions& _property);
    inline void property (::Deployment::ComponentPropertyDescriptions&& _property);
    inline const ::Deployment::ComponentPropertyDescriptions& property (void) const;
    inline ::Deployment::ComponentPropertyDescriptions& property (void);

    inline void infoProperty (const ::Deployment::Properties& _infoProperty);
    inline void infoProperty (::Deployment::Properties&& _infoProperty);
    inline const ::Deployment::Properties& infoProperty (void) const;
    inline ::Deployment::Properties& infoProperty (void);

    inline void swap (ComponentInterfaceDescription& s);

  private:
    std::string label_;
    std::string UUID_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile_;
    ::Deployment::Properties configProperty_;
    ::Deployment::ComponentPortDescriptions port_;
    ::Deployment::ComponentPropertyDescriptions property_;
    ::Deployment::Properties infoProperty_;
  };// ComponentInterfaceDescription
  typedef ComponentInterfaceDescription ComponentInterfaceDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/struct_pre.erb
  class MonolithicDeploymentDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline MonolithicDeploymentDescription (void);
    ~MonolithicDeploymentDescription (void) = default;
    MonolithicDeploymentDescription (const MonolithicDeploymentDescription&) = default;
    MonolithicDeploymentDescription (MonolithicDeploymentDescription&&) = default;
    explicit inline MonolithicDeploymentDescription (std::string name,
                                              ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                              ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef,
                                              ::Deployment::Properties execParameter,
                                              ::Deployment::Requirements deployRequirement);
    inline MonolithicDeploymentDescription& operator= (const MonolithicDeploymentDescription& x);
    inline MonolithicDeploymentDescription& operator= (MonolithicDeploymentDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    inline void artifactRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _artifactRef);
    inline void artifactRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _artifactRef);
    inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef (void);

    inline void execParameter (const ::Deployment::Properties& _execParameter);
    inline void execParameter (::Deployment::Properties&& _execParameter);
    inline const ::Deployment::Properties& execParameter (void) const;
    inline ::Deployment::Properties& execParameter (void);

    inline void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    inline void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    inline const ::Deployment::Requirements& deployRequirement (void) const;
    inline ::Deployment::Requirements& deployRequirement (void);

    inline void swap (MonolithicDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
  };// MonolithicDeploymentDescription
  typedef MonolithicDeploymentDescription MonolithicDeploymentDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < MonolithicDeploymentDescription> MonolithicDeploymentDescriptions;
  struct MonolithicDeploymentDescriptions_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/enum.erb
  enum class ResourceUsageKind : uint32_t
  {
    None,
    InstanceUsesResource,
    ResourceUsesInstance,
    PortUsesResource,
    ResourceUsesPort
  };// ResourceUsageKind
  typedef ResourceUsageKind ResourceUsageKind_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/struct_pre.erb
  class InstanceResourceDeploymentDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline InstanceResourceDeploymentDescription (void);
    ~InstanceResourceDeploymentDescription (void) = default;
    InstanceResourceDeploymentDescription (const InstanceResourceDeploymentDescription&) = default;
    InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription&&) = default;
    explicit inline InstanceResourceDeploymentDescription (::Deployment::ResourceUsageKind resourceUsage,
                                                    std::string requirementName,
                                                    std::string resourceName,
                                                    ::Deployment::Properties property);
    inline InstanceResourceDeploymentDescription& operator= (const InstanceResourceDeploymentDescription& x);
    inline InstanceResourceDeploymentDescription& operator= (InstanceResourceDeploymentDescription&& x);

    inline void resourceUsage (::Deployment::ResourceUsageKind _resourceUsage);
    inline ::Deployment::ResourceUsageKind resourceUsage (void) const;
    inline ::Deployment::ResourceUsageKind& resourceUsage (void);

    inline void requirementName (const std::string& _requirementName);
    inline void requirementName (std::string&& _requirementName);
    inline const std::string& requirementName (void) const;
    inline std::string& requirementName (void);

    inline void resourceName (const std::string& _resourceName);
    inline void resourceName (std::string&& _resourceName);
    inline const std::string& resourceName (void) const;
    inline std::string& resourceName (void);

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property (void) const;
    inline ::Deployment::Properties& property (void);

    inline void swap (InstanceResourceDeploymentDescription& s);

  private:
    ::Deployment::ResourceUsageKind resourceUsage_;
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// InstanceResourceDeploymentDescription
  typedef InstanceResourceDeploymentDescription InstanceResourceDeploymentDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < InstanceResourceDeploymentDescription> InstanceResourceDeploymentDescriptions;
  struct InstanceResourceDeploymentDescriptions_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class InstanceDeploymentDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline InstanceDeploymentDescription (void);
    ~InstanceDeploymentDescription (void) = default;
    InstanceDeploymentDescription (const InstanceDeploymentDescription&) = default;
    InstanceDeploymentDescription (InstanceDeploymentDescription&&) = default;
    explicit inline InstanceDeploymentDescription (std::string name,
                                            std::string node,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                            uint32_t implementationRef,
                                            ::Deployment::Properties configProperty,
                                            ::Deployment::InstanceResourceDeploymentDescriptions deployedResource,
                                            ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource);
    inline InstanceDeploymentDescription& operator= (const InstanceDeploymentDescription& x);
    inline InstanceDeploymentDescription& operator= (InstanceDeploymentDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void node (const std::string& _node);
    inline void node (std::string&& _node);
    inline const std::string& node (void) const;
    inline std::string& node (void);

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    inline void implementationRef (uint32_t _implementationRef);
    inline uint32_t implementationRef (void) const;
    inline uint32_t& implementationRef (void);

    inline void configProperty (const ::Deployment::Properties& _configProperty);
    inline void configProperty (::Deployment::Properties&& _configProperty);
    inline const ::Deployment::Properties& configProperty (void) const;
    inline ::Deployment::Properties& configProperty (void);

    inline void deployedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedResource);
    inline void deployedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedResource);
    inline const ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource (void) const;
    inline ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource (void);

    inline void deployedSharedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedSharedResource);
    inline void deployedSharedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedSharedResource);
    inline const ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource (void) const;
    inline ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource (void);

    inline void swap (InstanceDeploymentDescription& s);

  private:
    std::string name_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    uint32_t implementationRef_;
    ::Deployment::Properties configProperty_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedResource_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource_;
  };// InstanceDeploymentDescription
  typedef InstanceDeploymentDescription InstanceDeploymentDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < InstanceDeploymentDescription> InstanceDeploymentDescriptions;
  struct InstanceDeploymentDescriptions_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentExternalPortEndpoint final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ComponentExternalPortEndpoint (void);
    ~ComponentExternalPortEndpoint (void) = default;
    ComponentExternalPortEndpoint (const ComponentExternalPortEndpoint&) = default;
    ComponentExternalPortEndpoint (ComponentExternalPortEndpoint&&) = default;
    explicit inline ComponentExternalPortEndpoint (std::string portName);
    inline ComponentExternalPortEndpoint& operator= (const ComponentExternalPortEndpoint& x);
    inline ComponentExternalPortEndpoint& operator= (ComponentExternalPortEndpoint&& x);

    inline void portName (const std::string& _portName);
    inline void portName (std::string&& _portName);
    inline const std::string& portName (void) const;
    inline std::string& portName (void);

    inline void swap (ComponentExternalPortEndpoint& s);

  private:
    std::string portName_;
  };// ComponentExternalPortEndpoint
  typedef ComponentExternalPortEndpoint ComponentExternalPortEndpoint_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ComponentExternalPortEndpoint> ComponentExternalPortEndpoints;
  struct ComponentExternalPortEndpoints_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanSubcomponentPortEndpoint final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline PlanSubcomponentPortEndpoint (void);
    ~PlanSubcomponentPortEndpoint (void) = default;
    PlanSubcomponentPortEndpoint (const PlanSubcomponentPortEndpoint&) = default;
    PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint&&) = default;
    explicit inline PlanSubcomponentPortEndpoint (std::string portName,
                                           bool provider,
                                           ::Deployment::CCMComponentPortKind kind,
                                           uint32_t instanceRef);
    inline PlanSubcomponentPortEndpoint& operator= (const PlanSubcomponentPortEndpoint& x);
    inline PlanSubcomponentPortEndpoint& operator= (PlanSubcomponentPortEndpoint&& x);

    inline void portName (const std::string& _portName);
    inline void portName (std::string&& _portName);
    inline const std::string& portName (void) const;
    inline std::string& portName (void);

    inline void provider (bool _provider);
    inline bool provider (void) const;
    inline bool& provider (void);

    inline void kind (::Deployment::CCMComponentPortKind _kind);
    inline ::Deployment::CCMComponentPortKind kind (void) const;
    inline ::Deployment::CCMComponentPortKind& kind (void);

    inline void instanceRef (uint32_t _instanceRef);
    inline uint32_t instanceRef (void) const;
    inline uint32_t& instanceRef (void);

    inline void swap (PlanSubcomponentPortEndpoint& s);

  private:
    std::string portName_;
    bool provider_;
    ::Deployment::CCMComponentPortKind kind_;
    uint32_t instanceRef_;
  };// PlanSubcomponentPortEndpoint
  typedef PlanSubcomponentPortEndpoint PlanSubcomponentPortEndpoint_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanSubcomponentPortEndpoint> PlanSubcomponentPortEndpoints;
  struct PlanSubcomponentPortEndpoints_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class ExternalReferenceEndpoint final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ExternalReferenceEndpoint (void);
    ~ExternalReferenceEndpoint (void) = default;
    ExternalReferenceEndpoint (const ExternalReferenceEndpoint&) = default;
    ExternalReferenceEndpoint (ExternalReferenceEndpoint&&) = default;
    explicit inline ExternalReferenceEndpoint (std::string location,
                                        bool provider,
                                        std::string portName,
                                        ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType);
    inline ExternalReferenceEndpoint& operator= (const ExternalReferenceEndpoint& x);
    inline ExternalReferenceEndpoint& operator= (ExternalReferenceEndpoint&& x);

    inline void location (const std::string& _location);
    inline void location (std::string&& _location);
    inline const std::string& location (void) const;
    inline std::string& location (void);

    inline void provider (bool _provider);
    inline bool provider (void) const;
    inline bool& provider (void);

    inline void portName (const std::string& _portName);
    inline void portName (std::string&& _portName);
    inline const std::string& portName (void) const;
    inline std::string& portName (void);

    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType (void);

    inline void swap (ExternalReferenceEndpoint& s);

  private:
    std::string location_;
    bool provider_;
    std::string portName_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
  };// ExternalReferenceEndpoint
  typedef ExternalReferenceEndpoint ExternalReferenceEndpoint_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ExternalReferenceEndpoint> ExternalReferenceEndpoints;
  struct ExternalReferenceEndpoints_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class ConnectionResourceDeploymentDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ConnectionResourceDeploymentDescription (void);
    ~ConnectionResourceDeploymentDescription (void) = default;
    ConnectionResourceDeploymentDescription (const ConnectionResourceDeploymentDescription&) = default;
    ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription&&) = default;
    explicit inline ConnectionResourceDeploymentDescription (std::string targetName,
                                                      std::string requirementName,
                                                      std::string resourceName,
                                                      ::Deployment::Properties property);
    inline ConnectionResourceDeploymentDescription& operator= (const ConnectionResourceDeploymentDescription& x);
    inline ConnectionResourceDeploymentDescription& operator= (ConnectionResourceDeploymentDescription&& x);

    inline void targetName (const std::string& _targetName);
    inline void targetName (std::string&& _targetName);
    inline const std::string& targetName (void) const;
    inline std::string& targetName (void);

    inline void requirementName (const std::string& _requirementName);
    inline void requirementName (std::string&& _requirementName);
    inline const std::string& requirementName (void) const;
    inline std::string& requirementName (void);

    inline void resourceName (const std::string& _resourceName);
    inline void resourceName (std::string&& _resourceName);
    inline const std::string& resourceName (void) const;
    inline std::string& resourceName (void);

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property (void) const;
    inline ::Deployment::Properties& property (void);

    inline void swap (ConnectionResourceDeploymentDescription& s);

  private:
    std::string targetName_;
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// ConnectionResourceDeploymentDescription
  typedef ConnectionResourceDeploymentDescription ConnectionResourceDeploymentDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ConnectionResourceDeploymentDescription> ConnectionResourceDeploymentDescriptions;
  struct ConnectionResourceDeploymentDescriptions_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanConnectionDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline PlanConnectionDescription (void);
    ~PlanConnectionDescription (void) = default;
    PlanConnectionDescription (const PlanConnectionDescription&) = default;
    PlanConnectionDescription (PlanConnectionDescription&&) = default;
    explicit inline PlanConnectionDescription (std::string name,
                                        ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                        ::Deployment::Requirements deployRequirement,
                                        ::Deployment::ComponentExternalPortEndpoints externalEndpoint,
                                        ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint,
                                        ::Deployment::ExternalReferenceEndpoints externalReference,
                                        ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource);
    inline PlanConnectionDescription& operator= (const PlanConnectionDescription& x);
    inline PlanConnectionDescription& operator= (PlanConnectionDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    inline void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    inline void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    inline const ::Deployment::Requirements& deployRequirement (void) const;
    inline ::Deployment::Requirements& deployRequirement (void);

    inline void externalEndpoint (const ::Deployment::ComponentExternalPortEndpoints& _externalEndpoint);
    inline void externalEndpoint (::Deployment::ComponentExternalPortEndpoints&& _externalEndpoint);
    inline const ::Deployment::ComponentExternalPortEndpoints& externalEndpoint (void) const;
    inline ::Deployment::ComponentExternalPortEndpoints& externalEndpoint (void);

    inline void internalEndpoint (const ::Deployment::PlanSubcomponentPortEndpoints& _internalEndpoint);
    inline void internalEndpoint (::Deployment::PlanSubcomponentPortEndpoints&& _internalEndpoint);
    inline const ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint (void) const;
    inline ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint (void);

    inline void externalReference (const ::Deployment::ExternalReferenceEndpoints& _externalReference);
    inline void externalReference (::Deployment::ExternalReferenceEndpoints&& _externalReference);
    inline const ::Deployment::ExternalReferenceEndpoints& externalReference (void) const;
    inline ::Deployment::ExternalReferenceEndpoints& externalReference (void);

    inline void deployedResource (const ::Deployment::ConnectionResourceDeploymentDescriptions& _deployedResource);
    inline void deployedResource (::Deployment::ConnectionResourceDeploymentDescriptions&& _deployedResource);
    inline const ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource (void) const;
    inline ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource (void);

    inline void swap (PlanConnectionDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ComponentExternalPortEndpoints externalEndpoint_;
    ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint_;
    ::Deployment::ExternalReferenceEndpoints externalReference_;
    ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource_;
  };// PlanConnectionDescription
  typedef PlanConnectionDescription PlanConnectionDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanConnectionDescription> PlanConnectionDescriptions;
  struct PlanConnectionDescriptions_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanSubcomponentPropertyReference final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline PlanSubcomponentPropertyReference (void);
    ~PlanSubcomponentPropertyReference (void) = default;
    PlanSubcomponentPropertyReference (const PlanSubcomponentPropertyReference&) = default;
    PlanSubcomponentPropertyReference (PlanSubcomponentPropertyReference&&) = default;
    explicit inline PlanSubcomponentPropertyReference (std::string propertyName,
                                                uint32_t instanceRef);
    inline PlanSubcomponentPropertyReference& operator= (const PlanSubcomponentPropertyReference& x);
    inline PlanSubcomponentPropertyReference& operator= (PlanSubcomponentPropertyReference&& x);

    inline void propertyName (const std::string& _propertyName);
    inline void propertyName (std::string&& _propertyName);
    inline const std::string& propertyName (void) const;
    inline std::string& propertyName (void);

    inline void instanceRef (uint32_t _instanceRef);
    inline uint32_t instanceRef (void) const;
    inline uint32_t& instanceRef (void);

    inline void swap (PlanSubcomponentPropertyReference& s);

  private:
    std::string propertyName_;
    uint32_t instanceRef_;
  };// PlanSubcomponentPropertyReference
  typedef PlanSubcomponentPropertyReference PlanSubcomponentPropertyReference_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanSubcomponentPropertyReference> PlanSubcomponentPropertyReferences;
  struct PlanSubcomponentPropertyReferences_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanPropertyMapping final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline PlanPropertyMapping (void);
    ~PlanPropertyMapping (void) = default;
    PlanPropertyMapping (const PlanPropertyMapping&) = default;
    PlanPropertyMapping (PlanPropertyMapping&&) = default;
    explicit inline PlanPropertyMapping (std::string name,
                                  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                  std::string externalName,
                                  ::Deployment::PlanSubcomponentPropertyReferences delegatesTo);
    inline PlanPropertyMapping& operator= (const PlanPropertyMapping& x);
    inline PlanPropertyMapping& operator= (PlanPropertyMapping&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    inline void externalName (const std::string& _externalName);
    inline void externalName (std::string&& _externalName);
    inline const std::string& externalName (void) const;
    inline std::string& externalName (void);

    inline void delegatesTo (const ::Deployment::PlanSubcomponentPropertyReferences& _delegatesTo);
    inline void delegatesTo (::Deployment::PlanSubcomponentPropertyReferences&& _delegatesTo);
    inline const ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo (void) const;
    inline ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo (void);

    inline void swap (PlanPropertyMapping& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    std::string externalName_;
    ::Deployment::PlanSubcomponentPropertyReferences delegatesTo_;
  };// PlanPropertyMapping
  typedef PlanPropertyMapping PlanPropertyMapping_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanPropertyMapping> PlanPropertyMappings;
  struct PlanPropertyMappings_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class ImplementationDependency final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ImplementationDependency (void);
    ~ImplementationDependency (void) = default;
    ImplementationDependency (const ImplementationDependency&) = default;
    ImplementationDependency (ImplementationDependency&&) = default;
    explicit inline ImplementationDependency (std::string requiredType);
    inline ImplementationDependency& operator= (const ImplementationDependency& x);
    inline ImplementationDependency& operator= (ImplementationDependency&& x);

    inline void requiredType (const std::string& _requiredType);
    inline void requiredType (std::string&& _requiredType);
    inline const std::string& requiredType (void) const;
    inline std::string& requiredType (void);

    inline void swap (ImplementationDependency& s);

  private:
    std::string requiredType_;
  };// ImplementationDependency
  typedef ImplementationDependency ImplementationDependency_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ImplementationDependency> ImplementationDependencies;
  struct ImplementationDependencies_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class ResourceDeploymentDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ResourceDeploymentDescription (void);
    ~ResourceDeploymentDescription (void) = default;
    ResourceDeploymentDescription (const ResourceDeploymentDescription&) = default;
    ResourceDeploymentDescription (ResourceDeploymentDescription&&) = default;
    explicit inline ResourceDeploymentDescription (std::string requirementName,
                                            std::string resourceName,
                                            ::Deployment::Properties property);
    inline ResourceDeploymentDescription& operator= (const ResourceDeploymentDescription& x);
    inline ResourceDeploymentDescription& operator= (ResourceDeploymentDescription&& x);

    inline void requirementName (const std::string& _requirementName);
    inline void requirementName (std::string&& _requirementName);
    inline const std::string& requirementName (void) const;
    inline std::string& requirementName (void);

    inline void resourceName (const std::string& _resourceName);
    inline void resourceName (std::string&& _resourceName);
    inline const std::string& resourceName (void) const;
    inline std::string& resourceName (void);

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property (void) const;
    inline ::Deployment::Properties& property (void);

    inline void swap (ResourceDeploymentDescription& s);

  private:
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// ResourceDeploymentDescription
  typedef ResourceDeploymentDescription ResourceDeploymentDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ResourceDeploymentDescription> ResourceDeploymentDescriptions;
  struct ResourceDeploymentDescriptions_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class ArtifactDeploymentDescription final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ArtifactDeploymentDescription (void);
    ~ArtifactDeploymentDescription (void) = default;
    ArtifactDeploymentDescription (const ArtifactDeploymentDescription&) = default;
    ArtifactDeploymentDescription (ArtifactDeploymentDescription&&) = default;
    explicit inline ArtifactDeploymentDescription (std::string name,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq location,
                                            std::string node,
                                            ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                            ::Deployment::Properties execParameter,
                                            ::Deployment::Requirements deployRequirement,
                                            ::Deployment::ResourceDeploymentDescriptions deployedResource);
    inline ArtifactDeploymentDescription& operator= (const ArtifactDeploymentDescription& x);
    inline ArtifactDeploymentDescription& operator= (ArtifactDeploymentDescription&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void location (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _location);
    inline void location (::TAOX11_NAMESPACE::CORBA::StringSeq&& _location);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& location (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& location (void);

    inline void node (const std::string& _node);
    inline void node (std::string&& _node);
    inline const std::string& node (void) const;
    inline std::string& node (void);

    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source (void);

    inline void execParameter (const ::Deployment::Properties& _execParameter);
    inline void execParameter (::Deployment::Properties&& _execParameter);
    inline const ::Deployment::Properties& execParameter (void) const;
    inline ::Deployment::Properties& execParameter (void);

    inline void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    inline void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    inline const ::Deployment::Requirements& deployRequirement (void) const;
    inline ::Deployment::Requirements& deployRequirement (void);

    inline void deployedResource (const ::Deployment::ResourceDeploymentDescriptions& _deployedResource);
    inline void deployedResource (::Deployment::ResourceDeploymentDescriptions&& _deployedResource);
    inline const ::Deployment::ResourceDeploymentDescriptions& deployedResource (void) const;
    inline ::Deployment::ResourceDeploymentDescriptions& deployedResource (void);

    inline void swap (ArtifactDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq location_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ResourceDeploymentDescriptions deployedResource_;
  };// ArtifactDeploymentDescription
  typedef ArtifactDeploymentDescription ArtifactDeploymentDescription_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ArtifactDeploymentDescription> ArtifactDeploymentDescriptions;
  struct ArtifactDeploymentDescriptions_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/enum.erb
  enum class PlanLocalityKind : uint32_t
  {
    PlanSameProcess,
    PlanDifferentProcess,
    PlanNoConstraint
  };// PlanLocalityKind
  typedef PlanLocalityKind PlanLocalityKind_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/struct_pre.erb
  class PlanLocality final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline PlanLocality (void);
    ~PlanLocality (void) = default;
    PlanLocality (const PlanLocality&) = default;
    PlanLocality (PlanLocality&&) = default;
    explicit inline PlanLocality (::Deployment::PlanLocalityKind constraint,
                           ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef);
    inline PlanLocality& operator= (const PlanLocality& x);
    inline PlanLocality& operator= (PlanLocality&& x);

    inline void constraint (::Deployment::PlanLocalityKind _constraint);
    inline ::Deployment::PlanLocalityKind constraint (void) const;
    inline ::Deployment::PlanLocalityKind& constraint (void);

    inline void constrainedInstanceRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _constrainedInstanceRef);
    inline void constrainedInstanceRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _constrainedInstanceRef);
    inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef (void);

    inline void swap (PlanLocality& s);

  private:
    ::Deployment::PlanLocalityKind constraint_;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef_;
  };// PlanLocality
  typedef PlanLocality PlanLocality_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < PlanLocality> PlanLocalities;
  struct PlanLocalities_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class DeploymentPlan final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline DeploymentPlan (void);
    ~DeploymentPlan (void) = default;
    DeploymentPlan (const DeploymentPlan&) = default;
    DeploymentPlan (DeploymentPlan&&) = default;
    explicit inline DeploymentPlan (std::string label,
                             std::string UUID,
                             ::Deployment::ComponentInterfaceDescription realizes,
                             ::Deployment::MonolithicDeploymentDescriptions implementation,
                             ::Deployment::InstanceDeploymentDescriptions instance,
                             ::Deployment::PlanConnectionDescriptions connection,
                             ::Deployment::PlanPropertyMappings externalProperty,
                             ::Deployment::ImplementationDependencies dependsOn,
                             ::Deployment::ArtifactDeploymentDescriptions artifact,
                             ::Deployment::Properties infoProperty,
                             ::Deployment::PlanLocalities localityConstraint);
    inline DeploymentPlan& operator= (const DeploymentPlan& x);
    inline DeploymentPlan& operator= (DeploymentPlan&& x);

    inline void label (const std::string& _label);
    inline void label (std::string&& _label);
    inline const std::string& label (void) const;
    inline std::string& label (void);

    inline void UUID (const std::string& _UUID);
    inline void UUID (std::string&& _UUID);
    inline const std::string& UUID (void) const;
    inline std::string& UUID (void);

    inline void realizes (const ::Deployment::ComponentInterfaceDescription& _realizes);
    inline void realizes (::Deployment::ComponentInterfaceDescription&& _realizes);
    inline const ::Deployment::ComponentInterfaceDescription& realizes (void) const;
    inline ::Deployment::ComponentInterfaceDescription& realizes (void);

    inline void implementation (const ::Deployment::MonolithicDeploymentDescriptions& _implementation);
    inline void implementation (::Deployment::MonolithicDeploymentDescriptions&& _implementation);
    inline const ::Deployment::MonolithicDeploymentDescriptions& implementation (void) const;
    inline ::Deployment::MonolithicDeploymentDescriptions& implementation (void);

    inline void instance (const ::Deployment::InstanceDeploymentDescriptions& _instance);
    inline void instance (::Deployment::InstanceDeploymentDescriptions&& _instance);
    inline const ::Deployment::InstanceDeploymentDescriptions& instance (void) const;
    inline ::Deployment::InstanceDeploymentDescriptions& instance (void);

    inline void connection (const ::Deployment::PlanConnectionDescriptions& _connection);
    inline void connection (::Deployment::PlanConnectionDescriptions&& _connection);
    inline const ::Deployment::PlanConnectionDescriptions& connection (void) const;
    inline ::Deployment::PlanConnectionDescriptions& connection (void);

    inline void externalProperty (const ::Deployment::PlanPropertyMappings& _externalProperty);
    inline void externalProperty (::Deployment::PlanPropertyMappings&& _externalProperty);
    inline const ::Deployment::PlanPropertyMappings& externalProperty (void) const;
    inline ::Deployment::PlanPropertyMappings& externalProperty (void);

    inline void dependsOn (const ::Deployment::ImplementationDependencies& _dependsOn);
    inline void dependsOn (::Deployment::ImplementationDependencies&& _dependsOn);
    inline const ::Deployment::ImplementationDependencies& dependsOn (void) const;
    inline ::Deployment::ImplementationDependencies& dependsOn (void);

    inline void artifact (const ::Deployment::ArtifactDeploymentDescriptions& _artifact);
    inline void artifact (::Deployment::ArtifactDeploymentDescriptions&& _artifact);
    inline const ::Deployment::ArtifactDeploymentDescriptions& artifact (void) const;
    inline ::Deployment::ArtifactDeploymentDescriptions& artifact (void);

    inline void infoProperty (const ::Deployment::Properties& _infoProperty);
    inline void infoProperty (::Deployment::Properties&& _infoProperty);
    inline const ::Deployment::Properties& infoProperty (void) const;
    inline ::Deployment::Properties& infoProperty (void);

    inline void localityConstraint (const ::Deployment::PlanLocalities& _localityConstraint);
    inline void localityConstraint (::Deployment::PlanLocalities&& _localityConstraint);
    inline const ::Deployment::PlanLocalities& localityConstraint (void) const;
    inline ::Deployment::PlanLocalities& localityConstraint (void);

    inline void swap (DeploymentPlan& s);

  private:
    std::string label_;
    std::string UUID_;
    ::Deployment::ComponentInterfaceDescription realizes_;
    ::Deployment::MonolithicDeploymentDescriptions implementation_;
    ::Deployment::InstanceDeploymentDescriptions instance_;
    ::Deployment::PlanConnectionDescriptions connection_;
    ::Deployment::PlanPropertyMappings externalProperty_;
    ::Deployment::ImplementationDependencies dependsOn_;
    ::Deployment::ArtifactDeploymentDescriptions artifact_;
    ::Deployment::Properties infoProperty_;
    ::Deployment::PlanLocalities localityConstraint_;
  };// DeploymentPlan
  typedef DeploymentPlan DeploymentPlan_idl_t; // IDL traits typename
}; // namespace Deployment


// generated from StubHeaderWriter#enter_module
namespace Deployment
{

  // generated from c++/cli_hdr/struct_pre.erb
  class ComponentPackageReference final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ComponentPackageReference (void);
    ~ComponentPackageReference (void) = default;
    ComponentPackageReference (const ComponentPackageReference&) = default;
    ComponentPackageReference (ComponentPackageReference&&) = default;
    explicit inline ComponentPackageReference (std::string requiredUUID,
                                        std::string requiredName,
                                        ::Deployment::ComponentInterfaceDescription requiredType);
    inline ComponentPackageReference& operator= (const ComponentPackageReference& x);
    inline ComponentPackageReference& operator= (ComponentPackageReference&& x);

    inline void requiredUUID (const std::string& _requiredUUID);
    inline void requiredUUID (std::string&& _requiredUUID);
    inline const std::string& requiredUUID (void) const;
    inline std::string& requiredUUID (void);

    inline void requiredName (const std::string& _requiredName);
    inline void requiredName (std::string&& _requiredName);
    inline const std::string& requiredName (void) const;
    inline std::string& requiredName (void);

    inline void requiredType (const ::Deployment::ComponentInterfaceDescription& _requiredType);
    inline void requiredType (::Deployment::ComponentInterfaceDescription&& _requiredType);
    inline const ::Deployment::ComponentInterfaceDescription& requiredType (void) const;
    inline ::Deployment::ComponentInterfaceDescription& requiredType (void);

    inline void swap (ComponentPackageReference& s);

  private:
    std::string requiredUUID_;
    std::string requiredName_;
    ::Deployment::ComponentInterfaceDescription requiredType_;
  };// ComponentPackageReference
  typedef ComponentPackageReference ComponentPackageReference_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ComponentPackageReference> ComponentPackageReferences;
  struct ComponentPackageReferences_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ::Deployment::ResourceUsageKind> ResourceUsageKinds;
  struct ResourceUsageKinds_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class ImplementationRequirement final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline ImplementationRequirement (void);
    ~ImplementationRequirement (void) = default;
    ImplementationRequirement (const ImplementationRequirement&) = default;
    ImplementationRequirement (ImplementationRequirement&&) = default;
    explicit inline ImplementationRequirement (::Deployment::ResourceUsageKinds resourceUsage,
                                        std::string resourcePort,
                                        std::string componentPort,
                                        std::string name,
                                        std::string resourceType,
                                        ::Deployment::Properties property);
    inline ImplementationRequirement& operator= (const ImplementationRequirement& x);
    inline ImplementationRequirement& operator= (ImplementationRequirement&& x);

    inline void resourceUsage (const ::Deployment::ResourceUsageKinds& _resourceUsage);
    inline void resourceUsage (::Deployment::ResourceUsageKinds&& _resourceUsage);
    inline const ::Deployment::ResourceUsageKinds& resourceUsage (void) const;
    inline ::Deployment::ResourceUsageKinds& resourceUsage (void);

    inline void resourcePort (const std::string& _resourcePort);
    inline void resourcePort (std::string&& _resourcePort);
    inline const std::string& resourcePort (void) const;
    inline std::string& resourcePort (void);

    inline void componentPort (const std::string& _componentPort);
    inline void componentPort (std::string&& _componentPort);
    inline const std::string& componentPort (void) const;
    inline std::string& componentPort (void);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void resourceType (const std::string& _resourceType);
    inline void resourceType (std::string&& _resourceType);
    inline const std::string& resourceType (void) const;
    inline std::string& resourceType (void);

    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property (void) const;
    inline ::Deployment::Properties& property (void);

    inline void swap (ImplementationRequirement& s);

  private:
    ::Deployment::ResourceUsageKinds resourceUsage_;
    std::string resourcePort_;
    std::string componentPort_;
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  };// ImplementationRequirement
  typedef ImplementationRequirement ImplementationRequirement_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < ImplementationRequirement> ImplementationRequirements;
  struct ImplementationRequirements_idl_t {}; // IDL traits type-id

  // generated from c++/cli_hdr/struct_pre.erb
  class Capability final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    inline Capability (void);
    ~Capability (void) = default;
    Capability (const Capability&) = default;
    Capability (Capability&&) = default;
    explicit inline Capability (std::string name,
                         ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType,
                         ::Deployment::SatisfierProperties property);
    inline Capability& operator= (const Capability& x);
    inline Capability& operator= (Capability&& x);

    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name (void) const;
    inline std::string& name (void);

    inline void resourceType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _resourceType);
    inline void resourceType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _resourceType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType (void) const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType (void);

    inline void property (const ::Deployment::SatisfierProperties& _property);
    inline void property (::Deployment::SatisfierProperties&& _property);
    inline const ::Deployment::SatisfierProperties& property (void) const;
    inline ::Deployment::SatisfierProperties& property (void);

    inline void swap (Capability& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType_;
    ::Deployment::SatisfierProperties property_;
  };// Capability
  typedef Capability Capability_idl_t; // IDL traits typename

  // generated from c++/cli_hdr/typedef.erb
  typedef std::vector < Capability> Capabilities;
  struct Capabilities_idl_t {}; // IDL traits type-id
}; // namespace Deployment


// generated from StubHeaderTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE {
  namespace IDL {

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PROPERTY_TRAITS_)
#define _STRUCT_DEPLOYMENT_PROPERTY_TRAITS_
    template<>
    struct traits < ::Deployment::Property_idl_t>
      : IDL::common_traits< ::Deployment::Property>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PROPERTY_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::Properties_idl_t>
      : IDL::unbounded_traits< ::Deployment::Properties>,
        IDL::alias_traits< ::Deployment::Properties_idl_t,
                           ::Deployment::Properties>
    {
      typedef ::Deployment::Property&   element_cdr_to;
      typedef const ::Deployment::Property&  element_cdr_from;

      typedef IDL::traits< ::Deployment::Property_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_REQUIREMENT_TRAITS_)
#define _STRUCT_DEPLOYMENT_REQUIREMENT_TRAITS_
    template<>
    struct traits < ::Deployment::Requirement_idl_t>
      : IDL::common_traits< ::Deployment::Requirement>
    {
    };
#endif // _STRUCT_DEPLOYMENT_REQUIREMENT_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::Requirements_idl_t>
      : IDL::unbounded_traits< ::Deployment::Requirements>,
        IDL::alias_traits< ::Deployment::Requirements_idl_t,
                           ::Deployment::Requirements>
    {
      typedef ::Deployment::Requirement&   element_cdr_to;
      typedef const ::Deployment::Requirement&  element_cdr_from;

      typedef IDL::traits< ::Deployment::Requirement_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::SatisfierPropertyKind_idl_t>
      : IDL::common_traits< ::Deployment::SatisfierPropertyKind>
    {
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_SATISFIERPROPERTY_TRAITS_)
#define _STRUCT_DEPLOYMENT_SATISFIERPROPERTY_TRAITS_
    template<>
    struct traits < ::Deployment::SatisfierProperty_idl_t>
      : IDL::common_traits< ::Deployment::SatisfierProperty>
    {
    };
#endif // _STRUCT_DEPLOYMENT_SATISFIERPROPERTY_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::SatisfierProperties_idl_t>
      : IDL::unbounded_traits< ::Deployment::SatisfierProperties>,
        IDL::alias_traits< ::Deployment::SatisfierProperties_idl_t,
                           ::Deployment::SatisfierProperties>
    {
      typedef ::Deployment::SatisfierProperty&   element_cdr_to;
      typedef const ::Deployment::SatisfierProperty&  element_cdr_from;

      typedef IDL::traits< ::Deployment::SatisfierProperty_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::CCMComponentPortKind_idl_t>
      : IDL::common_traits< ::Deployment::CCMComponentPortKind>
    {
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTPORTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTPORTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPortDescription_idl_t>
      : IDL::common_traits< ::Deployment::ComponentPortDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTPORTDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ComponentPortDescriptions_idl_t>
      : IDL::unbounded_traits< ::Deployment::ComponentPortDescriptions>,
        IDL::alias_traits< ::Deployment::ComponentPortDescriptions_idl_t,
                           ::Deployment::ComponentPortDescriptions>
    {
      typedef ::Deployment::ComponentPortDescription&   element_cdr_to;
      typedef const ::Deployment::ComponentPortDescription&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ComponentPortDescription_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPropertyDescription_idl_t>
      : IDL::common_traits< ::Deployment::ComponentPropertyDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ComponentPropertyDescriptions_idl_t>
      : IDL::unbounded_traits< ::Deployment::ComponentPropertyDescriptions>,
        IDL::alias_traits< ::Deployment::ComponentPropertyDescriptions_idl_t,
                           ::Deployment::ComponentPropertyDescriptions>
    {
      typedef ::Deployment::ComponentPropertyDescription&   element_cdr_to;
      typedef const ::Deployment::ComponentPropertyDescription&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ComponentPropertyDescription_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTINTERFACEDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTINTERFACEDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentInterfaceDescription_idl_t>
      : IDL::common_traits< ::Deployment::ComponentInterfaceDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTINTERFACEDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::MonolithicDeploymentDescription_idl_t>
      : IDL::common_traits< ::Deployment::MonolithicDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::MonolithicDeploymentDescriptions_idl_t>
      : IDL::unbounded_traits< ::Deployment::MonolithicDeploymentDescriptions>,
        IDL::alias_traits< ::Deployment::MonolithicDeploymentDescriptions_idl_t,
                           ::Deployment::MonolithicDeploymentDescriptions>
    {
      typedef ::Deployment::MonolithicDeploymentDescription&   element_cdr_to;
      typedef const ::Deployment::MonolithicDeploymentDescription&  element_cdr_from;

      typedef IDL::traits< ::Deployment::MonolithicDeploymentDescription_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::ResourceUsageKind_idl_t>
      : IDL::common_traits< ::Deployment::ResourceUsageKind>
    {
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::InstanceResourceDeploymentDescription_idl_t>
      : IDL::common_traits< ::Deployment::InstanceResourceDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::InstanceResourceDeploymentDescriptions_idl_t>
      : IDL::unbounded_traits< ::Deployment::InstanceResourceDeploymentDescriptions>,
        IDL::alias_traits< ::Deployment::InstanceResourceDeploymentDescriptions_idl_t,
                           ::Deployment::InstanceResourceDeploymentDescriptions>
    {
      typedef ::Deployment::InstanceResourceDeploymentDescription&   element_cdr_to;
      typedef const ::Deployment::InstanceResourceDeploymentDescription&  element_cdr_from;

      typedef IDL::traits< ::Deployment::InstanceResourceDeploymentDescription_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::InstanceDeploymentDescription_idl_t>
      : IDL::common_traits< ::Deployment::InstanceDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::InstanceDeploymentDescriptions_idl_t>
      : IDL::unbounded_traits< ::Deployment::InstanceDeploymentDescriptions>,
        IDL::alias_traits< ::Deployment::InstanceDeploymentDescriptions_idl_t,
                           ::Deployment::InstanceDeploymentDescriptions>
    {
      typedef ::Deployment::InstanceDeploymentDescription&   element_cdr_to;
      typedef const ::Deployment::InstanceDeploymentDescription&  element_cdr_from;

      typedef IDL::traits< ::Deployment::InstanceDeploymentDescription_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentExternalPortEndpoint_idl_t>
      : IDL::common_traits< ::Deployment::ComponentExternalPortEndpoint>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ComponentExternalPortEndpoints_idl_t>
      : IDL::unbounded_traits< ::Deployment::ComponentExternalPortEndpoints>,
        IDL::alias_traits< ::Deployment::ComponentExternalPortEndpoints_idl_t,
                           ::Deployment::ComponentExternalPortEndpoints>
    {
      typedef ::Deployment::ComponentExternalPortEndpoint&   element_cdr_to;
      typedef const ::Deployment::ComponentExternalPortEndpoint&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ComponentExternalPortEndpoint_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::PlanSubcomponentPortEndpoint_idl_t>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPortEndpoint>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::PlanSubcomponentPortEndpoints_idl_t>
      : IDL::unbounded_traits< ::Deployment::PlanSubcomponentPortEndpoints>,
        IDL::alias_traits< ::Deployment::PlanSubcomponentPortEndpoints_idl_t,
                           ::Deployment::PlanSubcomponentPortEndpoints>
    {
      typedef ::Deployment::PlanSubcomponentPortEndpoint&   element_cdr_to;
      typedef const ::Deployment::PlanSubcomponentPortEndpoint&  element_cdr_from;

      typedef IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_EXTERNALREFERENCEENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT_EXTERNALREFERENCEENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::ExternalReferenceEndpoint_idl_t>
      : IDL::common_traits< ::Deployment::ExternalReferenceEndpoint>
    {
    };
#endif // _STRUCT_DEPLOYMENT_EXTERNALREFERENCEENDPOINT_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ExternalReferenceEndpoints_idl_t>
      : IDL::unbounded_traits< ::Deployment::ExternalReferenceEndpoints>,
        IDL::alias_traits< ::Deployment::ExternalReferenceEndpoints_idl_t,
                           ::Deployment::ExternalReferenceEndpoints>
    {
      typedef ::Deployment::ExternalReferenceEndpoint&   element_cdr_to;
      typedef const ::Deployment::ExternalReferenceEndpoint&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ExternalReferenceEndpoint_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ConnectionResourceDeploymentDescription_idl_t>
      : IDL::common_traits< ::Deployment::ConnectionResourceDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ConnectionResourceDeploymentDescriptions_idl_t>
      : IDL::unbounded_traits< ::Deployment::ConnectionResourceDeploymentDescriptions>,
        IDL::alias_traits< ::Deployment::ConnectionResourceDeploymentDescriptions_idl_t,
                           ::Deployment::ConnectionResourceDeploymentDescriptions>
    {
      typedef ::Deployment::ConnectionResourceDeploymentDescription&   element_cdr_to;
      typedef const ::Deployment::ConnectionResourceDeploymentDescription&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANCONNECTIONDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANCONNECTIONDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::PlanConnectionDescription_idl_t>
      : IDL::common_traits< ::Deployment::PlanConnectionDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANCONNECTIONDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::PlanConnectionDescriptions_idl_t>
      : IDL::unbounded_traits< ::Deployment::PlanConnectionDescriptions>,
        IDL::alias_traits< ::Deployment::PlanConnectionDescriptions_idl_t,
                           ::Deployment::PlanConnectionDescriptions>
    {
      typedef ::Deployment::PlanConnectionDescription&   element_cdr_to;
      typedef const ::Deployment::PlanConnectionDescription&  element_cdr_from;

      typedef IDL::traits< ::Deployment::PlanConnectionDescription_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_
    template<>
    struct traits < ::Deployment::PlanSubcomponentPropertyReference_idl_t>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPropertyReference>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::PlanSubcomponentPropertyReferences_idl_t>
      : IDL::unbounded_traits< ::Deployment::PlanSubcomponentPropertyReferences>,
        IDL::alias_traits< ::Deployment::PlanSubcomponentPropertyReferences_idl_t,
                           ::Deployment::PlanSubcomponentPropertyReferences>
    {
      typedef ::Deployment::PlanSubcomponentPropertyReference&   element_cdr_to;
      typedef const ::Deployment::PlanSubcomponentPropertyReference&  element_cdr_from;

      typedef IDL::traits< ::Deployment::PlanSubcomponentPropertyReference_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANPROPERTYMAPPING_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANPROPERTYMAPPING_TRAITS_
    template<>
    struct traits < ::Deployment::PlanPropertyMapping_idl_t>
      : IDL::common_traits< ::Deployment::PlanPropertyMapping>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANPROPERTYMAPPING_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::PlanPropertyMappings_idl_t>
      : IDL::unbounded_traits< ::Deployment::PlanPropertyMappings>,
        IDL::alias_traits< ::Deployment::PlanPropertyMappings_idl_t,
                           ::Deployment::PlanPropertyMappings>
    {
      typedef ::Deployment::PlanPropertyMapping&   element_cdr_to;
      typedef const ::Deployment::PlanPropertyMapping&  element_cdr_from;

      typedef IDL::traits< ::Deployment::PlanPropertyMapping_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY_TRAITS_)
#define _STRUCT_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY_TRAITS_
    template<>
    struct traits < ::Deployment::ImplementationDependency_idl_t>
      : IDL::common_traits< ::Deployment::ImplementationDependency>
    {
    };
#endif // _STRUCT_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ImplementationDependencies_idl_t>
      : IDL::unbounded_traits< ::Deployment::ImplementationDependencies>,
        IDL::alias_traits< ::Deployment::ImplementationDependencies_idl_t,
                           ::Deployment::ImplementationDependencies>
    {
      typedef ::Deployment::ImplementationDependency&   element_cdr_to;
      typedef const ::Deployment::ImplementationDependency&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ImplementationDependency_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ResourceDeploymentDescription_idl_t>
      : IDL::common_traits< ::Deployment::ResourceDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ResourceDeploymentDescriptions_idl_t>
      : IDL::unbounded_traits< ::Deployment::ResourceDeploymentDescriptions>,
        IDL::alias_traits< ::Deployment::ResourceDeploymentDescriptions_idl_t,
                           ::Deployment::ResourceDeploymentDescriptions>
    {
      typedef ::Deployment::ResourceDeploymentDescription&   element_cdr_to;
      typedef const ::Deployment::ResourceDeploymentDescription&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ResourceDeploymentDescription_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ArtifactDeploymentDescription_idl_t>
      : IDL::common_traits< ::Deployment::ArtifactDeploymentDescription>
    {
    };
#endif // _STRUCT_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ArtifactDeploymentDescriptions_idl_t>
      : IDL::unbounded_traits< ::Deployment::ArtifactDeploymentDescriptions>,
        IDL::alias_traits< ::Deployment::ArtifactDeploymentDescriptions_idl_t,
                           ::Deployment::ArtifactDeploymentDescriptions>
    {
      typedef ::Deployment::ArtifactDeploymentDescription&   element_cdr_to;
      typedef const ::Deployment::ArtifactDeploymentDescription&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ArtifactDeploymentDescription_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::PlanLocalityKind_idl_t>
      : IDL::common_traits< ::Deployment::PlanLocalityKind>
    {
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANLOCALITY_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANLOCALITY_TRAITS_
    template<>
    struct traits < ::Deployment::PlanLocality_idl_t>
      : IDL::common_traits< ::Deployment::PlanLocality>
    {
    };
#endif // _STRUCT_DEPLOYMENT_PLANLOCALITY_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::PlanLocalities_idl_t>
      : IDL::unbounded_traits< ::Deployment::PlanLocalities>,
        IDL::alias_traits< ::Deployment::PlanLocalities_idl_t,
                           ::Deployment::PlanLocalities>
    {
      typedef ::Deployment::PlanLocality&   element_cdr_to;
      typedef const ::Deployment::PlanLocality&  element_cdr_from;

      typedef IDL::traits< ::Deployment::PlanLocality_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_DEPLOYMENTPLAN_TRAITS_)
#define _STRUCT_DEPLOYMENT_DEPLOYMENTPLAN_TRAITS_
    template<>
    struct traits < ::Deployment::DeploymentPlan_idl_t>
      : IDL::common_traits< ::Deployment::DeploymentPlan>
    {
    };
#endif // _STRUCT_DEPLOYMENT_DEPLOYMENTPLAN_TRAITS_

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTPACKAGEREFERENCE_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTPACKAGEREFERENCE_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPackageReference_idl_t>
      : IDL::common_traits< ::Deployment::ComponentPackageReference>
    {
    };
#endif // _STRUCT_DEPLOYMENT_COMPONENTPACKAGEREFERENCE_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ComponentPackageReferences_idl_t>
      : IDL::unbounded_traits< ::Deployment::ComponentPackageReferences>,
        IDL::alias_traits< ::Deployment::ComponentPackageReferences_idl_t,
                           ::Deployment::ComponentPackageReferences>
    {
      typedef ::Deployment::ComponentPackageReference&   element_cdr_to;
      typedef const ::Deployment::ComponentPackageReference&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ComponentPackageReference_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ResourceUsageKinds_idl_t>
      : IDL::unbounded_traits< ::Deployment::ResourceUsageKinds>,
        IDL::alias_traits< ::Deployment::ResourceUsageKinds_idl_t,
                           ::Deployment::ResourceUsageKinds>
    {
      typedef ::Deployment::ResourceUsageKind&   element_cdr_to;
      typedef ::Deployment::ResourceUsageKind  element_cdr_from;

      typedef IDL::traits< ::Deployment::ResourceUsageKind_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT_TRAITS_)
#define _STRUCT_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT_TRAITS_
    template<>
    struct traits < ::Deployment::ImplementationRequirement_idl_t>
      : IDL::common_traits< ::Deployment::ImplementationRequirement>
    {
    };
#endif // _STRUCT_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::ImplementationRequirements_idl_t>
      : IDL::unbounded_traits< ::Deployment::ImplementationRequirements>,
        IDL::alias_traits< ::Deployment::ImplementationRequirements_idl_t,
                           ::Deployment::ImplementationRequirements>
    {
      typedef ::Deployment::ImplementationRequirement&   element_cdr_to;
      typedef const ::Deployment::ImplementationRequirement&  element_cdr_from;

      typedef IDL::traits< ::Deployment::ImplementationRequirement_idl_t>  element_traits;
    };

    // generated from c++/cli_hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_CAPABILITY_TRAITS_)
#define _STRUCT_DEPLOYMENT_CAPABILITY_TRAITS_
    template<>
    struct traits < ::Deployment::Capability_idl_t>
      : IDL::common_traits< ::Deployment::Capability>
    {
    };
#endif // _STRUCT_DEPLOYMENT_CAPABILITY_TRAITS_

    // generated from c++/cli_hdr/sequence_idl_traits.erb
    template<>
    struct traits < ::Deployment::Capabilities_idl_t>
      : IDL::unbounded_traits< ::Deployment::Capabilities>,
        IDL::alias_traits< ::Deployment::Capabilities_idl_t,
                           ::Deployment::Capabilities>
    {
      typedef ::Deployment::Capability&   element_cdr_to;
      typedef const ::Deployment::Capability&  element_cdr_from;

      typedef IDL::traits< ::Deployment::Capability_idl_t>  element_traits;
    };
  }; // IDL
}; // TAOX11_NAMESPACE

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::Property& m1, ::Deployment::Property& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::Requirement& m1, ::Deployment::Requirement& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::SatisfierProperty& m1, ::Deployment::SatisfierProperty& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPortDescription& m1, ::Deployment::ComponentPortDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPropertyDescription& m1, ::Deployment::ComponentPropertyDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentInterfaceDescription& m1, ::Deployment::ComponentInterfaceDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::MonolithicDeploymentDescription& m1, ::Deployment::MonolithicDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::InstanceResourceDeploymentDescription& m1, ::Deployment::InstanceResourceDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::InstanceDeploymentDescription& m1, ::Deployment::InstanceDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentExternalPortEndpoint& m1, ::Deployment::ComponentExternalPortEndpoint& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanSubcomponentPortEndpoint& m1, ::Deployment::PlanSubcomponentPortEndpoint& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ExternalReferenceEndpoint& m1, ::Deployment::ExternalReferenceEndpoint& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ConnectionResourceDeploymentDescription& m1, ::Deployment::ConnectionResourceDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanConnectionDescription& m1, ::Deployment::PlanConnectionDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanSubcomponentPropertyReference& m1, ::Deployment::PlanSubcomponentPropertyReference& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanPropertyMapping& m1, ::Deployment::PlanPropertyMapping& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ImplementationDependency& m1, ::Deployment::ImplementationDependency& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ResourceDeploymentDescription& m1, ::Deployment::ResourceDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ArtifactDeploymentDescription& m1, ::Deployment::ArtifactDeploymentDescription& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanLocality& m1, ::Deployment::PlanLocality& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::DeploymentPlan& m1, ::Deployment::DeploymentPlan& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPackageReference& m1, ::Deployment::ComponentPackageReference& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::ImplementationRequirement& m1, ::Deployment::ImplementationRequirement& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Deployment::Capability& m1, ::Deployment::Capability& m2);
}; // std

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::Property::Property ()
           : name_ (std::string())
           , value_ (TAOX11_NAMESPACE::CORBA::Any ())
{
}
inline Deployment::Property::Property (std::string name,
                                       TAOX11_NAMESPACE::CORBA::Any value)
           : name_ (std::move (name))
           , value_ (std::move (value))
{
}

inline void Deployment::Property::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::Property::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::Property::name (void) const { return this->name_; }
inline std::string& Deployment::Property::name (void) { return this->name_; }

inline void Deployment::Property::value (const TAOX11_NAMESPACE::CORBA::Any& _value) { this->value_ = _value; }
inline void Deployment::Property::value (TAOX11_NAMESPACE::CORBA::Any&& _value) { this->value_ = std::move (_value); }
inline const TAOX11_NAMESPACE::CORBA::Any& Deployment::Property::value (void) const { return this->value_; }
inline TAOX11_NAMESPACE::CORBA::Any& Deployment::Property::value (void) { return this->value_; }

inline ::Deployment::Property& Deployment::Property::operator= (const ::Deployment::Property& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->value_ = x.value_;
  }
  return *this;
}
inline ::Deployment::Property& Deployment::Property::operator= (::Deployment::Property&& x)
{
  this->name_ = std::move (x.name_);
  this->value_ = std::move (x.value_);
  return *this;
}

inline void Deployment::Property::swap (::Deployment::Property& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->value_, s.value_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::Requirement::Requirement ()
           : name_ (std::string())
           , resourceType_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::Requirement::Requirement (std::string name,
                                             std::string resourceType,
                                             ::Deployment::Properties property)
           : name_ (std::move (name))
           , resourceType_ (std::move (resourceType))
           , property_ (std::move (property))
{
}

inline void Deployment::Requirement::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::Requirement::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::Requirement::name (void) const { return this->name_; }
inline std::string& Deployment::Requirement::name (void) { return this->name_; }

inline void Deployment::Requirement::resourceType (const std::string& _resourceType) { this->resourceType_ = _resourceType; }
inline void Deployment::Requirement::resourceType (std::string&& _resourceType) { this->resourceType_ = std::move (_resourceType); }
inline const std::string& Deployment::Requirement::resourceType (void) const { return this->resourceType_; }
inline std::string& Deployment::Requirement::resourceType (void) { return this->resourceType_; }

inline void Deployment::Requirement::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::Requirement::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::Requirement::property (void) const { return this->property_; }
inline ::Deployment::Properties& Deployment::Requirement::property (void) { return this->property_; }

inline ::Deployment::Requirement& Deployment::Requirement::operator= (const ::Deployment::Requirement& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->resourceType_ = x.resourceType_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::Requirement& Deployment::Requirement::operator= (::Deployment::Requirement&& x)
{
  this->name_ = std::move (x.name_);
  this->resourceType_ = std::move (x.resourceType_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::Requirement::swap (::Deployment::Requirement& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::SatisfierProperty::SatisfierProperty ()
           : name_ (std::string())
           , kind_ (::Deployment::SatisfierPropertyKind::Quantity)
           , dynamic_ (false)
           , value_ (TAOX11_NAMESPACE::CORBA::Any ())
{
}
inline Deployment::SatisfierProperty::SatisfierProperty (std::string name,
                                                         ::Deployment::SatisfierPropertyKind kind,
                                                         bool dynamic,
                                                         TAOX11_NAMESPACE::CORBA::Any value)
           : name_ (std::move (name))
           , kind_ (std::move (kind))
           , dynamic_ (std::move (dynamic))
           , value_ (std::move (value))
{
}

inline void Deployment::SatisfierProperty::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::SatisfierProperty::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::SatisfierProperty::name (void) const { return this->name_; }
inline std::string& Deployment::SatisfierProperty::name (void) { return this->name_; }

inline void Deployment::SatisfierProperty::kind (::Deployment::SatisfierPropertyKind _kind) { this->kind_ = _kind; }
inline ::Deployment::SatisfierPropertyKind Deployment::SatisfierProperty::kind (void) const { return this->kind_; }
inline ::Deployment::SatisfierPropertyKind& Deployment::SatisfierProperty::kind (void) { return this->kind_; }

inline void Deployment::SatisfierProperty::dynamic (bool _dynamic) { this->dynamic_ = _dynamic; }
inline bool Deployment::SatisfierProperty::dynamic (void) const { return this->dynamic_; }
inline bool& Deployment::SatisfierProperty::dynamic (void) { return this->dynamic_; }

inline void Deployment::SatisfierProperty::value (const TAOX11_NAMESPACE::CORBA::Any& _value) { this->value_ = _value; }
inline void Deployment::SatisfierProperty::value (TAOX11_NAMESPACE::CORBA::Any&& _value) { this->value_ = std::move (_value); }
inline const TAOX11_NAMESPACE::CORBA::Any& Deployment::SatisfierProperty::value (void) const { return this->value_; }
inline TAOX11_NAMESPACE::CORBA::Any& Deployment::SatisfierProperty::value (void) { return this->value_; }

inline ::Deployment::SatisfierProperty& Deployment::SatisfierProperty::operator= (const ::Deployment::SatisfierProperty& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->kind_ = x.kind_;
    this->dynamic_ = x.dynamic_;
    this->value_ = x.value_;
  }
  return *this;
}
inline ::Deployment::SatisfierProperty& Deployment::SatisfierProperty::operator= (::Deployment::SatisfierProperty&& x)
{
  this->name_ = std::move (x.name_);
  this->kind_ = std::move (x.kind_);
  this->dynamic_ = std::move (x.dynamic_);
  this->value_ = std::move (x.value_);
  return *this;
}

inline void Deployment::SatisfierProperty::swap (::Deployment::SatisfierProperty& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->dynamic_, s.dynamic_);
  std::swap (this->value_, s.value_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ComponentPortDescription::ComponentPortDescription ()
           : name_ (std::string())
           , specificType_ (std::string())
           , supportedType_ (std::vector < std::string> ())
           , provider_ (false)
           , exclusiveProvider_ (false)
           , exclusiveUser_ (false)
           , optional_ (false)
           , kind_ (::Deployment::CCMComponentPortKind::Facet)
           , templateParam_ (std::vector < std::string> ())
{
}
inline Deployment::ComponentPortDescription::ComponentPortDescription (std::string name,
                                                                       std::string specificType,
                                                                       ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                                                       bool provider,
                                                                       bool exclusiveProvider,
                                                                       bool exclusiveUser,
                                                                       bool optional,
                                                                       CCMComponentPortKind kind,
                                                                       ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam)
           : name_ (std::move (name))
           , specificType_ (std::move (specificType))
           , supportedType_ (std::move (supportedType))
           , provider_ (std::move (provider))
           , exclusiveProvider_ (std::move (exclusiveProvider))
           , exclusiveUser_ (std::move (exclusiveUser))
           , optional_ (std::move (optional))
           , kind_ (std::move (kind))
           , templateParam_ (std::move (templateParam))
{
}

inline void Deployment::ComponentPortDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ComponentPortDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ComponentPortDescription::name (void) const { return this->name_; }
inline std::string& Deployment::ComponentPortDescription::name (void) { return this->name_; }

inline void Deployment::ComponentPortDescription::specificType (const std::string& _specificType) { this->specificType_ = _specificType; }
inline void Deployment::ComponentPortDescription::specificType (std::string&& _specificType) { this->specificType_ = std::move (_specificType); }
inline const std::string& Deployment::ComponentPortDescription::specificType (void) const { return this->specificType_; }
inline std::string& Deployment::ComponentPortDescription::specificType (void) { return this->specificType_; }

inline void Deployment::ComponentPortDescription::supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType) { this->supportedType_ = _supportedType; }
inline void Deployment::ComponentPortDescription::supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType) { this->supportedType_ = std::move (_supportedType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::supportedType (void) const { return this->supportedType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::supportedType (void) { return this->supportedType_; }

inline void Deployment::ComponentPortDescription::provider (bool _provider) { this->provider_ = _provider; }
inline bool Deployment::ComponentPortDescription::provider (void) const { return this->provider_; }
inline bool& Deployment::ComponentPortDescription::provider (void) { return this->provider_; }

inline void Deployment::ComponentPortDescription::exclusiveProvider (bool _exclusiveProvider) { this->exclusiveProvider_ = _exclusiveProvider; }
inline bool Deployment::ComponentPortDescription::exclusiveProvider (void) const { return this->exclusiveProvider_; }
inline bool& Deployment::ComponentPortDescription::exclusiveProvider (void) { return this->exclusiveProvider_; }

inline void Deployment::ComponentPortDescription::exclusiveUser (bool _exclusiveUser) { this->exclusiveUser_ = _exclusiveUser; }
inline bool Deployment::ComponentPortDescription::exclusiveUser (void) const { return this->exclusiveUser_; }
inline bool& Deployment::ComponentPortDescription::exclusiveUser (void) { return this->exclusiveUser_; }

inline void Deployment::ComponentPortDescription::optional (bool _optional) { this->optional_ = _optional; }
inline bool Deployment::ComponentPortDescription::optional (void) const { return this->optional_; }
inline bool& Deployment::ComponentPortDescription::optional (void) { return this->optional_; }

inline void Deployment::ComponentPortDescription::kind (CCMComponentPortKind _kind) { this->kind_ = _kind; }
inline ::Deployment::CCMComponentPortKind Deployment::ComponentPortDescription::kind (void) const { return this->kind_; }
inline ::Deployment::CCMComponentPortKind& Deployment::ComponentPortDescription::kind (void) { return this->kind_; }

inline void Deployment::ComponentPortDescription::templateParam (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _templateParam) { this->templateParam_ = _templateParam; }
inline void Deployment::ComponentPortDescription::templateParam (::TAOX11_NAMESPACE::CORBA::StringSeq&& _templateParam) { this->templateParam_ = std::move (_templateParam); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::templateParam (void) const { return this->templateParam_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::templateParam (void) { return this->templateParam_; }

inline ::Deployment::ComponentPortDescription& Deployment::ComponentPortDescription::operator= (const ::Deployment::ComponentPortDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->specificType_ = x.specificType_;
    this->supportedType_ = x.supportedType_;
    this->provider_ = x.provider_;
    this->exclusiveProvider_ = x.exclusiveProvider_;
    this->exclusiveUser_ = x.exclusiveUser_;
    this->optional_ = x.optional_;
    this->kind_ = x.kind_;
    this->templateParam_ = x.templateParam_;
  }
  return *this;
}
inline ::Deployment::ComponentPortDescription& Deployment::ComponentPortDescription::operator= (::Deployment::ComponentPortDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->specificType_ = std::move (x.specificType_);
  this->supportedType_ = std::move (x.supportedType_);
  this->provider_ = std::move (x.provider_);
  this->exclusiveProvider_ = std::move (x.exclusiveProvider_);
  this->exclusiveUser_ = std::move (x.exclusiveUser_);
  this->optional_ = std::move (x.optional_);
  this->kind_ = std::move (x.kind_);
  this->templateParam_ = std::move (x.templateParam_);
  return *this;
}

inline void Deployment::ComponentPortDescription::swap (::Deployment::ComponentPortDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->specificType_, s.specificType_);
  std::swap (this->supportedType_, s.supportedType_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->exclusiveProvider_, s.exclusiveProvider_);
  std::swap (this->exclusiveUser_, s.exclusiveUser_);
  std::swap (this->optional_, s.optional_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->templateParam_, s.templateParam_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ComponentPropertyDescription::ComponentPropertyDescription ()
           : name_ (std::string())
           , type_ (nullptr)
{
}
inline Deployment::ComponentPropertyDescription::ComponentPropertyDescription (std::string name,
                                                                               TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> type)
           : name_ (std::move (name))
           , type_ (std::move (type))
{
}

inline void Deployment::ComponentPropertyDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ComponentPropertyDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ComponentPropertyDescription::name (void) const { return this->name_; }
inline std::string& Deployment::ComponentPropertyDescription::name (void) { return this->name_; }

inline void Deployment::ComponentPropertyDescription::type (TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> _type) { this->type_ = _type; }
inline TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode> Deployment::ComponentPropertyDescription::type (void) const { return this->type_; }
inline TAOX11_CORBA::object_reference< ::TAOX11_NAMESPACE::CORBA::TypeCode>& Deployment::ComponentPropertyDescription::type (void) { return this->type_; }

inline ::Deployment::ComponentPropertyDescription& Deployment::ComponentPropertyDescription::operator= (const ::Deployment::ComponentPropertyDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->type_ = x.type_;
  }
  return *this;
}
inline ::Deployment::ComponentPropertyDescription& Deployment::ComponentPropertyDescription::operator= (::Deployment::ComponentPropertyDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->type_ = std::move (x.type_);
  return *this;
}

inline void Deployment::ComponentPropertyDescription::swap (::Deployment::ComponentPropertyDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->type_, s.type_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ComponentInterfaceDescription::ComponentInterfaceDescription ()
           : label_ (std::string())
           , UUID_ (std::string())
           , specificType_ (std::string())
           , supportedType_ (std::vector < std::string> ())
           , idlFile_ (std::vector < std::string> ())
           , configProperty_ (std::vector < ::Deployment::Property> ())
           , port_ (std::vector < ::Deployment::ComponentPortDescription> ())
           , property_ (std::vector < ::Deployment::ComponentPropertyDescription> ())
           , infoProperty_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::ComponentInterfaceDescription::ComponentInterfaceDescription (std::string label,
                                                                                 std::string UUID,
                                                                                 std::string specificType,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile,
                                                                                 ::Deployment::Properties configProperty,
                                                                                 ::Deployment::ComponentPortDescriptions port,
                                                                                 ::Deployment::ComponentPropertyDescriptions property,
                                                                                 ::Deployment::Properties infoProperty)
           : label_ (std::move (label))
           , UUID_ (std::move (UUID))
           , specificType_ (std::move (specificType))
           , supportedType_ (std::move (supportedType))
           , idlFile_ (std::move (idlFile))
           , configProperty_ (std::move (configProperty))
           , port_ (std::move (port))
           , property_ (std::move (property))
           , infoProperty_ (std::move (infoProperty))
{
}

inline void Deployment::ComponentInterfaceDescription::label (const std::string& _label) { this->label_ = _label; }
inline void Deployment::ComponentInterfaceDescription::label (std::string&& _label) { this->label_ = std::move (_label); }
inline const std::string& Deployment::ComponentInterfaceDescription::label (void) const { return this->label_; }
inline std::string& Deployment::ComponentInterfaceDescription::label (void) { return this->label_; }

inline void Deployment::ComponentInterfaceDescription::UUID (const std::string& _UUID) { this->UUID_ = _UUID; }
inline void Deployment::ComponentInterfaceDescription::UUID (std::string&& _UUID) { this->UUID_ = std::move (_UUID); }
inline const std::string& Deployment::ComponentInterfaceDescription::UUID (void) const { return this->UUID_; }
inline std::string& Deployment::ComponentInterfaceDescription::UUID (void) { return this->UUID_; }

inline void Deployment::ComponentInterfaceDescription::specificType (const std::string& _specificType) { this->specificType_ = _specificType; }
inline void Deployment::ComponentInterfaceDescription::specificType (std::string&& _specificType) { this->specificType_ = std::move (_specificType); }
inline const std::string& Deployment::ComponentInterfaceDescription::specificType (void) const { return this->specificType_; }
inline std::string& Deployment::ComponentInterfaceDescription::specificType (void) { return this->specificType_; }

inline void Deployment::ComponentInterfaceDescription::supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType) { this->supportedType_ = _supportedType; }
inline void Deployment::ComponentInterfaceDescription::supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType) { this->supportedType_ = std::move (_supportedType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::supportedType (void) const { return this->supportedType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::supportedType (void) { return this->supportedType_; }

inline void Deployment::ComponentInterfaceDescription::idlFile (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _idlFile) { this->idlFile_ = _idlFile; }
inline void Deployment::ComponentInterfaceDescription::idlFile (::TAOX11_NAMESPACE::CORBA::StringSeq&& _idlFile) { this->idlFile_ = std::move (_idlFile); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::idlFile (void) const { return this->idlFile_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::idlFile (void) { return this->idlFile_; }

inline void Deployment::ComponentInterfaceDescription::configProperty (const ::Deployment::Properties& _configProperty) { this->configProperty_ = _configProperty; }
inline void Deployment::ComponentInterfaceDescription::configProperty (::Deployment::Properties&& _configProperty) { this->configProperty_ = std::move (_configProperty); }
inline const ::Deployment::Properties& Deployment::ComponentInterfaceDescription::configProperty (void) const { return this->configProperty_; }
inline ::Deployment::Properties& Deployment::ComponentInterfaceDescription::configProperty (void) { return this->configProperty_; }

inline void Deployment::ComponentInterfaceDescription::port (const ::Deployment::ComponentPortDescriptions& _port) { this->port_ = _port; }
inline void Deployment::ComponentInterfaceDescription::port (::Deployment::ComponentPortDescriptions&& _port) { this->port_ = std::move (_port); }
inline const ::Deployment::ComponentPortDescriptions& Deployment::ComponentInterfaceDescription::port (void) const { return this->port_; }
inline ::Deployment::ComponentPortDescriptions& Deployment::ComponentInterfaceDescription::port (void) { return this->port_; }

inline void Deployment::ComponentInterfaceDescription::property (const ::Deployment::ComponentPropertyDescriptions& _property) { this->property_ = _property; }
inline void Deployment::ComponentInterfaceDescription::property (::Deployment::ComponentPropertyDescriptions&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::ComponentPropertyDescriptions& Deployment::ComponentInterfaceDescription::property (void) const { return this->property_; }
inline ::Deployment::ComponentPropertyDescriptions& Deployment::ComponentInterfaceDescription::property (void) { return this->property_; }

inline void Deployment::ComponentInterfaceDescription::infoProperty (const ::Deployment::Properties& _infoProperty) { this->infoProperty_ = _infoProperty; }
inline void Deployment::ComponentInterfaceDescription::infoProperty (::Deployment::Properties&& _infoProperty) { this->infoProperty_ = std::move (_infoProperty); }
inline const ::Deployment::Properties& Deployment::ComponentInterfaceDescription::infoProperty (void) const { return this->infoProperty_; }
inline ::Deployment::Properties& Deployment::ComponentInterfaceDescription::infoProperty (void) { return this->infoProperty_; }

inline ::Deployment::ComponentInterfaceDescription& Deployment::ComponentInterfaceDescription::operator= (const ::Deployment::ComponentInterfaceDescription& x)
{
  if (this != &x) {
    this->label_ = x.label_;
    this->UUID_ = x.UUID_;
    this->specificType_ = x.specificType_;
    this->supportedType_ = x.supportedType_;
    this->idlFile_ = x.idlFile_;
    this->configProperty_ = x.configProperty_;
    this->port_ = x.port_;
    this->property_ = x.property_;
    this->infoProperty_ = x.infoProperty_;
  }
  return *this;
}
inline ::Deployment::ComponentInterfaceDescription& Deployment::ComponentInterfaceDescription::operator= (::Deployment::ComponentInterfaceDescription&& x)
{
  this->label_ = std::move (x.label_);
  this->UUID_ = std::move (x.UUID_);
  this->specificType_ = std::move (x.specificType_);
  this->supportedType_ = std::move (x.supportedType_);
  this->idlFile_ = std::move (x.idlFile_);
  this->configProperty_ = std::move (x.configProperty_);
  this->port_ = std::move (x.port_);
  this->property_ = std::move (x.property_);
  this->infoProperty_ = std::move (x.infoProperty_);
  return *this;
}

inline void Deployment::ComponentInterfaceDescription::swap (::Deployment::ComponentInterfaceDescription& s)
{
  std::swap (this->label_, s.label_);
  std::swap (this->UUID_, s.UUID_);
  std::swap (this->specificType_, s.specificType_);
  std::swap (this->supportedType_, s.supportedType_);
  std::swap (this->idlFile_, s.idlFile_);
  std::swap (this->configProperty_, s.configProperty_);
  std::swap (this->port_, s.port_);
  std::swap (this->property_, s.property_);
  std::swap (this->infoProperty_, s.infoProperty_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::MonolithicDeploymentDescription::MonolithicDeploymentDescription ()
           : name_ (std::string())
           , source_ (std::vector < std::string> ())
           , artifactRef_ (std::vector < uint32_t> ())
           , execParameter_ (std::vector < ::Deployment::Property> ())
           , deployRequirement_ (std::vector < ::Deployment::Requirement> ())
{
}
inline Deployment::MonolithicDeploymentDescription::MonolithicDeploymentDescription (std::string name,
                                                                                     ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                                                     ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef,
                                                                                     ::Deployment::Properties execParameter,
                                                                                     ::Deployment::Requirements deployRequirement)
           : name_ (std::move (name))
           , source_ (std::move (source))
           , artifactRef_ (std::move (artifactRef))
           , execParameter_ (std::move (execParameter))
           , deployRequirement_ (std::move (deployRequirement))
{
}

inline void Deployment::MonolithicDeploymentDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::MonolithicDeploymentDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::MonolithicDeploymentDescription::name (void) const { return this->name_; }
inline std::string& Deployment::MonolithicDeploymentDescription::name (void) { return this->name_; }

inline void Deployment::MonolithicDeploymentDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::MonolithicDeploymentDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::MonolithicDeploymentDescription::source (void) const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::MonolithicDeploymentDescription::source (void) { return this->source_; }

inline void Deployment::MonolithicDeploymentDescription::artifactRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _artifactRef) { this->artifactRef_ = _artifactRef; }
inline void Deployment::MonolithicDeploymentDescription::artifactRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _artifactRef) { this->artifactRef_ = std::move (_artifactRef); }
inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::MonolithicDeploymentDescription::artifactRef (void) const { return this->artifactRef_; }
inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::MonolithicDeploymentDescription::artifactRef (void) { return this->artifactRef_; }

inline void Deployment::MonolithicDeploymentDescription::execParameter (const ::Deployment::Properties& _execParameter) { this->execParameter_ = _execParameter; }
inline void Deployment::MonolithicDeploymentDescription::execParameter (::Deployment::Properties&& _execParameter) { this->execParameter_ = std::move (_execParameter); }
inline const ::Deployment::Properties& Deployment::MonolithicDeploymentDescription::execParameter (void) const { return this->execParameter_; }
inline ::Deployment::Properties& Deployment::MonolithicDeploymentDescription::execParameter (void) { return this->execParameter_; }

inline void Deployment::MonolithicDeploymentDescription::deployRequirement (const ::Deployment::Requirements& _deployRequirement) { this->deployRequirement_ = _deployRequirement; }
inline void Deployment::MonolithicDeploymentDescription::deployRequirement (::Deployment::Requirements&& _deployRequirement) { this->deployRequirement_ = std::move (_deployRequirement); }
inline const ::Deployment::Requirements& Deployment::MonolithicDeploymentDescription::deployRequirement (void) const { return this->deployRequirement_; }
inline ::Deployment::Requirements& Deployment::MonolithicDeploymentDescription::deployRequirement (void) { return this->deployRequirement_; }

inline ::Deployment::MonolithicDeploymentDescription& Deployment::MonolithicDeploymentDescription::operator= (const ::Deployment::MonolithicDeploymentDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->source_ = x.source_;
    this->artifactRef_ = x.artifactRef_;
    this->execParameter_ = x.execParameter_;
    this->deployRequirement_ = x.deployRequirement_;
  }
  return *this;
}
inline ::Deployment::MonolithicDeploymentDescription& Deployment::MonolithicDeploymentDescription::operator= (::Deployment::MonolithicDeploymentDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->source_ = std::move (x.source_);
  this->artifactRef_ = std::move (x.artifactRef_);
  this->execParameter_ = std::move (x.execParameter_);
  this->deployRequirement_ = std::move (x.deployRequirement_);
  return *this;
}

inline void Deployment::MonolithicDeploymentDescription::swap (::Deployment::MonolithicDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->artifactRef_, s.artifactRef_);
  std::swap (this->execParameter_, s.execParameter_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription ()
           : resourceUsage_ (::Deployment::ResourceUsageKind::None)
           , requirementName_ (std::string())
           , resourceName_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription (::Deployment::ResourceUsageKind resourceUsage,
                                                                                                 std::string requirementName,
                                                                                                 std::string resourceName,
                                                                                                 ::Deployment::Properties property)
           : resourceUsage_ (std::move (resourceUsage))
           , requirementName_ (std::move (requirementName))
           , resourceName_ (std::move (resourceName))
           , property_ (std::move (property))
{
}

inline void Deployment::InstanceResourceDeploymentDescription::resourceUsage (::Deployment::ResourceUsageKind _resourceUsage) { this->resourceUsage_ = _resourceUsage; }
inline ::Deployment::ResourceUsageKind Deployment::InstanceResourceDeploymentDescription::resourceUsage (void) const { return this->resourceUsage_; }
inline ::Deployment::ResourceUsageKind& Deployment::InstanceResourceDeploymentDescription::resourceUsage (void) { return this->resourceUsage_; }

inline void Deployment::InstanceResourceDeploymentDescription::requirementName (const std::string& _requirementName) { this->requirementName_ = _requirementName; }
inline void Deployment::InstanceResourceDeploymentDescription::requirementName (std::string&& _requirementName) { this->requirementName_ = std::move (_requirementName); }
inline const std::string& Deployment::InstanceResourceDeploymentDescription::requirementName (void) const { return this->requirementName_; }
inline std::string& Deployment::InstanceResourceDeploymentDescription::requirementName (void) { return this->requirementName_; }

inline void Deployment::InstanceResourceDeploymentDescription::resourceName (const std::string& _resourceName) { this->resourceName_ = _resourceName; }
inline void Deployment::InstanceResourceDeploymentDescription::resourceName (std::string&& _resourceName) { this->resourceName_ = std::move (_resourceName); }
inline const std::string& Deployment::InstanceResourceDeploymentDescription::resourceName (void) const { return this->resourceName_; }
inline std::string& Deployment::InstanceResourceDeploymentDescription::resourceName (void) { return this->resourceName_; }

inline void Deployment::InstanceResourceDeploymentDescription::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::InstanceResourceDeploymentDescription::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::InstanceResourceDeploymentDescription::property (void) const { return this->property_; }
inline ::Deployment::Properties& Deployment::InstanceResourceDeploymentDescription::property (void) { return this->property_; }

inline ::Deployment::InstanceResourceDeploymentDescription& Deployment::InstanceResourceDeploymentDescription::operator= (const ::Deployment::InstanceResourceDeploymentDescription& x)
{
  if (this != &x) {
    this->resourceUsage_ = x.resourceUsage_;
    this->requirementName_ = x.requirementName_;
    this->resourceName_ = x.resourceName_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::InstanceResourceDeploymentDescription& Deployment::InstanceResourceDeploymentDescription::operator= (::Deployment::InstanceResourceDeploymentDescription&& x)
{
  this->resourceUsage_ = std::move (x.resourceUsage_);
  this->requirementName_ = std::move (x.requirementName_);
  this->resourceName_ = std::move (x.resourceName_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::InstanceResourceDeploymentDescription::swap (::Deployment::InstanceResourceDeploymentDescription& s)
{
  std::swap (this->resourceUsage_, s.resourceUsage_);
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::InstanceDeploymentDescription::InstanceDeploymentDescription ()
           : name_ (std::string())
           , node_ (std::string())
           , source_ (std::vector < std::string> ())
           , implementationRef_ (0)
           , configProperty_ (std::vector < ::Deployment::Property> ())
           , deployedResource_ (std::vector < ::Deployment::InstanceResourceDeploymentDescription> ())
           , deployedSharedResource_ (std::vector < ::Deployment::InstanceResourceDeploymentDescription> ())
{
}
inline Deployment::InstanceDeploymentDescription::InstanceDeploymentDescription (std::string name,
                                                                                 std::string node,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                                                 uint32_t implementationRef,
                                                                                 ::Deployment::Properties configProperty,
                                                                                 ::Deployment::InstanceResourceDeploymentDescriptions deployedResource,
                                                                                 ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource)
           : name_ (std::move (name))
           , node_ (std::move (node))
           , source_ (std::move (source))
           , implementationRef_ (std::move (implementationRef))
           , configProperty_ (std::move (configProperty))
           , deployedResource_ (std::move (deployedResource))
           , deployedSharedResource_ (std::move (deployedSharedResource))
{
}

inline void Deployment::InstanceDeploymentDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::InstanceDeploymentDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::InstanceDeploymentDescription::name (void) const { return this->name_; }
inline std::string& Deployment::InstanceDeploymentDescription::name (void) { return this->name_; }

inline void Deployment::InstanceDeploymentDescription::node (const std::string& _node) { this->node_ = _node; }
inline void Deployment::InstanceDeploymentDescription::node (std::string&& _node) { this->node_ = std::move (_node); }
inline const std::string& Deployment::InstanceDeploymentDescription::node (void) const { return this->node_; }
inline std::string& Deployment::InstanceDeploymentDescription::node (void) { return this->node_; }

inline void Deployment::InstanceDeploymentDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::InstanceDeploymentDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::InstanceDeploymentDescription::source (void) const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::InstanceDeploymentDescription::source (void) { return this->source_; }

inline void Deployment::InstanceDeploymentDescription::implementationRef (uint32_t _implementationRef) { this->implementationRef_ = _implementationRef; }
inline uint32_t Deployment::InstanceDeploymentDescription::implementationRef (void) const { return this->implementationRef_; }
inline uint32_t& Deployment::InstanceDeploymentDescription::implementationRef (void) { return this->implementationRef_; }

inline void Deployment::InstanceDeploymentDescription::configProperty (const ::Deployment::Properties& _configProperty) { this->configProperty_ = _configProperty; }
inline void Deployment::InstanceDeploymentDescription::configProperty (::Deployment::Properties&& _configProperty) { this->configProperty_ = std::move (_configProperty); }
inline const ::Deployment::Properties& Deployment::InstanceDeploymentDescription::configProperty (void) const { return this->configProperty_; }
inline ::Deployment::Properties& Deployment::InstanceDeploymentDescription::configProperty (void) { return this->configProperty_; }

inline void Deployment::InstanceDeploymentDescription::deployedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedResource) { this->deployedResource_ = _deployedResource; }
inline void Deployment::InstanceDeploymentDescription::deployedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedResource) { this->deployedResource_ = std::move (_deployedResource); }
inline const ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedResource (void) const { return this->deployedResource_; }
inline ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedResource (void) { return this->deployedResource_; }

inline void Deployment::InstanceDeploymentDescription::deployedSharedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedSharedResource) { this->deployedSharedResource_ = _deployedSharedResource; }
inline void Deployment::InstanceDeploymentDescription::deployedSharedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedSharedResource) { this->deployedSharedResource_ = std::move (_deployedSharedResource); }
inline const ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedSharedResource (void) const { return this->deployedSharedResource_; }
inline ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedSharedResource (void) { return this->deployedSharedResource_; }

inline ::Deployment::InstanceDeploymentDescription& Deployment::InstanceDeploymentDescription::operator= (const ::Deployment::InstanceDeploymentDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->node_ = x.node_;
    this->source_ = x.source_;
    this->implementationRef_ = x.implementationRef_;
    this->configProperty_ = x.configProperty_;
    this->deployedResource_ = x.deployedResource_;
    this->deployedSharedResource_ = x.deployedSharedResource_;
  }
  return *this;
}
inline ::Deployment::InstanceDeploymentDescription& Deployment::InstanceDeploymentDescription::operator= (::Deployment::InstanceDeploymentDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->node_ = std::move (x.node_);
  this->source_ = std::move (x.source_);
  this->implementationRef_ = std::move (x.implementationRef_);
  this->configProperty_ = std::move (x.configProperty_);
  this->deployedResource_ = std::move (x.deployedResource_);
  this->deployedSharedResource_ = std::move (x.deployedSharedResource_);
  return *this;
}

inline void Deployment::InstanceDeploymentDescription::swap (::Deployment::InstanceDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->node_, s.node_);
  std::swap (this->source_, s.source_);
  std::swap (this->implementationRef_, s.implementationRef_);
  std::swap (this->configProperty_, s.configProperty_);
  std::swap (this->deployedResource_, s.deployedResource_);
  std::swap (this->deployedSharedResource_, s.deployedSharedResource_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ComponentExternalPortEndpoint::ComponentExternalPortEndpoint ()
           : portName_ (std::string())
{
}
inline Deployment::ComponentExternalPortEndpoint::ComponentExternalPortEndpoint (std::string portName)
           : portName_ (std::move (portName))
{
}

inline void Deployment::ComponentExternalPortEndpoint::portName (const std::string& _portName) { this->portName_ = _portName; }
inline void Deployment::ComponentExternalPortEndpoint::portName (std::string&& _portName) { this->portName_ = std::move (_portName); }
inline const std::string& Deployment::ComponentExternalPortEndpoint::portName (void) const { return this->portName_; }
inline std::string& Deployment::ComponentExternalPortEndpoint::portName (void) { return this->portName_; }

inline ::Deployment::ComponentExternalPortEndpoint& Deployment::ComponentExternalPortEndpoint::operator= (const ::Deployment::ComponentExternalPortEndpoint& x)
{
  if (this != &x) {
    this->portName_ = x.portName_;
  }
  return *this;
}
inline ::Deployment::ComponentExternalPortEndpoint& Deployment::ComponentExternalPortEndpoint::operator= (::Deployment::ComponentExternalPortEndpoint&& x)
{
  this->portName_ = std::move (x.portName_);
  return *this;
}

inline void Deployment::ComponentExternalPortEndpoint::swap (::Deployment::ComponentExternalPortEndpoint& s)
{
  std::swap (this->portName_, s.portName_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint ()
           : portName_ (std::string())
           , provider_ (false)
           , kind_ (::Deployment::CCMComponentPortKind::Facet)
           , instanceRef_ (0)
{
}
inline Deployment::PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint (std::string portName,
                                                                               bool provider,
                                                                               ::Deployment::CCMComponentPortKind kind,
                                                                               uint32_t instanceRef)
           : portName_ (std::move (portName))
           , provider_ (std::move (provider))
           , kind_ (std::move (kind))
           , instanceRef_ (std::move (instanceRef))
{
}

inline void Deployment::PlanSubcomponentPortEndpoint::portName (const std::string& _portName) { this->portName_ = _portName; }
inline void Deployment::PlanSubcomponentPortEndpoint::portName (std::string&& _portName) { this->portName_ = std::move (_portName); }
inline const std::string& Deployment::PlanSubcomponentPortEndpoint::portName (void) const { return this->portName_; }
inline std::string& Deployment::PlanSubcomponentPortEndpoint::portName (void) { return this->portName_; }

inline void Deployment::PlanSubcomponentPortEndpoint::provider (bool _provider) { this->provider_ = _provider; }
inline bool Deployment::PlanSubcomponentPortEndpoint::provider (void) const { return this->provider_; }
inline bool& Deployment::PlanSubcomponentPortEndpoint::provider (void) { return this->provider_; }

inline void Deployment::PlanSubcomponentPortEndpoint::kind (::Deployment::CCMComponentPortKind _kind) { this->kind_ = _kind; }
inline ::Deployment::CCMComponentPortKind Deployment::PlanSubcomponentPortEndpoint::kind (void) const { return this->kind_; }
inline ::Deployment::CCMComponentPortKind& Deployment::PlanSubcomponentPortEndpoint::kind (void) { return this->kind_; }

inline void Deployment::PlanSubcomponentPortEndpoint::instanceRef (uint32_t _instanceRef) { this->instanceRef_ = _instanceRef; }
inline uint32_t Deployment::PlanSubcomponentPortEndpoint::instanceRef (void) const { return this->instanceRef_; }
inline uint32_t& Deployment::PlanSubcomponentPortEndpoint::instanceRef (void) { return this->instanceRef_; }

inline ::Deployment::PlanSubcomponentPortEndpoint& Deployment::PlanSubcomponentPortEndpoint::operator= (const ::Deployment::PlanSubcomponentPortEndpoint& x)
{
  if (this != &x) {
    this->portName_ = x.portName_;
    this->provider_ = x.provider_;
    this->kind_ = x.kind_;
    this->instanceRef_ = x.instanceRef_;
  }
  return *this;
}
inline ::Deployment::PlanSubcomponentPortEndpoint& Deployment::PlanSubcomponentPortEndpoint::operator= (::Deployment::PlanSubcomponentPortEndpoint&& x)
{
  this->portName_ = std::move (x.portName_);
  this->provider_ = std::move (x.provider_);
  this->kind_ = std::move (x.kind_);
  this->instanceRef_ = std::move (x.instanceRef_);
  return *this;
}

inline void Deployment::PlanSubcomponentPortEndpoint::swap (::Deployment::PlanSubcomponentPortEndpoint& s)
{
  std::swap (this->portName_, s.portName_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->instanceRef_, s.instanceRef_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ExternalReferenceEndpoint::ExternalReferenceEndpoint ()
           : location_ (std::string())
           , provider_ (false)
           , portName_ (std::string())
           , supportedType_ (std::vector < std::string> ())
{
}
inline Deployment::ExternalReferenceEndpoint::ExternalReferenceEndpoint (std::string location,
                                                                         bool provider,
                                                                         std::string portName,
                                                                         ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType)
           : location_ (std::move (location))
           , provider_ (std::move (provider))
           , portName_ (std::move (portName))
           , supportedType_ (std::move (supportedType))
{
}

inline void Deployment::ExternalReferenceEndpoint::location (const std::string& _location) { this->location_ = _location; }
inline void Deployment::ExternalReferenceEndpoint::location (std::string&& _location) { this->location_ = std::move (_location); }
inline const std::string& Deployment::ExternalReferenceEndpoint::location (void) const { return this->location_; }
inline std::string& Deployment::ExternalReferenceEndpoint::location (void) { return this->location_; }

inline void Deployment::ExternalReferenceEndpoint::provider (bool _provider) { this->provider_ = _provider; }
inline bool Deployment::ExternalReferenceEndpoint::provider (void) const { return this->provider_; }
inline bool& Deployment::ExternalReferenceEndpoint::provider (void) { return this->provider_; }

inline void Deployment::ExternalReferenceEndpoint::portName (const std::string& _portName) { this->portName_ = _portName; }
inline void Deployment::ExternalReferenceEndpoint::portName (std::string&& _portName) { this->portName_ = std::move (_portName); }
inline const std::string& Deployment::ExternalReferenceEndpoint::portName (void) const { return this->portName_; }
inline std::string& Deployment::ExternalReferenceEndpoint::portName (void) { return this->portName_; }

inline void Deployment::ExternalReferenceEndpoint::supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType) { this->supportedType_ = _supportedType; }
inline void Deployment::ExternalReferenceEndpoint::supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType) { this->supportedType_ = std::move (_supportedType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ExternalReferenceEndpoint::supportedType (void) const { return this->supportedType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ExternalReferenceEndpoint::supportedType (void) { return this->supportedType_; }

inline ::Deployment::ExternalReferenceEndpoint& Deployment::ExternalReferenceEndpoint::operator= (const ::Deployment::ExternalReferenceEndpoint& x)
{
  if (this != &x) {
    this->location_ = x.location_;
    this->provider_ = x.provider_;
    this->portName_ = x.portName_;
    this->supportedType_ = x.supportedType_;
  }
  return *this;
}
inline ::Deployment::ExternalReferenceEndpoint& Deployment::ExternalReferenceEndpoint::operator= (::Deployment::ExternalReferenceEndpoint&& x)
{
  this->location_ = std::move (x.location_);
  this->provider_ = std::move (x.provider_);
  this->portName_ = std::move (x.portName_);
  this->supportedType_ = std::move (x.supportedType_);
  return *this;
}

inline void Deployment::ExternalReferenceEndpoint::swap (::Deployment::ExternalReferenceEndpoint& s)
{
  std::swap (this->location_, s.location_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->portName_, s.portName_);
  std::swap (this->supportedType_, s.supportedType_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription ()
           : targetName_ (std::string())
           , requirementName_ (std::string())
           , resourceName_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription (std::string targetName,
                                                                                                     std::string requirementName,
                                                                                                     std::string resourceName,
                                                                                                     ::Deployment::Properties property)
           : targetName_ (std::move (targetName))
           , requirementName_ (std::move (requirementName))
           , resourceName_ (std::move (resourceName))
           , property_ (std::move (property))
{
}

inline void Deployment::ConnectionResourceDeploymentDescription::targetName (const std::string& _targetName) { this->targetName_ = _targetName; }
inline void Deployment::ConnectionResourceDeploymentDescription::targetName (std::string&& _targetName) { this->targetName_ = std::move (_targetName); }
inline const std::string& Deployment::ConnectionResourceDeploymentDescription::targetName (void) const { return this->targetName_; }
inline std::string& Deployment::ConnectionResourceDeploymentDescription::targetName (void) { return this->targetName_; }

inline void Deployment::ConnectionResourceDeploymentDescription::requirementName (const std::string& _requirementName) { this->requirementName_ = _requirementName; }
inline void Deployment::ConnectionResourceDeploymentDescription::requirementName (std::string&& _requirementName) { this->requirementName_ = std::move (_requirementName); }
inline const std::string& Deployment::ConnectionResourceDeploymentDescription::requirementName (void) const { return this->requirementName_; }
inline std::string& Deployment::ConnectionResourceDeploymentDescription::requirementName (void) { return this->requirementName_; }

inline void Deployment::ConnectionResourceDeploymentDescription::resourceName (const std::string& _resourceName) { this->resourceName_ = _resourceName; }
inline void Deployment::ConnectionResourceDeploymentDescription::resourceName (std::string&& _resourceName) { this->resourceName_ = std::move (_resourceName); }
inline const std::string& Deployment::ConnectionResourceDeploymentDescription::resourceName (void) const { return this->resourceName_; }
inline std::string& Deployment::ConnectionResourceDeploymentDescription::resourceName (void) { return this->resourceName_; }

inline void Deployment::ConnectionResourceDeploymentDescription::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::ConnectionResourceDeploymentDescription::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::ConnectionResourceDeploymentDescription::property (void) const { return this->property_; }
inline ::Deployment::Properties& Deployment::ConnectionResourceDeploymentDescription::property (void) { return this->property_; }

inline ::Deployment::ConnectionResourceDeploymentDescription& Deployment::ConnectionResourceDeploymentDescription::operator= (const ::Deployment::ConnectionResourceDeploymentDescription& x)
{
  if (this != &x) {
    this->targetName_ = x.targetName_;
    this->requirementName_ = x.requirementName_;
    this->resourceName_ = x.resourceName_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::ConnectionResourceDeploymentDescription& Deployment::ConnectionResourceDeploymentDescription::operator= (::Deployment::ConnectionResourceDeploymentDescription&& x)
{
  this->targetName_ = std::move (x.targetName_);
  this->requirementName_ = std::move (x.requirementName_);
  this->resourceName_ = std::move (x.resourceName_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::ConnectionResourceDeploymentDescription::swap (::Deployment::ConnectionResourceDeploymentDescription& s)
{
  std::swap (this->targetName_, s.targetName_);
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::PlanConnectionDescription::PlanConnectionDescription ()
           : name_ (std::string())
           , source_ (std::vector < std::string> ())
           , deployRequirement_ (std::vector < ::Deployment::Requirement> ())
           , externalEndpoint_ (std::vector < ::Deployment::ComponentExternalPortEndpoint> ())
           , internalEndpoint_ (std::vector < ::Deployment::PlanSubcomponentPortEndpoint> ())
           , externalReference_ (std::vector < ::Deployment::ExternalReferenceEndpoint> ())
           , deployedResource_ (std::vector < ::Deployment::ConnectionResourceDeploymentDescription> ())
{
}
inline Deployment::PlanConnectionDescription::PlanConnectionDescription (std::string name,
                                                                         ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                                         ::Deployment::Requirements deployRequirement,
                                                                         ::Deployment::ComponentExternalPortEndpoints externalEndpoint,
                                                                         ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint,
                                                                         ::Deployment::ExternalReferenceEndpoints externalReference,
                                                                         ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource)
           : name_ (std::move (name))
           , source_ (std::move (source))
           , deployRequirement_ (std::move (deployRequirement))
           , externalEndpoint_ (std::move (externalEndpoint))
           , internalEndpoint_ (std::move (internalEndpoint))
           , externalReference_ (std::move (externalReference))
           , deployedResource_ (std::move (deployedResource))
{
}

inline void Deployment::PlanConnectionDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::PlanConnectionDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::PlanConnectionDescription::name (void) const { return this->name_; }
inline std::string& Deployment::PlanConnectionDescription::name (void) { return this->name_; }

inline void Deployment::PlanConnectionDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::PlanConnectionDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanConnectionDescription::source (void) const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanConnectionDescription::source (void) { return this->source_; }

inline void Deployment::PlanConnectionDescription::deployRequirement (const ::Deployment::Requirements& _deployRequirement) { this->deployRequirement_ = _deployRequirement; }
inline void Deployment::PlanConnectionDescription::deployRequirement (::Deployment::Requirements&& _deployRequirement) { this->deployRequirement_ = std::move (_deployRequirement); }
inline const ::Deployment::Requirements& Deployment::PlanConnectionDescription::deployRequirement (void) const { return this->deployRequirement_; }
inline ::Deployment::Requirements& Deployment::PlanConnectionDescription::deployRequirement (void) { return this->deployRequirement_; }

inline void Deployment::PlanConnectionDescription::externalEndpoint (const ::Deployment::ComponentExternalPortEndpoints& _externalEndpoint) { this->externalEndpoint_ = _externalEndpoint; }
inline void Deployment::PlanConnectionDescription::externalEndpoint (::Deployment::ComponentExternalPortEndpoints&& _externalEndpoint) { this->externalEndpoint_ = std::move (_externalEndpoint); }
inline const ::Deployment::ComponentExternalPortEndpoints& Deployment::PlanConnectionDescription::externalEndpoint (void) const { return this->externalEndpoint_; }
inline ::Deployment::ComponentExternalPortEndpoints& Deployment::PlanConnectionDescription::externalEndpoint (void) { return this->externalEndpoint_; }

inline void Deployment::PlanConnectionDescription::internalEndpoint (const ::Deployment::PlanSubcomponentPortEndpoints& _internalEndpoint) { this->internalEndpoint_ = _internalEndpoint; }
inline void Deployment::PlanConnectionDescription::internalEndpoint (::Deployment::PlanSubcomponentPortEndpoints&& _internalEndpoint) { this->internalEndpoint_ = std::move (_internalEndpoint); }
inline const ::Deployment::PlanSubcomponentPortEndpoints& Deployment::PlanConnectionDescription::internalEndpoint (void) const { return this->internalEndpoint_; }
inline ::Deployment::PlanSubcomponentPortEndpoints& Deployment::PlanConnectionDescription::internalEndpoint (void) { return this->internalEndpoint_; }

inline void Deployment::PlanConnectionDescription::externalReference (const ::Deployment::ExternalReferenceEndpoints& _externalReference) { this->externalReference_ = _externalReference; }
inline void Deployment::PlanConnectionDescription::externalReference (::Deployment::ExternalReferenceEndpoints&& _externalReference) { this->externalReference_ = std::move (_externalReference); }
inline const ::Deployment::ExternalReferenceEndpoints& Deployment::PlanConnectionDescription::externalReference (void) const { return this->externalReference_; }
inline ::Deployment::ExternalReferenceEndpoints& Deployment::PlanConnectionDescription::externalReference (void) { return this->externalReference_; }

inline void Deployment::PlanConnectionDescription::deployedResource (const ::Deployment::ConnectionResourceDeploymentDescriptions& _deployedResource) { this->deployedResource_ = _deployedResource; }
inline void Deployment::PlanConnectionDescription::deployedResource (::Deployment::ConnectionResourceDeploymentDescriptions&& _deployedResource) { this->deployedResource_ = std::move (_deployedResource); }
inline const ::Deployment::ConnectionResourceDeploymentDescriptions& Deployment::PlanConnectionDescription::deployedResource (void) const { return this->deployedResource_; }
inline ::Deployment::ConnectionResourceDeploymentDescriptions& Deployment::PlanConnectionDescription::deployedResource (void) { return this->deployedResource_; }

inline ::Deployment::PlanConnectionDescription& Deployment::PlanConnectionDescription::operator= (const ::Deployment::PlanConnectionDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->source_ = x.source_;
    this->deployRequirement_ = x.deployRequirement_;
    this->externalEndpoint_ = x.externalEndpoint_;
    this->internalEndpoint_ = x.internalEndpoint_;
    this->externalReference_ = x.externalReference_;
    this->deployedResource_ = x.deployedResource_;
  }
  return *this;
}
inline ::Deployment::PlanConnectionDescription& Deployment::PlanConnectionDescription::operator= (::Deployment::PlanConnectionDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->source_ = std::move (x.source_);
  this->deployRequirement_ = std::move (x.deployRequirement_);
  this->externalEndpoint_ = std::move (x.externalEndpoint_);
  this->internalEndpoint_ = std::move (x.internalEndpoint_);
  this->externalReference_ = std::move (x.externalReference_);
  this->deployedResource_ = std::move (x.deployedResource_);
  return *this;
}

inline void Deployment::PlanConnectionDescription::swap (::Deployment::PlanConnectionDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
  std::swap (this->externalEndpoint_, s.externalEndpoint_);
  std::swap (this->internalEndpoint_, s.internalEndpoint_);
  std::swap (this->externalReference_, s.externalReference_);
  std::swap (this->deployedResource_, s.deployedResource_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::PlanSubcomponentPropertyReference::PlanSubcomponentPropertyReference ()
           : propertyName_ (std::string())
           , instanceRef_ (0)
{
}
inline Deployment::PlanSubcomponentPropertyReference::PlanSubcomponentPropertyReference (std::string propertyName,
                                                                                         uint32_t instanceRef)
           : propertyName_ (std::move (propertyName))
           , instanceRef_ (std::move (instanceRef))
{
}

inline void Deployment::PlanSubcomponentPropertyReference::propertyName (const std::string& _propertyName) { this->propertyName_ = _propertyName; }
inline void Deployment::PlanSubcomponentPropertyReference::propertyName (std::string&& _propertyName) { this->propertyName_ = std::move (_propertyName); }
inline const std::string& Deployment::PlanSubcomponentPropertyReference::propertyName (void) const { return this->propertyName_; }
inline std::string& Deployment::PlanSubcomponentPropertyReference::propertyName (void) { return this->propertyName_; }

inline void Deployment::PlanSubcomponentPropertyReference::instanceRef (uint32_t _instanceRef) { this->instanceRef_ = _instanceRef; }
inline uint32_t Deployment::PlanSubcomponentPropertyReference::instanceRef (void) const { return this->instanceRef_; }
inline uint32_t& Deployment::PlanSubcomponentPropertyReference::instanceRef (void) { return this->instanceRef_; }

inline ::Deployment::PlanSubcomponentPropertyReference& Deployment::PlanSubcomponentPropertyReference::operator= (const ::Deployment::PlanSubcomponentPropertyReference& x)
{
  if (this != &x) {
    this->propertyName_ = x.propertyName_;
    this->instanceRef_ = x.instanceRef_;
  }
  return *this;
}
inline ::Deployment::PlanSubcomponentPropertyReference& Deployment::PlanSubcomponentPropertyReference::operator= (::Deployment::PlanSubcomponentPropertyReference&& x)
{
  this->propertyName_ = std::move (x.propertyName_);
  this->instanceRef_ = std::move (x.instanceRef_);
  return *this;
}

inline void Deployment::PlanSubcomponentPropertyReference::swap (::Deployment::PlanSubcomponentPropertyReference& s)
{
  std::swap (this->propertyName_, s.propertyName_);
  std::swap (this->instanceRef_, s.instanceRef_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::PlanPropertyMapping::PlanPropertyMapping ()
           : name_ (std::string())
           , source_ (std::vector < std::string> ())
           , externalName_ (std::string())
           , delegatesTo_ (std::vector < ::Deployment::PlanSubcomponentPropertyReference> ())
{
}
inline Deployment::PlanPropertyMapping::PlanPropertyMapping (std::string name,
                                                             ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                             std::string externalName,
                                                             ::Deployment::PlanSubcomponentPropertyReferences delegatesTo)
           : name_ (std::move (name))
           , source_ (std::move (source))
           , externalName_ (std::move (externalName))
           , delegatesTo_ (std::move (delegatesTo))
{
}

inline void Deployment::PlanPropertyMapping::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::PlanPropertyMapping::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::PlanPropertyMapping::name (void) const { return this->name_; }
inline std::string& Deployment::PlanPropertyMapping::name (void) { return this->name_; }

inline void Deployment::PlanPropertyMapping::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::PlanPropertyMapping::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanPropertyMapping::source (void) const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanPropertyMapping::source (void) { return this->source_; }

inline void Deployment::PlanPropertyMapping::externalName (const std::string& _externalName) { this->externalName_ = _externalName; }
inline void Deployment::PlanPropertyMapping::externalName (std::string&& _externalName) { this->externalName_ = std::move (_externalName); }
inline const std::string& Deployment::PlanPropertyMapping::externalName (void) const { return this->externalName_; }
inline std::string& Deployment::PlanPropertyMapping::externalName (void) { return this->externalName_; }

inline void Deployment::PlanPropertyMapping::delegatesTo (const ::Deployment::PlanSubcomponentPropertyReferences& _delegatesTo) { this->delegatesTo_ = _delegatesTo; }
inline void Deployment::PlanPropertyMapping::delegatesTo (::Deployment::PlanSubcomponentPropertyReferences&& _delegatesTo) { this->delegatesTo_ = std::move (_delegatesTo); }
inline const ::Deployment::PlanSubcomponentPropertyReferences& Deployment::PlanPropertyMapping::delegatesTo (void) const { return this->delegatesTo_; }
inline ::Deployment::PlanSubcomponentPropertyReferences& Deployment::PlanPropertyMapping::delegatesTo (void) { return this->delegatesTo_; }

inline ::Deployment::PlanPropertyMapping& Deployment::PlanPropertyMapping::operator= (const ::Deployment::PlanPropertyMapping& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->source_ = x.source_;
    this->externalName_ = x.externalName_;
    this->delegatesTo_ = x.delegatesTo_;
  }
  return *this;
}
inline ::Deployment::PlanPropertyMapping& Deployment::PlanPropertyMapping::operator= (::Deployment::PlanPropertyMapping&& x)
{
  this->name_ = std::move (x.name_);
  this->source_ = std::move (x.source_);
  this->externalName_ = std::move (x.externalName_);
  this->delegatesTo_ = std::move (x.delegatesTo_);
  return *this;
}

inline void Deployment::PlanPropertyMapping::swap (::Deployment::PlanPropertyMapping& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->externalName_, s.externalName_);
  std::swap (this->delegatesTo_, s.delegatesTo_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ImplementationDependency::ImplementationDependency ()
           : requiredType_ (std::string())
{
}
inline Deployment::ImplementationDependency::ImplementationDependency (std::string requiredType)
           : requiredType_ (std::move (requiredType))
{
}

inline void Deployment::ImplementationDependency::requiredType (const std::string& _requiredType) { this->requiredType_ = _requiredType; }
inline void Deployment::ImplementationDependency::requiredType (std::string&& _requiredType) { this->requiredType_ = std::move (_requiredType); }
inline const std::string& Deployment::ImplementationDependency::requiredType (void) const { return this->requiredType_; }
inline std::string& Deployment::ImplementationDependency::requiredType (void) { return this->requiredType_; }

inline ::Deployment::ImplementationDependency& Deployment::ImplementationDependency::operator= (const ::Deployment::ImplementationDependency& x)
{
  if (this != &x) {
    this->requiredType_ = x.requiredType_;
  }
  return *this;
}
inline ::Deployment::ImplementationDependency& Deployment::ImplementationDependency::operator= (::Deployment::ImplementationDependency&& x)
{
  this->requiredType_ = std::move (x.requiredType_);
  return *this;
}

inline void Deployment::ImplementationDependency::swap (::Deployment::ImplementationDependency& s)
{
  std::swap (this->requiredType_, s.requiredType_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ResourceDeploymentDescription::ResourceDeploymentDescription ()
           : requirementName_ (std::string())
           , resourceName_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::ResourceDeploymentDescription::ResourceDeploymentDescription (std::string requirementName,
                                                                                 std::string resourceName,
                                                                                 ::Deployment::Properties property)
           : requirementName_ (std::move (requirementName))
           , resourceName_ (std::move (resourceName))
           , property_ (std::move (property))
{
}

inline void Deployment::ResourceDeploymentDescription::requirementName (const std::string& _requirementName) { this->requirementName_ = _requirementName; }
inline void Deployment::ResourceDeploymentDescription::requirementName (std::string&& _requirementName) { this->requirementName_ = std::move (_requirementName); }
inline const std::string& Deployment::ResourceDeploymentDescription::requirementName (void) const { return this->requirementName_; }
inline std::string& Deployment::ResourceDeploymentDescription::requirementName (void) { return this->requirementName_; }

inline void Deployment::ResourceDeploymentDescription::resourceName (const std::string& _resourceName) { this->resourceName_ = _resourceName; }
inline void Deployment::ResourceDeploymentDescription::resourceName (std::string&& _resourceName) { this->resourceName_ = std::move (_resourceName); }
inline const std::string& Deployment::ResourceDeploymentDescription::resourceName (void) const { return this->resourceName_; }
inline std::string& Deployment::ResourceDeploymentDescription::resourceName (void) { return this->resourceName_; }

inline void Deployment::ResourceDeploymentDescription::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::ResourceDeploymentDescription::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::ResourceDeploymentDescription::property (void) const { return this->property_; }
inline ::Deployment::Properties& Deployment::ResourceDeploymentDescription::property (void) { return this->property_; }

inline ::Deployment::ResourceDeploymentDescription& Deployment::ResourceDeploymentDescription::operator= (const ::Deployment::ResourceDeploymentDescription& x)
{
  if (this != &x) {
    this->requirementName_ = x.requirementName_;
    this->resourceName_ = x.resourceName_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::ResourceDeploymentDescription& Deployment::ResourceDeploymentDescription::operator= (::Deployment::ResourceDeploymentDescription&& x)
{
  this->requirementName_ = std::move (x.requirementName_);
  this->resourceName_ = std::move (x.resourceName_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::ResourceDeploymentDescription::swap (::Deployment::ResourceDeploymentDescription& s)
{
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ArtifactDeploymentDescription::ArtifactDeploymentDescription ()
           : name_ (std::string())
           , location_ (std::vector < std::string> ())
           , node_ (std::string())
           , source_ (std::vector < std::string> ())
           , execParameter_ (std::vector < ::Deployment::Property> ())
           , deployRequirement_ (std::vector < ::Deployment::Requirement> ())
           , deployedResource_ (std::vector < ::Deployment::ResourceDeploymentDescription> ())
{
}
inline Deployment::ArtifactDeploymentDescription::ArtifactDeploymentDescription (std::string name,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq location,
                                                                                 std::string node,
                                                                                 ::TAOX11_NAMESPACE::CORBA::StringSeq source,
                                                                                 ::Deployment::Properties execParameter,
                                                                                 ::Deployment::Requirements deployRequirement,
                                                                                 ::Deployment::ResourceDeploymentDescriptions deployedResource)
           : name_ (std::move (name))
           , location_ (std::move (location))
           , node_ (std::move (node))
           , source_ (std::move (source))
           , execParameter_ (std::move (execParameter))
           , deployRequirement_ (std::move (deployRequirement))
           , deployedResource_ (std::move (deployedResource))
{
}

inline void Deployment::ArtifactDeploymentDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ArtifactDeploymentDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ArtifactDeploymentDescription::name (void) const { return this->name_; }
inline std::string& Deployment::ArtifactDeploymentDescription::name (void) { return this->name_; }

inline void Deployment::ArtifactDeploymentDescription::location (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _location) { this->location_ = _location; }
inline void Deployment::ArtifactDeploymentDescription::location (::TAOX11_NAMESPACE::CORBA::StringSeq&& _location) { this->location_ = std::move (_location); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::location (void) const { return this->location_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::location (void) { return this->location_; }

inline void Deployment::ArtifactDeploymentDescription::node (const std::string& _node) { this->node_ = _node; }
inline void Deployment::ArtifactDeploymentDescription::node (std::string&& _node) { this->node_ = std::move (_node); }
inline const std::string& Deployment::ArtifactDeploymentDescription::node (void) const { return this->node_; }
inline std::string& Deployment::ArtifactDeploymentDescription::node (void) { return this->node_; }

inline void Deployment::ArtifactDeploymentDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::ArtifactDeploymentDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::source (void) const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::source (void) { return this->source_; }

inline void Deployment::ArtifactDeploymentDescription::execParameter (const ::Deployment::Properties& _execParameter) { this->execParameter_ = _execParameter; }
inline void Deployment::ArtifactDeploymentDescription::execParameter (::Deployment::Properties&& _execParameter) { this->execParameter_ = std::move (_execParameter); }
inline const ::Deployment::Properties& Deployment::ArtifactDeploymentDescription::execParameter (void) const { return this->execParameter_; }
inline ::Deployment::Properties& Deployment::ArtifactDeploymentDescription::execParameter (void) { return this->execParameter_; }

inline void Deployment::ArtifactDeploymentDescription::deployRequirement (const ::Deployment::Requirements& _deployRequirement) { this->deployRequirement_ = _deployRequirement; }
inline void Deployment::ArtifactDeploymentDescription::deployRequirement (::Deployment::Requirements&& _deployRequirement) { this->deployRequirement_ = std::move (_deployRequirement); }
inline const ::Deployment::Requirements& Deployment::ArtifactDeploymentDescription::deployRequirement (void) const { return this->deployRequirement_; }
inline ::Deployment::Requirements& Deployment::ArtifactDeploymentDescription::deployRequirement (void) { return this->deployRequirement_; }

inline void Deployment::ArtifactDeploymentDescription::deployedResource (const ::Deployment::ResourceDeploymentDescriptions& _deployedResource) { this->deployedResource_ = _deployedResource; }
inline void Deployment::ArtifactDeploymentDescription::deployedResource (::Deployment::ResourceDeploymentDescriptions&& _deployedResource) { this->deployedResource_ = std::move (_deployedResource); }
inline const ::Deployment::ResourceDeploymentDescriptions& Deployment::ArtifactDeploymentDescription::deployedResource (void) const { return this->deployedResource_; }
inline ::Deployment::ResourceDeploymentDescriptions& Deployment::ArtifactDeploymentDescription::deployedResource (void) { return this->deployedResource_; }

inline ::Deployment::ArtifactDeploymentDescription& Deployment::ArtifactDeploymentDescription::operator= (const ::Deployment::ArtifactDeploymentDescription& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->location_ = x.location_;
    this->node_ = x.node_;
    this->source_ = x.source_;
    this->execParameter_ = x.execParameter_;
    this->deployRequirement_ = x.deployRequirement_;
    this->deployedResource_ = x.deployedResource_;
  }
  return *this;
}
inline ::Deployment::ArtifactDeploymentDescription& Deployment::ArtifactDeploymentDescription::operator= (::Deployment::ArtifactDeploymentDescription&& x)
{
  this->name_ = std::move (x.name_);
  this->location_ = std::move (x.location_);
  this->node_ = std::move (x.node_);
  this->source_ = std::move (x.source_);
  this->execParameter_ = std::move (x.execParameter_);
  this->deployRequirement_ = std::move (x.deployRequirement_);
  this->deployedResource_ = std::move (x.deployedResource_);
  return *this;
}

inline void Deployment::ArtifactDeploymentDescription::swap (::Deployment::ArtifactDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->location_, s.location_);
  std::swap (this->node_, s.node_);
  std::swap (this->source_, s.source_);
  std::swap (this->execParameter_, s.execParameter_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
  std::swap (this->deployedResource_, s.deployedResource_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::PlanLocality::PlanLocality ()
           : constraint_ (::Deployment::PlanLocalityKind::PlanSameProcess)
           , constrainedInstanceRef_ (std::vector < uint32_t> ())
{
}
inline Deployment::PlanLocality::PlanLocality (::Deployment::PlanLocalityKind constraint,
                                               ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef)
           : constraint_ (std::move (constraint))
           , constrainedInstanceRef_ (std::move (constrainedInstanceRef))
{
}

inline void Deployment::PlanLocality::constraint (::Deployment::PlanLocalityKind _constraint) { this->constraint_ = _constraint; }
inline ::Deployment::PlanLocalityKind Deployment::PlanLocality::constraint (void) const { return this->constraint_; }
inline ::Deployment::PlanLocalityKind& Deployment::PlanLocality::constraint (void) { return this->constraint_; }

inline void Deployment::PlanLocality::constrainedInstanceRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _constrainedInstanceRef) { this->constrainedInstanceRef_ = _constrainedInstanceRef; }
inline void Deployment::PlanLocality::constrainedInstanceRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _constrainedInstanceRef) { this->constrainedInstanceRef_ = std::move (_constrainedInstanceRef); }
inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::PlanLocality::constrainedInstanceRef (void) const { return this->constrainedInstanceRef_; }
inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::PlanLocality::constrainedInstanceRef (void) { return this->constrainedInstanceRef_; }

inline ::Deployment::PlanLocality& Deployment::PlanLocality::operator= (const ::Deployment::PlanLocality& x)
{
  if (this != &x) {
    this->constraint_ = x.constraint_;
    this->constrainedInstanceRef_ = x.constrainedInstanceRef_;
  }
  return *this;
}
inline ::Deployment::PlanLocality& Deployment::PlanLocality::operator= (::Deployment::PlanLocality&& x)
{
  this->constraint_ = std::move (x.constraint_);
  this->constrainedInstanceRef_ = std::move (x.constrainedInstanceRef_);
  return *this;
}

inline void Deployment::PlanLocality::swap (::Deployment::PlanLocality& s)
{
  std::swap (this->constraint_, s.constraint_);
  std::swap (this->constrainedInstanceRef_, s.constrainedInstanceRef_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::DeploymentPlan::DeploymentPlan ()
           : label_ (std::string())
           , UUID_ (std::string())
           , realizes_ (::Deployment::ComponentInterfaceDescription ())
           , implementation_ (std::vector < ::Deployment::MonolithicDeploymentDescription> ())
           , instance_ (std::vector < ::Deployment::InstanceDeploymentDescription> ())
           , connection_ (std::vector < ::Deployment::PlanConnectionDescription> ())
           , externalProperty_ (std::vector < ::Deployment::PlanPropertyMapping> ())
           , dependsOn_ (std::vector < ::Deployment::ImplementationDependency> ())
           , artifact_ (std::vector < ::Deployment::ArtifactDeploymentDescription> ())
           , infoProperty_ (std::vector < ::Deployment::Property> ())
           , localityConstraint_ (std::vector < ::Deployment::PlanLocality> ())
{
}
inline Deployment::DeploymentPlan::DeploymentPlan (std::string label,
                                                   std::string UUID,
                                                   ::Deployment::ComponentInterfaceDescription realizes,
                                                   ::Deployment::MonolithicDeploymentDescriptions implementation,
                                                   ::Deployment::InstanceDeploymentDescriptions instance,
                                                   ::Deployment::PlanConnectionDescriptions connection,
                                                   ::Deployment::PlanPropertyMappings externalProperty,
                                                   ::Deployment::ImplementationDependencies dependsOn,
                                                   ::Deployment::ArtifactDeploymentDescriptions artifact,
                                                   ::Deployment::Properties infoProperty,
                                                   ::Deployment::PlanLocalities localityConstraint)
           : label_ (std::move (label))
           , UUID_ (std::move (UUID))
           , realizes_ (std::move (realizes))
           , implementation_ (std::move (implementation))
           , instance_ (std::move (instance))
           , connection_ (std::move (connection))
           , externalProperty_ (std::move (externalProperty))
           , dependsOn_ (std::move (dependsOn))
           , artifact_ (std::move (artifact))
           , infoProperty_ (std::move (infoProperty))
           , localityConstraint_ (std::move (localityConstraint))
{
}

inline void Deployment::DeploymentPlan::label (const std::string& _label) { this->label_ = _label; }
inline void Deployment::DeploymentPlan::label (std::string&& _label) { this->label_ = std::move (_label); }
inline const std::string& Deployment::DeploymentPlan::label (void) const { return this->label_; }
inline std::string& Deployment::DeploymentPlan::label (void) { return this->label_; }

inline void Deployment::DeploymentPlan::UUID (const std::string& _UUID) { this->UUID_ = _UUID; }
inline void Deployment::DeploymentPlan::UUID (std::string&& _UUID) { this->UUID_ = std::move (_UUID); }
inline const std::string& Deployment::DeploymentPlan::UUID (void) const { return this->UUID_; }
inline std::string& Deployment::DeploymentPlan::UUID (void) { return this->UUID_; }

inline void Deployment::DeploymentPlan::realizes (const ::Deployment::ComponentInterfaceDescription& _realizes) { this->realizes_ = _realizes; }
inline void Deployment::DeploymentPlan::realizes (::Deployment::ComponentInterfaceDescription&& _realizes) { this->realizes_ = std::move (_realizes); }
inline const ::Deployment::ComponentInterfaceDescription& Deployment::DeploymentPlan::realizes (void) const { return this->realizes_; }
inline ::Deployment::ComponentInterfaceDescription& Deployment::DeploymentPlan::realizes (void) { return this->realizes_; }

inline void Deployment::DeploymentPlan::implementation (const ::Deployment::MonolithicDeploymentDescriptions& _implementation) { this->implementation_ = _implementation; }
inline void Deployment::DeploymentPlan::implementation (::Deployment::MonolithicDeploymentDescriptions&& _implementation) { this->implementation_ = std::move (_implementation); }
inline const ::Deployment::MonolithicDeploymentDescriptions& Deployment::DeploymentPlan::implementation (void) const { return this->implementation_; }
inline ::Deployment::MonolithicDeploymentDescriptions& Deployment::DeploymentPlan::implementation (void) { return this->implementation_; }

inline void Deployment::DeploymentPlan::instance (const ::Deployment::InstanceDeploymentDescriptions& _instance) { this->instance_ = _instance; }
inline void Deployment::DeploymentPlan::instance (::Deployment::InstanceDeploymentDescriptions&& _instance) { this->instance_ = std::move (_instance); }
inline const ::Deployment::InstanceDeploymentDescriptions& Deployment::DeploymentPlan::instance (void) const { return this->instance_; }
inline ::Deployment::InstanceDeploymentDescriptions& Deployment::DeploymentPlan::instance (void) { return this->instance_; }

inline void Deployment::DeploymentPlan::connection (const ::Deployment::PlanConnectionDescriptions& _connection) { this->connection_ = _connection; }
inline void Deployment::DeploymentPlan::connection (::Deployment::PlanConnectionDescriptions&& _connection) { this->connection_ = std::move (_connection); }
inline const ::Deployment::PlanConnectionDescriptions& Deployment::DeploymentPlan::connection (void) const { return this->connection_; }
inline ::Deployment::PlanConnectionDescriptions& Deployment::DeploymentPlan::connection (void) { return this->connection_; }

inline void Deployment::DeploymentPlan::externalProperty (const ::Deployment::PlanPropertyMappings& _externalProperty) { this->externalProperty_ = _externalProperty; }
inline void Deployment::DeploymentPlan::externalProperty (::Deployment::PlanPropertyMappings&& _externalProperty) { this->externalProperty_ = std::move (_externalProperty); }
inline const ::Deployment::PlanPropertyMappings& Deployment::DeploymentPlan::externalProperty (void) const { return this->externalProperty_; }
inline ::Deployment::PlanPropertyMappings& Deployment::DeploymentPlan::externalProperty (void) { return this->externalProperty_; }

inline void Deployment::DeploymentPlan::dependsOn (const ::Deployment::ImplementationDependencies& _dependsOn) { this->dependsOn_ = _dependsOn; }
inline void Deployment::DeploymentPlan::dependsOn (::Deployment::ImplementationDependencies&& _dependsOn) { this->dependsOn_ = std::move (_dependsOn); }
inline const ::Deployment::ImplementationDependencies& Deployment::DeploymentPlan::dependsOn (void) const { return this->dependsOn_; }
inline ::Deployment::ImplementationDependencies& Deployment::DeploymentPlan::dependsOn (void) { return this->dependsOn_; }

inline void Deployment::DeploymentPlan::artifact (const ::Deployment::ArtifactDeploymentDescriptions& _artifact) { this->artifact_ = _artifact; }
inline void Deployment::DeploymentPlan::artifact (::Deployment::ArtifactDeploymentDescriptions&& _artifact) { this->artifact_ = std::move (_artifact); }
inline const ::Deployment::ArtifactDeploymentDescriptions& Deployment::DeploymentPlan::artifact (void) const { return this->artifact_; }
inline ::Deployment::ArtifactDeploymentDescriptions& Deployment::DeploymentPlan::artifact (void) { return this->artifact_; }

inline void Deployment::DeploymentPlan::infoProperty (const ::Deployment::Properties& _infoProperty) { this->infoProperty_ = _infoProperty; }
inline void Deployment::DeploymentPlan::infoProperty (::Deployment::Properties&& _infoProperty) { this->infoProperty_ = std::move (_infoProperty); }
inline const ::Deployment::Properties& Deployment::DeploymentPlan::infoProperty (void) const { return this->infoProperty_; }
inline ::Deployment::Properties& Deployment::DeploymentPlan::infoProperty (void) { return this->infoProperty_; }

inline void Deployment::DeploymentPlan::localityConstraint (const ::Deployment::PlanLocalities& _localityConstraint) { this->localityConstraint_ = _localityConstraint; }
inline void Deployment::DeploymentPlan::localityConstraint (::Deployment::PlanLocalities&& _localityConstraint) { this->localityConstraint_ = std::move (_localityConstraint); }
inline const ::Deployment::PlanLocalities& Deployment::DeploymentPlan::localityConstraint (void) const { return this->localityConstraint_; }
inline ::Deployment::PlanLocalities& Deployment::DeploymentPlan::localityConstraint (void) { return this->localityConstraint_; }

inline ::Deployment::DeploymentPlan& Deployment::DeploymentPlan::operator= (const ::Deployment::DeploymentPlan& x)
{
  if (this != &x) {
    this->label_ = x.label_;
    this->UUID_ = x.UUID_;
    this->realizes_ = x.realizes_;
    this->implementation_ = x.implementation_;
    this->instance_ = x.instance_;
    this->connection_ = x.connection_;
    this->externalProperty_ = x.externalProperty_;
    this->dependsOn_ = x.dependsOn_;
    this->artifact_ = x.artifact_;
    this->infoProperty_ = x.infoProperty_;
    this->localityConstraint_ = x.localityConstraint_;
  }
  return *this;
}
inline ::Deployment::DeploymentPlan& Deployment::DeploymentPlan::operator= (::Deployment::DeploymentPlan&& x)
{
  this->label_ = std::move (x.label_);
  this->UUID_ = std::move (x.UUID_);
  this->realizes_ = std::move (x.realizes_);
  this->implementation_ = std::move (x.implementation_);
  this->instance_ = std::move (x.instance_);
  this->connection_ = std::move (x.connection_);
  this->externalProperty_ = std::move (x.externalProperty_);
  this->dependsOn_ = std::move (x.dependsOn_);
  this->artifact_ = std::move (x.artifact_);
  this->infoProperty_ = std::move (x.infoProperty_);
  this->localityConstraint_ = std::move (x.localityConstraint_);
  return *this;
}

inline void Deployment::DeploymentPlan::swap (::Deployment::DeploymentPlan& s)
{
  std::swap (this->label_, s.label_);
  std::swap (this->UUID_, s.UUID_);
  std::swap (this->realizes_, s.realizes_);
  std::swap (this->implementation_, s.implementation_);
  std::swap (this->instance_, s.instance_);
  std::swap (this->connection_, s.connection_);
  std::swap (this->externalProperty_, s.externalProperty_);
  std::swap (this->dependsOn_, s.dependsOn_);
  std::swap (this->artifact_, s.artifact_);
  std::swap (this->infoProperty_, s.infoProperty_);
  std::swap (this->localityConstraint_, s.localityConstraint_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ComponentPackageReference::ComponentPackageReference ()
           : requiredUUID_ (std::string())
           , requiredName_ (std::string())
           , requiredType_ (::Deployment::ComponentInterfaceDescription ())
{
}
inline Deployment::ComponentPackageReference::ComponentPackageReference (std::string requiredUUID,
                                                                         std::string requiredName,
                                                                         ::Deployment::ComponentInterfaceDescription requiredType)
           : requiredUUID_ (std::move (requiredUUID))
           , requiredName_ (std::move (requiredName))
           , requiredType_ (std::move (requiredType))
{
}

inline void Deployment::ComponentPackageReference::requiredUUID (const std::string& _requiredUUID) { this->requiredUUID_ = _requiredUUID; }
inline void Deployment::ComponentPackageReference::requiredUUID (std::string&& _requiredUUID) { this->requiredUUID_ = std::move (_requiredUUID); }
inline const std::string& Deployment::ComponentPackageReference::requiredUUID (void) const { return this->requiredUUID_; }
inline std::string& Deployment::ComponentPackageReference::requiredUUID (void) { return this->requiredUUID_; }

inline void Deployment::ComponentPackageReference::requiredName (const std::string& _requiredName) { this->requiredName_ = _requiredName; }
inline void Deployment::ComponentPackageReference::requiredName (std::string&& _requiredName) { this->requiredName_ = std::move (_requiredName); }
inline const std::string& Deployment::ComponentPackageReference::requiredName (void) const { return this->requiredName_; }
inline std::string& Deployment::ComponentPackageReference::requiredName (void) { return this->requiredName_; }

inline void Deployment::ComponentPackageReference::requiredType (const ::Deployment::ComponentInterfaceDescription& _requiredType) { this->requiredType_ = _requiredType; }
inline void Deployment::ComponentPackageReference::requiredType (::Deployment::ComponentInterfaceDescription&& _requiredType) { this->requiredType_ = std::move (_requiredType); }
inline const ::Deployment::ComponentInterfaceDescription& Deployment::ComponentPackageReference::requiredType (void) const { return this->requiredType_; }
inline ::Deployment::ComponentInterfaceDescription& Deployment::ComponentPackageReference::requiredType (void) { return this->requiredType_; }

inline ::Deployment::ComponentPackageReference& Deployment::ComponentPackageReference::operator= (const ::Deployment::ComponentPackageReference& x)
{
  if (this != &x) {
    this->requiredUUID_ = x.requiredUUID_;
    this->requiredName_ = x.requiredName_;
    this->requiredType_ = x.requiredType_;
  }
  return *this;
}
inline ::Deployment::ComponentPackageReference& Deployment::ComponentPackageReference::operator= (::Deployment::ComponentPackageReference&& x)
{
  this->requiredUUID_ = std::move (x.requiredUUID_);
  this->requiredName_ = std::move (x.requiredName_);
  this->requiredType_ = std::move (x.requiredType_);
  return *this;
}

inline void Deployment::ComponentPackageReference::swap (::Deployment::ComponentPackageReference& s)
{
  std::swap (this->requiredUUID_, s.requiredUUID_);
  std::swap (this->requiredName_, s.requiredName_);
  std::swap (this->requiredType_, s.requiredType_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::ImplementationRequirement::ImplementationRequirement ()
           : resourceUsage_ (std::vector < ::Deployment::ResourceUsageKind> ())
           , resourcePort_ (std::string())
           , componentPort_ (std::string())
           , name_ (std::string())
           , resourceType_ (std::string())
           , property_ (std::vector < ::Deployment::Property> ())
{
}
inline Deployment::ImplementationRequirement::ImplementationRequirement (::Deployment::ResourceUsageKinds resourceUsage,
                                                                         std::string resourcePort,
                                                                         std::string componentPort,
                                                                         std::string name,
                                                                         std::string resourceType,
                                                                         ::Deployment::Properties property)
           : resourceUsage_ (std::move (resourceUsage))
           , resourcePort_ (std::move (resourcePort))
           , componentPort_ (std::move (componentPort))
           , name_ (std::move (name))
           , resourceType_ (std::move (resourceType))
           , property_ (std::move (property))
{
}

inline void Deployment::ImplementationRequirement::resourceUsage (const ::Deployment::ResourceUsageKinds& _resourceUsage) { this->resourceUsage_ = _resourceUsage; }
inline void Deployment::ImplementationRequirement::resourceUsage (::Deployment::ResourceUsageKinds&& _resourceUsage) { this->resourceUsage_ = std::move (_resourceUsage); }
inline const ::Deployment::ResourceUsageKinds& Deployment::ImplementationRequirement::resourceUsage (void) const { return this->resourceUsage_; }
inline ::Deployment::ResourceUsageKinds& Deployment::ImplementationRequirement::resourceUsage (void) { return this->resourceUsage_; }

inline void Deployment::ImplementationRequirement::resourcePort (const std::string& _resourcePort) { this->resourcePort_ = _resourcePort; }
inline void Deployment::ImplementationRequirement::resourcePort (std::string&& _resourcePort) { this->resourcePort_ = std::move (_resourcePort); }
inline const std::string& Deployment::ImplementationRequirement::resourcePort (void) const { return this->resourcePort_; }
inline std::string& Deployment::ImplementationRequirement::resourcePort (void) { return this->resourcePort_; }

inline void Deployment::ImplementationRequirement::componentPort (const std::string& _componentPort) { this->componentPort_ = _componentPort; }
inline void Deployment::ImplementationRequirement::componentPort (std::string&& _componentPort) { this->componentPort_ = std::move (_componentPort); }
inline const std::string& Deployment::ImplementationRequirement::componentPort (void) const { return this->componentPort_; }
inline std::string& Deployment::ImplementationRequirement::componentPort (void) { return this->componentPort_; }

inline void Deployment::ImplementationRequirement::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ImplementationRequirement::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ImplementationRequirement::name (void) const { return this->name_; }
inline std::string& Deployment::ImplementationRequirement::name (void) { return this->name_; }

inline void Deployment::ImplementationRequirement::resourceType (const std::string& _resourceType) { this->resourceType_ = _resourceType; }
inline void Deployment::ImplementationRequirement::resourceType (std::string&& _resourceType) { this->resourceType_ = std::move (_resourceType); }
inline const std::string& Deployment::ImplementationRequirement::resourceType (void) const { return this->resourceType_; }
inline std::string& Deployment::ImplementationRequirement::resourceType (void) { return this->resourceType_; }

inline void Deployment::ImplementationRequirement::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::ImplementationRequirement::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::ImplementationRequirement::property (void) const { return this->property_; }
inline ::Deployment::Properties& Deployment::ImplementationRequirement::property (void) { return this->property_; }

inline ::Deployment::ImplementationRequirement& Deployment::ImplementationRequirement::operator= (const ::Deployment::ImplementationRequirement& x)
{
  if (this != &x) {
    this->resourceUsage_ = x.resourceUsage_;
    this->resourcePort_ = x.resourcePort_;
    this->componentPort_ = x.componentPort_;
    this->name_ = x.name_;
    this->resourceType_ = x.resourceType_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::ImplementationRequirement& Deployment::ImplementationRequirement::operator= (::Deployment::ImplementationRequirement&& x)
{
  this->resourceUsage_ = std::move (x.resourceUsage_);
  this->resourcePort_ = std::move (x.resourcePort_);
  this->componentPort_ = std::move (x.componentPort_);
  this->name_ = std::move (x.name_);
  this->resourceType_ = std::move (x.resourceType_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::ImplementationRequirement::swap (::Deployment::ImplementationRequirement& s)
{
  std::swap (this->resourceUsage_, s.resourceUsage_);
  std::swap (this->resourcePort_, s.resourcePort_);
  std::swap (this->componentPort_, s.componentPort_);
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Deployment::Capability::Capability ()
           : name_ (std::string())
           , resourceType_ (std::vector < std::string> ())
           , property_ (std::vector < ::Deployment::SatisfierProperty> ())
{
}
inline Deployment::Capability::Capability (std::string name,
                                           ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType,
                                           ::Deployment::SatisfierProperties property)
           : name_ (std::move (name))
           , resourceType_ (std::move (resourceType))
           , property_ (std::move (property))
{
}

inline void Deployment::Capability::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::Capability::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::Capability::name (void) const { return this->name_; }
inline std::string& Deployment::Capability::name (void) { return this->name_; }

inline void Deployment::Capability::resourceType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _resourceType) { this->resourceType_ = _resourceType; }
inline void Deployment::Capability::resourceType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _resourceType) { this->resourceType_ = std::move (_resourceType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::Capability::resourceType (void) const { return this->resourceType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::Capability::resourceType (void) { return this->resourceType_; }

inline void Deployment::Capability::property (const ::Deployment::SatisfierProperties& _property) { this->property_ = _property; }
inline void Deployment::Capability::property (::Deployment::SatisfierProperties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::SatisfierProperties& Deployment::Capability::property (void) const { return this->property_; }
inline ::Deployment::SatisfierProperties& Deployment::Capability::property (void) { return this->property_; }

inline ::Deployment::Capability& Deployment::Capability::operator= (const ::Deployment::Capability& x)
{
  if (this != &x) {
    this->name_ = x.name_;
    this->resourceType_ = x.resourceType_;
    this->property_ = x.property_;
  }
  return *this;
}
inline ::Deployment::Capability& Deployment::Capability::operator= (::Deployment::Capability&& x)
{
  this->name_ = std::move (x.name_);
  this->resourceType_ = std::move (x.resourceType_);
  this->property_ = std::move (x.property_);
  return *this;
}

inline void Deployment::Capability::swap (::Deployment::Capability& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Property& m1, ::Deployment::Property& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Requirement& m1, ::Deployment::Requirement& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::SatisfierProperty& m1, ::Deployment::SatisfierProperty& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPortDescription& m1, ::Deployment::ComponentPortDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPropertyDescription& m1, ::Deployment::ComponentPropertyDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentInterfaceDescription& m1, ::Deployment::ComponentInterfaceDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::MonolithicDeploymentDescription& m1, ::Deployment::MonolithicDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::InstanceResourceDeploymentDescription& m1, ::Deployment::InstanceResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::InstanceDeploymentDescription& m1, ::Deployment::InstanceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentExternalPortEndpoint& m1, ::Deployment::ComponentExternalPortEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanSubcomponentPortEndpoint& m1, ::Deployment::PlanSubcomponentPortEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ExternalReferenceEndpoint& m1, ::Deployment::ExternalReferenceEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ConnectionResourceDeploymentDescription& m1, ::Deployment::ConnectionResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanConnectionDescription& m1, ::Deployment::PlanConnectionDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanSubcomponentPropertyReference& m1, ::Deployment::PlanSubcomponentPropertyReference& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanPropertyMapping& m1, ::Deployment::PlanPropertyMapping& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ImplementationDependency& m1, ::Deployment::ImplementationDependency& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ResourceDeploymentDescription& m1, ::Deployment::ResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ArtifactDeploymentDescription& m1, ::Deployment::ArtifactDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanLocality& m1, ::Deployment::PlanLocality& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::DeploymentPlan& m1, ::Deployment::DeploymentPlan& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPackageReference& m1, ::Deployment::ComponentPackageReference& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ImplementationRequirement& m1, ::Deployment::ImplementationRequirement& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Capability& m1, ::Deployment::Capability& m2)
  {
    m1.swap (m2);
  }
}; // std

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::Property &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::Properties&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::Requirement &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::Requirements&);

// generated from c++/cli_hdr/enum_os.erb
std::ostream& operator<< (std::ostream& , Deployment::SatisfierPropertyKind);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::SatisfierProperty &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::SatisfierProperties&);

// generated from c++/cli_hdr/enum_os.erb
std::ostream& operator<< (std::ostream& , Deployment::CCMComponentPortKind);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ComponentPortDescription &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ComponentPortDescriptions&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ComponentPropertyDescription &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ComponentPropertyDescriptions&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ComponentInterfaceDescription &);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::MonolithicDeploymentDescription &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::MonolithicDeploymentDescriptions&);

// generated from c++/cli_hdr/enum_os.erb
std::ostream& operator<< (std::ostream& , Deployment::ResourceUsageKind);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::InstanceResourceDeploymentDescription &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::InstanceResourceDeploymentDescriptions&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::InstanceDeploymentDescription &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::InstanceDeploymentDescriptions&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ComponentExternalPortEndpoint &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ComponentExternalPortEndpoints&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::PlanSubcomponentPortEndpoint &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::PlanSubcomponentPortEndpoints&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ExternalReferenceEndpoint &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ExternalReferenceEndpoints&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ConnectionResourceDeploymentDescription &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ConnectionResourceDeploymentDescriptions&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::PlanConnectionDescription &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::PlanConnectionDescriptions&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::PlanSubcomponentPropertyReference &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::PlanSubcomponentPropertyReferences&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::PlanPropertyMapping &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::PlanPropertyMappings&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ImplementationDependency &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ImplementationDependencies&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ResourceDeploymentDescription &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ResourceDeploymentDescriptions&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ArtifactDeploymentDescription &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ArtifactDeploymentDescriptions&);

// generated from c++/cli_hdr/enum_os.erb
std::ostream& operator<< (std::ostream& , Deployment::PlanLocalityKind);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::PlanLocality &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::PlanLocalities&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::DeploymentPlan &);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ComponentPackageReference &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ComponentPackageReferences&);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ResourceUsageKinds&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::ImplementationRequirement &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::ImplementationRequirements&);

// generated from c++/cli_hdr/struct_os.erb
std::ostream& operator<< (std::ostream &, const Deployment::Capability &);

// generated from c++/cli_hdr/sequence_os.erb
std::ostream& operator<< (std::ostream& , const ::Deployment::Capabilities&);

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::Property &_aggregate)
{
  strm << "Deployment::Property ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    << _aggregate.value ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PROPERTY__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PROPERTY__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::Properties& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::Property& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PROPERTY__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::Requirement &_aggregate)
{
  strm << "Deployment::Requirement ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    <<  "\"" <<  _aggregate.resourceType () << "\"" << ","
    << _aggregate.property ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_REQUIREMENT__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_REQUIREMENT__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::Requirements& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::Requirement& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_REQUIREMENT__DECL__

// generated from c++/cli_hdr/enum_os.erb
inline std::ostream& operator<< (std::ostream& strm , Deployment::SatisfierPropertyKind _enumerator)
{
  switch (_enumerator){
    case Deployment::SatisfierPropertyKind::Quantity: return strm << "Deployment::SatisfierPropertyKind::Quantity"; break;
    case Deployment::SatisfierPropertyKind::Capacity: return strm << "Deployment::SatisfierPropertyKind::Capacity"; break;
    case Deployment::SatisfierPropertyKind::Minimum: return strm << "Deployment::SatisfierPropertyKind::Minimum"; break;
    case Deployment::SatisfierPropertyKind::Maximum: return strm << "Deployment::SatisfierPropertyKind::Maximum"; break;
    case Deployment::SatisfierPropertyKind::Attribute: return strm << "Deployment::SatisfierPropertyKind::Attribute"; break;
    case Deployment::SatisfierPropertyKind::Selection: return strm << "Deployment::SatisfierPropertyKind::Selection"; break;
    default: return strm;
  }
}

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::SatisfierProperty &_aggregate)
{
  strm << "Deployment::SatisfierProperty ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    << _aggregate.kind ()<< ","
    << (_aggregate.dynamic ()? "true" : "false")<< ","
    << _aggregate.value ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_SATISFIERPROPERTY__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_SATISFIERPROPERTY__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::SatisfierProperties& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::SatisfierProperty& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_SATISFIERPROPERTY__DECL__

// generated from c++/cli_hdr/enum_os.erb
inline std::ostream& operator<< (std::ostream& strm , Deployment::CCMComponentPortKind _enumerator)
{
  switch (_enumerator){
    case Deployment::CCMComponentPortKind::Facet: return strm << "Deployment::CCMComponentPortKind::Facet"; break;
    case Deployment::CCMComponentPortKind::SimplexReceptacle: return strm << "Deployment::CCMComponentPortKind::SimplexReceptacle"; break;
    case Deployment::CCMComponentPortKind::MultiplexReceptacle: return strm << "Deployment::CCMComponentPortKind::MultiplexReceptacle"; break;
    case Deployment::CCMComponentPortKind::EventEmitter: return strm << "Deployment::CCMComponentPortKind::EventEmitter"; break;
    case Deployment::CCMComponentPortKind::EventPublisher: return strm << "Deployment::CCMComponentPortKind::EventPublisher"; break;
    case Deployment::CCMComponentPortKind::EventConsumer: return strm << "Deployment::CCMComponentPortKind::EventConsumer"; break;
    case Deployment::CCMComponentPortKind::ExtendedPort: return strm << "Deployment::CCMComponentPortKind::ExtendedPort"; break;
    case Deployment::CCMComponentPortKind::MirrorPort: return strm << "Deployment::CCMComponentPortKind::MirrorPort"; break;
    default: return strm;
  }
}

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ComponentPortDescription &_aggregate)
{
  strm << "Deployment::ComponentPortDescription ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    <<  "\"" <<  _aggregate.specificType () << "\"" << ","
    << _aggregate.supportedType ()<< ","
    << (_aggregate.provider ()? "true" : "false")<< ","
    << (_aggregate.exclusiveProvider ()? "true" : "false")<< ","
    << (_aggregate.exclusiveUser ()? "true" : "false")<< ","
    << (_aggregate.optional ()? "true" : "false")<< ","
    << _aggregate.kind ()<< ","
    << _aggregate.templateParam ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTPORTDESCRIPTION__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTPORTDESCRIPTION__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ComponentPortDescriptions& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ComponentPortDescription& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTPORTDESCRIPTION__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ComponentPropertyDescription &_aggregate)
{
  strm << "Deployment::ComponentPropertyDescription ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    << _aggregate.type ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ComponentPropertyDescriptions& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ComponentPropertyDescription& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ComponentInterfaceDescription &_aggregate)
{
  strm << "Deployment::ComponentInterfaceDescription ("
    <<  "\"" <<  _aggregate.label () << "\"" << ","
    <<  "\"" <<  _aggregate.UUID () << "\"" << ","
    <<  "\"" <<  _aggregate.specificType () << "\"" << ","
    << _aggregate.supportedType ()<< ","
    << _aggregate.idlFile ()<< ","
    << _aggregate.configProperty ()<< ","
    << _aggregate.port ()<< ","
    << _aggregate.property ()<< ","
    << _aggregate.infoProperty ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::MonolithicDeploymentDescription &_aggregate)
{
  strm << "Deployment::MonolithicDeploymentDescription ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    << _aggregate.source ()<< ","
    << _aggregate.artifactRef ()<< ","
    << _aggregate.execParameter ()<< ","
    << _aggregate.deployRequirement ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::MonolithicDeploymentDescriptions& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::MonolithicDeploymentDescription& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION__DECL__

// generated from c++/cli_hdr/enum_os.erb
inline std::ostream& operator<< (std::ostream& strm , Deployment::ResourceUsageKind _enumerator)
{
  switch (_enumerator){
    case Deployment::ResourceUsageKind::None: return strm << "Deployment::ResourceUsageKind::None"; break;
    case Deployment::ResourceUsageKind::InstanceUsesResource: return strm << "Deployment::ResourceUsageKind::InstanceUsesResource"; break;
    case Deployment::ResourceUsageKind::ResourceUsesInstance: return strm << "Deployment::ResourceUsageKind::ResourceUsesInstance"; break;
    case Deployment::ResourceUsageKind::PortUsesResource: return strm << "Deployment::ResourceUsageKind::PortUsesResource"; break;
    case Deployment::ResourceUsageKind::ResourceUsesPort: return strm << "Deployment::ResourceUsageKind::ResourceUsesPort"; break;
    default: return strm;
  }
}

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::InstanceResourceDeploymentDescription &_aggregate)
{
  strm << "Deployment::InstanceResourceDeploymentDescription ("
    << _aggregate.resourceUsage ()<< ","
    <<  "\"" <<  _aggregate.requirementName () << "\"" << ","
    <<  "\"" <<  _aggregate.resourceName () << "\"" << ","
    << _aggregate.property ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::InstanceResourceDeploymentDescriptions& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::InstanceResourceDeploymentDescription& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::InstanceDeploymentDescription &_aggregate)
{
  strm << "Deployment::InstanceDeploymentDescription ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    <<  "\"" <<  _aggregate.node () << "\"" << ","
    << _aggregate.source ()<< ","
    << _aggregate.implementationRef ()<< ","
    << _aggregate.configProperty ()<< ","
    << _aggregate.deployedResource ()<< ","
    << _aggregate.deployedSharedResource ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::InstanceDeploymentDescriptions& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::InstanceDeploymentDescription& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ComponentExternalPortEndpoint &_aggregate)
{
  strm << "Deployment::ComponentExternalPortEndpoint ("
    <<  "\"" <<  _aggregate.portName () << "\"" 
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ComponentExternalPortEndpoints& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ComponentExternalPortEndpoint& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::PlanSubcomponentPortEndpoint &_aggregate)
{
  strm << "Deployment::PlanSubcomponentPortEndpoint ("
    <<  "\"" <<  _aggregate.portName () << "\"" << ","
    << (_aggregate.provider ()? "true" : "false")<< ","
    << _aggregate.kind ()<< ","
    << _aggregate.instanceRef ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::PlanSubcomponentPortEndpoints& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::PlanSubcomponentPortEndpoint& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ExternalReferenceEndpoint &_aggregate)
{
  strm << "Deployment::ExternalReferenceEndpoint ("
    <<  "\"" <<  _aggregate.location () << "\"" << ","
    << (_aggregate.provider ()? "true" : "false")<< ","
    <<  "\"" <<  _aggregate.portName () << "\"" << ","
    << _aggregate.supportedType ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_EXTERNALREFERENCEENDPOINT__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_EXTERNALREFERENCEENDPOINT__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ExternalReferenceEndpoints& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ExternalReferenceEndpoint& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_EXTERNALREFERENCEENDPOINT__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ConnectionResourceDeploymentDescription &_aggregate)
{
  strm << "Deployment::ConnectionResourceDeploymentDescription ("
    <<  "\"" <<  _aggregate.targetName () << "\"" << ","
    <<  "\"" <<  _aggregate.requirementName () << "\"" << ","
    <<  "\"" <<  _aggregate.resourceName () << "\"" << ","
    << _aggregate.property ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ConnectionResourceDeploymentDescriptions& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ConnectionResourceDeploymentDescription& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::PlanConnectionDescription &_aggregate)
{
  strm << "Deployment::PlanConnectionDescription ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    << _aggregate.source ()<< ","
    << _aggregate.deployRequirement ()<< ","
    << _aggregate.externalEndpoint ()<< ","
    << _aggregate.internalEndpoint ()<< ","
    << _aggregate.externalReference ()<< ","
    << _aggregate.deployedResource ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANCONNECTIONDESCRIPTION__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANCONNECTIONDESCRIPTION__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::PlanConnectionDescriptions& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::PlanConnectionDescription& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANCONNECTIONDESCRIPTION__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::PlanSubcomponentPropertyReference &_aggregate)
{
  strm << "Deployment::PlanSubcomponentPropertyReference ("
    <<  "\"" <<  _aggregate.propertyName () << "\"" << ","
    << _aggregate.instanceRef ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::PlanSubcomponentPropertyReferences& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::PlanSubcomponentPropertyReference& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::PlanPropertyMapping &_aggregate)
{
  strm << "Deployment::PlanPropertyMapping ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    << _aggregate.source ()<< ","
    <<  "\"" <<  _aggregate.externalName () << "\"" << ","
    << _aggregate.delegatesTo ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANPROPERTYMAPPING__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANPROPERTYMAPPING__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::PlanPropertyMappings& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::PlanPropertyMapping& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANPROPERTYMAPPING__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ImplementationDependency &_aggregate)
{
  strm << "Deployment::ImplementationDependency ("
    <<  "\"" <<  _aggregate.requiredType () << "\"" 
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ImplementationDependencies& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ImplementationDependency& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ResourceDeploymentDescription &_aggregate)
{
  strm << "Deployment::ResourceDeploymentDescription ("
    <<  "\"" <<  _aggregate.requirementName () << "\"" << ","
    <<  "\"" <<  _aggregate.resourceName () << "\"" << ","
    << _aggregate.property ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ResourceDeploymentDescriptions& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ResourceDeploymentDescription& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ArtifactDeploymentDescription &_aggregate)
{
  strm << "Deployment::ArtifactDeploymentDescription ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    << _aggregate.location ()<< ","
    <<  "\"" <<  _aggregate.node () << "\"" << ","
    << _aggregate.source ()<< ","
    << _aggregate.execParameter ()<< ","
    << _aggregate.deployRequirement ()<< ","
    << _aggregate.deployedResource ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ArtifactDeploymentDescriptions& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ArtifactDeploymentDescription& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION__DECL__

// generated from c++/cli_hdr/enum_os.erb
inline std::ostream& operator<< (std::ostream& strm , Deployment::PlanLocalityKind _enumerator)
{
  switch (_enumerator){
    case Deployment::PlanLocalityKind::PlanSameProcess: return strm << "Deployment::PlanLocalityKind::PlanSameProcess"; break;
    case Deployment::PlanLocalityKind::PlanDifferentProcess: return strm << "Deployment::PlanLocalityKind::PlanDifferentProcess"; break;
    case Deployment::PlanLocalityKind::PlanNoConstraint: return strm << "Deployment::PlanLocalityKind::PlanNoConstraint"; break;
    default: return strm;
  }
}

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::PlanLocality &_aggregate)
{
  strm << "Deployment::PlanLocality ("
    << _aggregate.constraint ()<< ","
    << _aggregate.constrainedInstanceRef ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANLOCALITY__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANLOCALITY__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::PlanLocalities& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::PlanLocality& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_PLANLOCALITY__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::DeploymentPlan &_aggregate)
{
  strm << "Deployment::DeploymentPlan ("
    <<  "\"" <<  _aggregate.label () << "\"" << ","
    <<  "\"" <<  _aggregate.UUID () << "\"" << ","
    << _aggregate.realizes ()<< ","
    << _aggregate.implementation ()<< ","
    << _aggregate.instance ()<< ","
    << _aggregate.connection ()<< ","
    << _aggregate.externalProperty ()<< ","
    << _aggregate.dependsOn ()<< ","
    << _aggregate.artifact ()<< ","
    << _aggregate.infoProperty ()<< ","
    << _aggregate.localityConstraint ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ComponentPackageReference &_aggregate)
{
  strm << "Deployment::ComponentPackageReference ("
    <<  "\"" <<  _aggregate.requiredUUID () << "\"" << ","
    <<  "\"" <<  _aggregate.requiredName () << "\"" << ","
    << _aggregate.requiredType ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTPACKAGEREFERENCE__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTPACKAGEREFERENCE__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ComponentPackageReferences& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ComponentPackageReference& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_COMPONENTPACKAGEREFERENCE__DECL__

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_RESOURCEUSAGEKIND__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_RESOURCEUSAGEKIND__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ResourceUsageKinds& _v)
{
  strm << "[";
  bool first = true;
  for (::Deployment::ResourceUsageKind _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_RESOURCEUSAGEKIND__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::ImplementationRequirement &_aggregate)
{
  strm << "Deployment::ImplementationRequirement ("
    << _aggregate.resourceUsage ()<< ","
    <<  "\"" <<  _aggregate.resourcePort () << "\"" << ","
    <<  "\"" <<  _aggregate.componentPort () << "\"" << ","
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    <<  "\"" <<  _aggregate.resourceType () << "\"" << ","
    << _aggregate.property ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::ImplementationRequirements& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::ImplementationRequirement& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT__DECL__

// generated from c++/cli_hdr/struct_os.erb
inline std::ostream& operator<< (
    std::ostream &strm,
    const Deployment::Capability &_aggregate)
{
  strm << "Deployment::Capability ("
    <<  "\"" <<  _aggregate.name () << "\"" << ","
    << _aggregate.resourceType ()<< ","
    << _aggregate.property ()
  << ")";
  return strm;
}

// generated from c++/cli_hdr/sequence_os.erb
#if !defined (__TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_CAPABILITY__DECL__)
#define __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_CAPABILITY__DECL__
inline std::ostream& operator<< (std::ostream& strm , const ::Deployment::Capabilities& _v)
{
  strm << "[";
  bool first = true;
  for (const ::Deployment::Capability& _ve : _v) {
  if(!first)
    strm << ',';
  first = false;
  strm << _ve ; }
  strm << "]";
  return strm;
}

#endif // __TAOX11_OSSTREAM_STD_VECTOR_DEPLOYMENT_CAPABILITY__DECL__

// generated from c++/cli_hdr/post.erb
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testP.h"
#endif

#include /**/ "ace/post.h"

#endif // __RIDL_TESTC_H_INCLUDED__

// -*- END -*-
