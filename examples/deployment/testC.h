// -*- C++ -*-
/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT
 *        Nijkerk, GLD
 *        The Netherlands
 *        http://www.remedy.nl \ http://www.theaceorb.nl
 */

#ifndef __RIDL_TESTC_H_HFCDCFJD_INCLUDED__
#define __RIDL_TESTC_H_HFCDCFJD_INCLUDED__


#include /**/ "ace/pre.h"

#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/anytypecode/any.h"
#include "tao/x11/corba_ostream.h"

#include "tao/x11/versionx11.h"

#if TAOX11_MAJOR_VERSION != 1 || TAOX11_MINOR_VERSION != 3 || TAOX11_BETA_VERSION != 2
#error This file was generated with another RIDL C++11 backend version (1.3.2). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from StubHeaderWriter#enter_module
/// @copydoc Deployment
namespace Deployment
{

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::Property
  class Property
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    Property () = default;
    /// Destructor
    ~Property () = default;
    /// Copy constructor
    Property (const Property&) = default;
    /// Move constructor
    Property (Property&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Property (
      std::string name,
      TAOX11_NAMESPACE::CORBA::Any value);
    /// Copy assignment operator
    Property& operator= (const Property&) = default;
    /// Move assignment operator
    Property& operator= (Property&&) = default;

    /// @copydoc Deployment::Property::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::Property::value
    //@{
    inline void value (const TAOX11_NAMESPACE::CORBA::Any& _value);
    inline void value (TAOX11_NAMESPACE::CORBA::Any&& _value);
    inline const TAOX11_NAMESPACE::CORBA::Any& value () const;
    inline TAOX11_NAMESPACE::CORBA::Any& value ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (Property& s);

  private:
    std::string name_;
    TAOX11_NAMESPACE::CORBA::Any value_;
  };// Property

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::Properties
  typedef std::vector < Property> Properties;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::Requirement
  class Requirement
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    Requirement () = default;
    /// Destructor
    ~Requirement () = default;
    /// Copy constructor
    Requirement (const Requirement&) = default;
    /// Move constructor
    Requirement (Requirement&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Requirement (
      std::string name,
      std::string resourceType,
      ::Deployment::Properties property);
    /// Copy assignment operator
    Requirement& operator= (const Requirement&) = default;
    /// Move assignment operator
    Requirement& operator= (Requirement&&) = default;

    /// @copydoc Deployment::Requirement::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::Requirement::resourceType
    //@{
    inline void resourceType (const std::string& _resourceType);
    inline void resourceType (std::string&& _resourceType);
    inline const std::string& resourceType () const;
    inline std::string& resourceType ();
    //@}

    /// @copydoc Deployment::Requirement::property
    //@{
    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (Requirement& s);

  private:
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  };// Requirement

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::Requirements
  typedef std::vector < Requirement> Requirements;

  // generated from c++11/templates/cli/hdr/enum.erb

  /// @copydoc Deployment::SatisfierPropertyKind
  enum class SatisfierPropertyKind : uint32_t
  {
    /// @copydoc Deployment::SatisfierPropertyKind::Quantity
    Quantity,
    /// @copydoc Deployment::SatisfierPropertyKind::Capacity
    Capacity,
    /// @copydoc Deployment::SatisfierPropertyKind::Minimum
    Minimum,
    /// @copydoc Deployment::SatisfierPropertyKind::Maximum
    Maximum,
    /// @copydoc Deployment::SatisfierPropertyKind::Attribute
    Attribute,
    /// @copydoc Deployment::SatisfierPropertyKind::Selection
    Selection
  };// SatisfierPropertyKind


  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::SatisfierProperty
  class SatisfierProperty
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    SatisfierProperty () = default;
    /// Destructor
    ~SatisfierProperty () = default;
    /// Copy constructor
    SatisfierProperty (const SatisfierProperty&) = default;
    /// Move constructor
    SatisfierProperty (SatisfierProperty&&) = default;
    /// Constructor which accepts value for all members
    explicit inline SatisfierProperty (
      std::string name,
      ::Deployment::SatisfierPropertyKind kind,
      bool dynamic,
      TAOX11_NAMESPACE::CORBA::Any value);
    /// Copy assignment operator
    SatisfierProperty& operator= (const SatisfierProperty&) = default;
    /// Move assignment operator
    SatisfierProperty& operator= (SatisfierProperty&&) = default;

    /// @copydoc Deployment::SatisfierProperty::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::SatisfierProperty::kind
    //@{
    inline void kind (::Deployment::SatisfierPropertyKind _kind);
    inline ::Deployment::SatisfierPropertyKind kind () const;
    inline ::Deployment::SatisfierPropertyKind& kind ();
    //@}

    /// @copydoc Deployment::SatisfierProperty::dynamic
    //@{
    inline void dynamic (bool _dynamic);
    inline bool dynamic () const;
    inline bool& dynamic ();
    //@}

    /// @copydoc Deployment::SatisfierProperty::value
    //@{
    inline void value (const TAOX11_NAMESPACE::CORBA::Any& _value);
    inline void value (TAOX11_NAMESPACE::CORBA::Any&& _value);
    inline const TAOX11_NAMESPACE::CORBA::Any& value () const;
    inline TAOX11_NAMESPACE::CORBA::Any& value ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (SatisfierProperty& s);

  private:
    std::string name_;
    ::Deployment::SatisfierPropertyKind kind_ {};
    bool dynamic_ {};
    TAOX11_NAMESPACE::CORBA::Any value_;
  };// SatisfierProperty

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::SatisfierProperties
  typedef std::vector < SatisfierProperty> SatisfierProperties;
} // namespace Deployment


// generated from StubHeaderWriter#enter_module
/// @copydoc Deployment
namespace Deployment
{

  // generated from c++11/templates/cli/hdr/enum.erb

  /// @copydoc Deployment::CCMComponentPortKind
  enum class CCMComponentPortKind : uint32_t
  {
    /// @copydoc Deployment::CCMComponentPortKind::Facet
    Facet,
    /// @copydoc Deployment::CCMComponentPortKind::SimplexReceptacle
    SimplexReceptacle,
    /// @copydoc Deployment::CCMComponentPortKind::MultiplexReceptacle
    MultiplexReceptacle,
    /// @copydoc Deployment::CCMComponentPortKind::EventEmitter
    EventEmitter,
    /// @copydoc Deployment::CCMComponentPortKind::EventPublisher
    EventPublisher,
    /// @copydoc Deployment::CCMComponentPortKind::EventConsumer
    EventConsumer,
    /// @copydoc Deployment::CCMComponentPortKind::ExtendedPort
    ExtendedPort,
    /// @copydoc Deployment::CCMComponentPortKind::MirrorPort
    MirrorPort
  };// CCMComponentPortKind


  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ComponentPortDescription
  class ComponentPortDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ComponentPortDescription () = default;
    /// Destructor
    ~ComponentPortDescription () = default;
    /// Copy constructor
    ComponentPortDescription (const ComponentPortDescription&) = default;
    /// Move constructor
    ComponentPortDescription (ComponentPortDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentPortDescription (
      std::string name,
      std::string specificType,
      ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
      bool provider,
      bool exclusiveProvider,
      bool exclusiveUser,
      bool optional,
      ::Deployment::CCMComponentPortKind kind,
      ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam);
    /// Copy assignment operator
    ComponentPortDescription& operator= (const ComponentPortDescription&) = default;
    /// Move assignment operator
    ComponentPortDescription& operator= (ComponentPortDescription&&) = default;

    /// @copydoc Deployment::ComponentPortDescription::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::ComponentPortDescription::specificType
    //@{
    inline void specificType (const std::string& _specificType);
    inline void specificType (std::string&& _specificType);
    inline const std::string& specificType () const;
    inline std::string& specificType ();
    //@}

    /// @copydoc Deployment::ComponentPortDescription::supportedType
    //@{
    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType ();
    //@}

    /// @copydoc Deployment::ComponentPortDescription::provider
    //@{
    inline void provider (bool _provider);
    inline bool provider () const;
    inline bool& provider ();
    //@}

    /// @copydoc Deployment::ComponentPortDescription::exclusiveProvider
    //@{
    inline void exclusiveProvider (bool _exclusiveProvider);
    inline bool exclusiveProvider () const;
    inline bool& exclusiveProvider ();
    //@}

    /// @copydoc Deployment::ComponentPortDescription::exclusiveUser
    //@{
    inline void exclusiveUser (bool _exclusiveUser);
    inline bool exclusiveUser () const;
    inline bool& exclusiveUser ();
    //@}

    /// @copydoc Deployment::ComponentPortDescription::optional
    //@{
    inline void optional (bool _optional);
    inline bool optional () const;
    inline bool& optional ();
    //@}

    /// @copydoc Deployment::ComponentPortDescription::kind
    //@{
    inline void kind (::Deployment::CCMComponentPortKind _kind);
    inline ::Deployment::CCMComponentPortKind kind () const;
    inline ::Deployment::CCMComponentPortKind& kind ();
    //@}

    /// @copydoc Deployment::ComponentPortDescription::templateParam
    //@{
    inline void templateParam (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _templateParam);
    inline void templateParam (::TAOX11_NAMESPACE::CORBA::StringSeq&& _templateParam);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentPortDescription& s);

  private:
    std::string name_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    bool provider_ {};
    bool exclusiveProvider_ {};
    bool exclusiveUser_ {};
    bool optional_ {};
    ::Deployment::CCMComponentPortKind kind_ {};
    ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam_;
  };// ComponentPortDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ComponentPortDescriptions
  typedef std::vector < ComponentPortDescription> ComponentPortDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ComponentPropertyDescription
  class ComponentPropertyDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ComponentPropertyDescription () = default;
    /// Destructor
    ~ComponentPropertyDescription () = default;
    /// Copy constructor
    ComponentPropertyDescription (const ComponentPropertyDescription&) = default;
    /// Move constructor
    ComponentPropertyDescription (ComponentPropertyDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentPropertyDescription (
      std::string name,
      TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type);
    /// Copy assignment operator
    ComponentPropertyDescription& operator= (const ComponentPropertyDescription&) = default;
    /// Move assignment operator
    ComponentPropertyDescription& operator= (ComponentPropertyDescription&&) = default;

    /// @copydoc Deployment::ComponentPropertyDescription::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::ComponentPropertyDescription::type
    //@{
    inline void type (TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type _type);
    inline TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type () const;
    inline TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type& type ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentPropertyDescription& s);

  private:
    std::string name_;
    TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type_;
  };// ComponentPropertyDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ComponentPropertyDescriptions
  typedef std::vector < ComponentPropertyDescription> ComponentPropertyDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ComponentInterfaceDescription
  class ComponentInterfaceDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ComponentInterfaceDescription () = default;
    /// Destructor
    ~ComponentInterfaceDescription () = default;
    /// Copy constructor
    ComponentInterfaceDescription (const ComponentInterfaceDescription&) = default;
    /// Move constructor
    ComponentInterfaceDescription (ComponentInterfaceDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentInterfaceDescription (
      std::string label,
      std::string UUID,
      std::string specificType,
      ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
      ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile,
      ::Deployment::Properties configProperty,
      ::Deployment::ComponentPortDescriptions port,
      ::Deployment::ComponentPropertyDescriptions property,
      ::Deployment::Properties infoProperty);
    /// Copy assignment operator
    ComponentInterfaceDescription& operator= (const ComponentInterfaceDescription&) = default;
    /// Move assignment operator
    ComponentInterfaceDescription& operator= (ComponentInterfaceDescription&&) = default;

    /// @copydoc Deployment::ComponentInterfaceDescription::label
    //@{
    inline void label (const std::string& _label);
    inline void label (std::string&& _label);
    inline const std::string& label () const;
    inline std::string& label ();
    //@}

    /// @copydoc Deployment::ComponentInterfaceDescription::UUID
    //@{
    inline void UUID (const std::string& _UUID);
    inline void UUID (std::string&& _UUID);
    inline const std::string& UUID () const;
    inline std::string& UUID ();
    //@}

    /// @copydoc Deployment::ComponentInterfaceDescription::specificType
    //@{
    inline void specificType (const std::string& _specificType);
    inline void specificType (std::string&& _specificType);
    inline const std::string& specificType () const;
    inline std::string& specificType ();
    //@}

    /// @copydoc Deployment::ComponentInterfaceDescription::supportedType
    //@{
    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType ();
    //@}

    /// @copydoc Deployment::ComponentInterfaceDescription::idlFile
    //@{
    inline void idlFile (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _idlFile);
    inline void idlFile (::TAOX11_NAMESPACE::CORBA::StringSeq&& _idlFile);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile ();
    //@}

    /// @copydoc Deployment::ComponentInterfaceDescription::configProperty
    //@{
    inline void configProperty (const ::Deployment::Properties& _configProperty);
    inline void configProperty (::Deployment::Properties&& _configProperty);
    inline const ::Deployment::Properties& configProperty () const;
    inline ::Deployment::Properties& configProperty ();
    //@}

    /// @copydoc Deployment::ComponentInterfaceDescription::port
    //@{
    inline void port (const ::Deployment::ComponentPortDescriptions& _port);
    inline void port (::Deployment::ComponentPortDescriptions&& _port);
    inline const ::Deployment::ComponentPortDescriptions& port () const;
    inline ::Deployment::ComponentPortDescriptions& port ();
    //@}

    /// @copydoc Deployment::ComponentInterfaceDescription::property
    //@{
    inline void property (const ::Deployment::ComponentPropertyDescriptions& _property);
    inline void property (::Deployment::ComponentPropertyDescriptions&& _property);
    inline const ::Deployment::ComponentPropertyDescriptions& property () const;
    inline ::Deployment::ComponentPropertyDescriptions& property ();
    //@}

    /// @copydoc Deployment::ComponentInterfaceDescription::infoProperty
    //@{
    inline void infoProperty (const ::Deployment::Properties& _infoProperty);
    inline void infoProperty (::Deployment::Properties&& _infoProperty);
    inline const ::Deployment::Properties& infoProperty () const;
    inline ::Deployment::Properties& infoProperty ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentInterfaceDescription& s);

  private:
    std::string label_;
    std::string UUID_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile_;
    ::Deployment::Properties configProperty_;
    ::Deployment::ComponentPortDescriptions port_;
    ::Deployment::ComponentPropertyDescriptions property_;
    ::Deployment::Properties infoProperty_;
  };// ComponentInterfaceDescription

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::MonolithicDeploymentDescription
  class MonolithicDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    MonolithicDeploymentDescription () = default;
    /// Destructor
    ~MonolithicDeploymentDescription () = default;
    /// Copy constructor
    MonolithicDeploymentDescription (const MonolithicDeploymentDescription&) = default;
    /// Move constructor
    MonolithicDeploymentDescription (MonolithicDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline MonolithicDeploymentDescription (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef,
      ::Deployment::Properties execParameter,
      ::Deployment::Requirements deployRequirement);
    /// Copy assignment operator
    MonolithicDeploymentDescription& operator= (const MonolithicDeploymentDescription&) = default;
    /// Move assignment operator
    MonolithicDeploymentDescription& operator= (MonolithicDeploymentDescription&&) = default;

    /// @copydoc Deployment::MonolithicDeploymentDescription::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::MonolithicDeploymentDescription::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();
    //@}

    /// @copydoc Deployment::MonolithicDeploymentDescription::artifactRef
    //@{
    inline void artifactRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _artifactRef);
    inline void artifactRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _artifactRef);
    inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef () const;
    inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef ();
    //@}

    /// @copydoc Deployment::MonolithicDeploymentDescription::execParameter
    //@{
    inline void execParameter (const ::Deployment::Properties& _execParameter);
    inline void execParameter (::Deployment::Properties&& _execParameter);
    inline const ::Deployment::Properties& execParameter () const;
    inline ::Deployment::Properties& execParameter ();
    //@}

    /// @copydoc Deployment::MonolithicDeploymentDescription::deployRequirement
    //@{
    inline void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    inline void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    inline const ::Deployment::Requirements& deployRequirement () const;
    inline ::Deployment::Requirements& deployRequirement ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (MonolithicDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
  };// MonolithicDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::MonolithicDeploymentDescriptions
  typedef std::vector < MonolithicDeploymentDescription> MonolithicDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/enum.erb

  /// @copydoc Deployment::ResourceUsageKind
  enum class ResourceUsageKind : uint32_t
  {
    /// @copydoc Deployment::ResourceUsageKind::None
    None,
    /// @copydoc Deployment::ResourceUsageKind::InstanceUsesResource
    InstanceUsesResource,
    /// @copydoc Deployment::ResourceUsageKind::ResourceUsesInstance
    ResourceUsesInstance,
    /// @copydoc Deployment::ResourceUsageKind::PortUsesResource
    PortUsesResource,
    /// @copydoc Deployment::ResourceUsageKind::ResourceUsesPort
    ResourceUsesPort
  };// ResourceUsageKind


  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::InstanceResourceDeploymentDescription
  class InstanceResourceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    InstanceResourceDeploymentDescription () = default;
    /// Destructor
    ~InstanceResourceDeploymentDescription () = default;
    /// Copy constructor
    InstanceResourceDeploymentDescription (const InstanceResourceDeploymentDescription&) = default;
    /// Move constructor
    InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline InstanceResourceDeploymentDescription (
      ::Deployment::ResourceUsageKind resourceUsage,
      std::string requirementName,
      std::string resourceName,
      ::Deployment::Properties property);
    /// Copy assignment operator
    InstanceResourceDeploymentDescription& operator= (const InstanceResourceDeploymentDescription&) = default;
    /// Move assignment operator
    InstanceResourceDeploymentDescription& operator= (InstanceResourceDeploymentDescription&&) = default;

    /// @copydoc Deployment::InstanceResourceDeploymentDescription::resourceUsage
    //@{
    inline void resourceUsage (::Deployment::ResourceUsageKind _resourceUsage);
    inline ::Deployment::ResourceUsageKind resourceUsage () const;
    inline ::Deployment::ResourceUsageKind& resourceUsage ();
    //@}

    /// @copydoc Deployment::InstanceResourceDeploymentDescription::requirementName
    //@{
    inline void requirementName (const std::string& _requirementName);
    inline void requirementName (std::string&& _requirementName);
    inline const std::string& requirementName () const;
    inline std::string& requirementName ();
    //@}

    /// @copydoc Deployment::InstanceResourceDeploymentDescription::resourceName
    //@{
    inline void resourceName (const std::string& _resourceName);
    inline void resourceName (std::string&& _resourceName);
    inline const std::string& resourceName () const;
    inline std::string& resourceName ();
    //@}

    /// @copydoc Deployment::InstanceResourceDeploymentDescription::property
    //@{
    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (InstanceResourceDeploymentDescription& s);

  private:
    ::Deployment::ResourceUsageKind resourceUsage_ {};
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// InstanceResourceDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::InstanceResourceDeploymentDescriptions
  typedef std::vector < InstanceResourceDeploymentDescription> InstanceResourceDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::InstanceDeploymentDescription
  class InstanceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    InstanceDeploymentDescription () = default;
    /// Destructor
    ~InstanceDeploymentDescription () = default;
    /// Copy constructor
    InstanceDeploymentDescription (const InstanceDeploymentDescription&) = default;
    /// Move constructor
    InstanceDeploymentDescription (InstanceDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline InstanceDeploymentDescription (
      std::string name,
      std::string node,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      uint32_t implementationRef,
      ::Deployment::Properties configProperty,
      ::Deployment::InstanceResourceDeploymentDescriptions deployedResource,
      ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource);
    /// Copy assignment operator
    InstanceDeploymentDescription& operator= (const InstanceDeploymentDescription&) = default;
    /// Move assignment operator
    InstanceDeploymentDescription& operator= (InstanceDeploymentDescription&&) = default;

    /// @copydoc Deployment::InstanceDeploymentDescription::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::InstanceDeploymentDescription::node
    //@{
    inline void node (const std::string& _node);
    inline void node (std::string&& _node);
    inline const std::string& node () const;
    inline std::string& node ();
    //@}

    /// @copydoc Deployment::InstanceDeploymentDescription::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();
    //@}

    /// @copydoc Deployment::InstanceDeploymentDescription::implementationRef
    //@{
    inline void implementationRef (uint32_t _implementationRef);
    inline uint32_t implementationRef () const;
    inline uint32_t& implementationRef ();
    //@}

    /// @copydoc Deployment::InstanceDeploymentDescription::configProperty
    //@{
    inline void configProperty (const ::Deployment::Properties& _configProperty);
    inline void configProperty (::Deployment::Properties&& _configProperty);
    inline const ::Deployment::Properties& configProperty () const;
    inline ::Deployment::Properties& configProperty ();
    //@}

    /// @copydoc Deployment::InstanceDeploymentDescription::deployedResource
    //@{
    inline void deployedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedResource);
    inline void deployedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedResource);
    inline const ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource () const;
    inline ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource ();
    //@}

    /// @copydoc Deployment::InstanceDeploymentDescription::deployedSharedResource
    //@{
    inline void deployedSharedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedSharedResource);
    inline void deployedSharedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedSharedResource);
    inline const ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource () const;
    inline ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (InstanceDeploymentDescription& s);

  private:
    std::string name_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    uint32_t implementationRef_ {};
    ::Deployment::Properties configProperty_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedResource_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource_;
  };// InstanceDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::InstanceDeploymentDescriptions
  typedef std::vector < InstanceDeploymentDescription> InstanceDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ComponentExternalPortEndpoint
  class ComponentExternalPortEndpoint
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ComponentExternalPortEndpoint () = default;
    /// Destructor
    ~ComponentExternalPortEndpoint () = default;
    /// Copy constructor
    ComponentExternalPortEndpoint (const ComponentExternalPortEndpoint&) = default;
    /// Move constructor
    ComponentExternalPortEndpoint (ComponentExternalPortEndpoint&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentExternalPortEndpoint (
      std::string portName);
    /// Copy assignment operator
    ComponentExternalPortEndpoint& operator= (const ComponentExternalPortEndpoint&) = default;
    /// Move assignment operator
    ComponentExternalPortEndpoint& operator= (ComponentExternalPortEndpoint&&) = default;

    /// @copydoc Deployment::ComponentExternalPortEndpoint::portName
    //@{
    inline void portName (const std::string& _portName);
    inline void portName (std::string&& _portName);
    inline const std::string& portName () const;
    inline std::string& portName ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentExternalPortEndpoint& s);

  private:
    std::string portName_;
  };// ComponentExternalPortEndpoint

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ComponentExternalPortEndpoints
  typedef std::vector < ComponentExternalPortEndpoint> ComponentExternalPortEndpoints;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::PlanSubcomponentPortEndpoint
  class PlanSubcomponentPortEndpoint
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    PlanSubcomponentPortEndpoint () = default;
    /// Destructor
    ~PlanSubcomponentPortEndpoint () = default;
    /// Copy constructor
    PlanSubcomponentPortEndpoint (const PlanSubcomponentPortEndpoint&) = default;
    /// Move constructor
    PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanSubcomponentPortEndpoint (
      std::string portName,
      bool provider,
      ::Deployment::CCMComponentPortKind kind,
      uint32_t instanceRef);
    /// Copy assignment operator
    PlanSubcomponentPortEndpoint& operator= (const PlanSubcomponentPortEndpoint&) = default;
    /// Move assignment operator
    PlanSubcomponentPortEndpoint& operator= (PlanSubcomponentPortEndpoint&&) = default;

    /// @copydoc Deployment::PlanSubcomponentPortEndpoint::portName
    //@{
    inline void portName (const std::string& _portName);
    inline void portName (std::string&& _portName);
    inline const std::string& portName () const;
    inline std::string& portName ();
    //@}

    /// @copydoc Deployment::PlanSubcomponentPortEndpoint::provider
    //@{
    inline void provider (bool _provider);
    inline bool provider () const;
    inline bool& provider ();
    //@}

    /// @copydoc Deployment::PlanSubcomponentPortEndpoint::kind
    //@{
    inline void kind (::Deployment::CCMComponentPortKind _kind);
    inline ::Deployment::CCMComponentPortKind kind () const;
    inline ::Deployment::CCMComponentPortKind& kind ();
    //@}

    /// @copydoc Deployment::PlanSubcomponentPortEndpoint::instanceRef
    //@{
    inline void instanceRef (uint32_t _instanceRef);
    inline uint32_t instanceRef () const;
    inline uint32_t& instanceRef ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanSubcomponentPortEndpoint& s);

  private:
    std::string portName_;
    bool provider_ {};
    ::Deployment::CCMComponentPortKind kind_ {};
    uint32_t instanceRef_ {};
  };// PlanSubcomponentPortEndpoint

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::PlanSubcomponentPortEndpoints
  typedef std::vector < PlanSubcomponentPortEndpoint> PlanSubcomponentPortEndpoints;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ExternalReferenceEndpoint
  class ExternalReferenceEndpoint
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ExternalReferenceEndpoint () = default;
    /// Destructor
    ~ExternalReferenceEndpoint () = default;
    /// Copy constructor
    ExternalReferenceEndpoint (const ExternalReferenceEndpoint&) = default;
    /// Move constructor
    ExternalReferenceEndpoint (ExternalReferenceEndpoint&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ExternalReferenceEndpoint (
      std::string location,
      bool provider,
      std::string portName,
      ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType);
    /// Copy assignment operator
    ExternalReferenceEndpoint& operator= (const ExternalReferenceEndpoint&) = default;
    /// Move assignment operator
    ExternalReferenceEndpoint& operator= (ExternalReferenceEndpoint&&) = default;

    /// @copydoc Deployment::ExternalReferenceEndpoint::location
    //@{
    inline void location (const std::string& _location);
    inline void location (std::string&& _location);
    inline const std::string& location () const;
    inline std::string& location ();
    //@}

    /// @copydoc Deployment::ExternalReferenceEndpoint::provider
    //@{
    inline void provider (bool _provider);
    inline bool provider () const;
    inline bool& provider ();
    //@}

    /// @copydoc Deployment::ExternalReferenceEndpoint::portName
    //@{
    inline void portName (const std::string& _portName);
    inline void portName (std::string&& _portName);
    inline const std::string& portName () const;
    inline std::string& portName ();
    //@}

    /// @copydoc Deployment::ExternalReferenceEndpoint::supportedType
    //@{
    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType);
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ExternalReferenceEndpoint& s);

  private:
    std::string location_;
    bool provider_ {};
    std::string portName_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
  };// ExternalReferenceEndpoint

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ExternalReferenceEndpoints
  typedef std::vector < ExternalReferenceEndpoint> ExternalReferenceEndpoints;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ConnectionResourceDeploymentDescription
  class ConnectionResourceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ConnectionResourceDeploymentDescription () = default;
    /// Destructor
    ~ConnectionResourceDeploymentDescription () = default;
    /// Copy constructor
    ConnectionResourceDeploymentDescription (const ConnectionResourceDeploymentDescription&) = default;
    /// Move constructor
    ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ConnectionResourceDeploymentDescription (
      std::string targetName,
      std::string requirementName,
      std::string resourceName,
      ::Deployment::Properties property);
    /// Copy assignment operator
    ConnectionResourceDeploymentDescription& operator= (const ConnectionResourceDeploymentDescription&) = default;
    /// Move assignment operator
    ConnectionResourceDeploymentDescription& operator= (ConnectionResourceDeploymentDescription&&) = default;

    /// @copydoc Deployment::ConnectionResourceDeploymentDescription::targetName
    //@{
    inline void targetName (const std::string& _targetName);
    inline void targetName (std::string&& _targetName);
    inline const std::string& targetName () const;
    inline std::string& targetName ();
    //@}

    /// @copydoc Deployment::ConnectionResourceDeploymentDescription::requirementName
    //@{
    inline void requirementName (const std::string& _requirementName);
    inline void requirementName (std::string&& _requirementName);
    inline const std::string& requirementName () const;
    inline std::string& requirementName ();
    //@}

    /// @copydoc Deployment::ConnectionResourceDeploymentDescription::resourceName
    //@{
    inline void resourceName (const std::string& _resourceName);
    inline void resourceName (std::string&& _resourceName);
    inline const std::string& resourceName () const;
    inline std::string& resourceName ();
    //@}

    /// @copydoc Deployment::ConnectionResourceDeploymentDescription::property
    //@{
    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ConnectionResourceDeploymentDescription& s);

  private:
    std::string targetName_;
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// ConnectionResourceDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ConnectionResourceDeploymentDescriptions
  typedef std::vector < ConnectionResourceDeploymentDescription> ConnectionResourceDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::PlanConnectionDescription
  class PlanConnectionDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    PlanConnectionDescription () = default;
    /// Destructor
    ~PlanConnectionDescription () = default;
    /// Copy constructor
    PlanConnectionDescription (const PlanConnectionDescription&) = default;
    /// Move constructor
    PlanConnectionDescription (PlanConnectionDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanConnectionDescription (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      ::Deployment::Requirements deployRequirement,
      ::Deployment::ComponentExternalPortEndpoints externalEndpoint,
      ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint,
      ::Deployment::ExternalReferenceEndpoints externalReference,
      ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource);
    /// Copy assignment operator
    PlanConnectionDescription& operator= (const PlanConnectionDescription&) = default;
    /// Move assignment operator
    PlanConnectionDescription& operator= (PlanConnectionDescription&&) = default;

    /// @copydoc Deployment::PlanConnectionDescription::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::PlanConnectionDescription::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();
    //@}

    /// @copydoc Deployment::PlanConnectionDescription::deployRequirement
    //@{
    inline void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    inline void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    inline const ::Deployment::Requirements& deployRequirement () const;
    inline ::Deployment::Requirements& deployRequirement ();
    //@}

    /// @copydoc Deployment::PlanConnectionDescription::externalEndpoint
    //@{
    inline void externalEndpoint (const ::Deployment::ComponentExternalPortEndpoints& _externalEndpoint);
    inline void externalEndpoint (::Deployment::ComponentExternalPortEndpoints&& _externalEndpoint);
    inline const ::Deployment::ComponentExternalPortEndpoints& externalEndpoint () const;
    inline ::Deployment::ComponentExternalPortEndpoints& externalEndpoint ();
    //@}

    /// @copydoc Deployment::PlanConnectionDescription::internalEndpoint
    //@{
    inline void internalEndpoint (const ::Deployment::PlanSubcomponentPortEndpoints& _internalEndpoint);
    inline void internalEndpoint (::Deployment::PlanSubcomponentPortEndpoints&& _internalEndpoint);
    inline const ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint () const;
    inline ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint ();
    //@}

    /// @copydoc Deployment::PlanConnectionDescription::externalReference
    //@{
    inline void externalReference (const ::Deployment::ExternalReferenceEndpoints& _externalReference);
    inline void externalReference (::Deployment::ExternalReferenceEndpoints&& _externalReference);
    inline const ::Deployment::ExternalReferenceEndpoints& externalReference () const;
    inline ::Deployment::ExternalReferenceEndpoints& externalReference ();
    //@}

    /// @copydoc Deployment::PlanConnectionDescription::deployedResource
    //@{
    inline void deployedResource (const ::Deployment::ConnectionResourceDeploymentDescriptions& _deployedResource);
    inline void deployedResource (::Deployment::ConnectionResourceDeploymentDescriptions&& _deployedResource);
    inline const ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource () const;
    inline ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanConnectionDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ComponentExternalPortEndpoints externalEndpoint_;
    ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint_;
    ::Deployment::ExternalReferenceEndpoints externalReference_;
    ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource_;
  };// PlanConnectionDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::PlanConnectionDescriptions
  typedef std::vector < PlanConnectionDescription> PlanConnectionDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::PlanSubcomponentPropertyReference
  class PlanSubcomponentPropertyReference
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    PlanSubcomponentPropertyReference () = default;
    /// Destructor
    ~PlanSubcomponentPropertyReference () = default;
    /// Copy constructor
    PlanSubcomponentPropertyReference (const PlanSubcomponentPropertyReference&) = default;
    /// Move constructor
    PlanSubcomponentPropertyReference (PlanSubcomponentPropertyReference&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanSubcomponentPropertyReference (
      std::string propertyName,
      uint32_t instanceRef);
    /// Copy assignment operator
    PlanSubcomponentPropertyReference& operator= (const PlanSubcomponentPropertyReference&) = default;
    /// Move assignment operator
    PlanSubcomponentPropertyReference& operator= (PlanSubcomponentPropertyReference&&) = default;

    /// @copydoc Deployment::PlanSubcomponentPropertyReference::propertyName
    //@{
    inline void propertyName (const std::string& _propertyName);
    inline void propertyName (std::string&& _propertyName);
    inline const std::string& propertyName () const;
    inline std::string& propertyName ();
    //@}

    /// @copydoc Deployment::PlanSubcomponentPropertyReference::instanceRef
    //@{
    inline void instanceRef (uint32_t _instanceRef);
    inline uint32_t instanceRef () const;
    inline uint32_t& instanceRef ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanSubcomponentPropertyReference& s);

  private:
    std::string propertyName_;
    uint32_t instanceRef_ {};
  };// PlanSubcomponentPropertyReference

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::PlanSubcomponentPropertyReferences
  typedef std::vector < PlanSubcomponentPropertyReference> PlanSubcomponentPropertyReferences;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::PlanPropertyMapping
  class PlanPropertyMapping
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    PlanPropertyMapping () = default;
    /// Destructor
    ~PlanPropertyMapping () = default;
    /// Copy constructor
    PlanPropertyMapping (const PlanPropertyMapping&) = default;
    /// Move constructor
    PlanPropertyMapping (PlanPropertyMapping&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanPropertyMapping (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      std::string externalName,
      ::Deployment::PlanSubcomponentPropertyReferences delegatesTo);
    /// Copy assignment operator
    PlanPropertyMapping& operator= (const PlanPropertyMapping&) = default;
    /// Move assignment operator
    PlanPropertyMapping& operator= (PlanPropertyMapping&&) = default;

    /// @copydoc Deployment::PlanPropertyMapping::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::PlanPropertyMapping::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();
    //@}

    /// @copydoc Deployment::PlanPropertyMapping::externalName
    //@{
    inline void externalName (const std::string& _externalName);
    inline void externalName (std::string&& _externalName);
    inline const std::string& externalName () const;
    inline std::string& externalName ();
    //@}

    /// @copydoc Deployment::PlanPropertyMapping::delegatesTo
    //@{
    inline void delegatesTo (const ::Deployment::PlanSubcomponentPropertyReferences& _delegatesTo);
    inline void delegatesTo (::Deployment::PlanSubcomponentPropertyReferences&& _delegatesTo);
    inline const ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo () const;
    inline ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanPropertyMapping& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    std::string externalName_;
    ::Deployment::PlanSubcomponentPropertyReferences delegatesTo_;
  };// PlanPropertyMapping

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::PlanPropertyMappings
  typedef std::vector < PlanPropertyMapping> PlanPropertyMappings;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ImplementationDependency
  class ImplementationDependency
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ImplementationDependency () = default;
    /// Destructor
    ~ImplementationDependency () = default;
    /// Copy constructor
    ImplementationDependency (const ImplementationDependency&) = default;
    /// Move constructor
    ImplementationDependency (ImplementationDependency&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ImplementationDependency (
      std::string requiredType);
    /// Copy assignment operator
    ImplementationDependency& operator= (const ImplementationDependency&) = default;
    /// Move assignment operator
    ImplementationDependency& operator= (ImplementationDependency&&) = default;

    /// @copydoc Deployment::ImplementationDependency::requiredType
    //@{
    inline void requiredType (const std::string& _requiredType);
    inline void requiredType (std::string&& _requiredType);
    inline const std::string& requiredType () const;
    inline std::string& requiredType ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ImplementationDependency& s);

  private:
    std::string requiredType_;
  };// ImplementationDependency

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ImplementationDependencies
  typedef std::vector < ImplementationDependency> ImplementationDependencies;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ResourceDeploymentDescription
  class ResourceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ResourceDeploymentDescription () = default;
    /// Destructor
    ~ResourceDeploymentDescription () = default;
    /// Copy constructor
    ResourceDeploymentDescription (const ResourceDeploymentDescription&) = default;
    /// Move constructor
    ResourceDeploymentDescription (ResourceDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ResourceDeploymentDescription (
      std::string requirementName,
      std::string resourceName,
      ::Deployment::Properties property);
    /// Copy assignment operator
    ResourceDeploymentDescription& operator= (const ResourceDeploymentDescription&) = default;
    /// Move assignment operator
    ResourceDeploymentDescription& operator= (ResourceDeploymentDescription&&) = default;

    /// @copydoc Deployment::ResourceDeploymentDescription::requirementName
    //@{
    inline void requirementName (const std::string& _requirementName);
    inline void requirementName (std::string&& _requirementName);
    inline const std::string& requirementName () const;
    inline std::string& requirementName ();
    //@}

    /// @copydoc Deployment::ResourceDeploymentDescription::resourceName
    //@{
    inline void resourceName (const std::string& _resourceName);
    inline void resourceName (std::string&& _resourceName);
    inline const std::string& resourceName () const;
    inline std::string& resourceName ();
    //@}

    /// @copydoc Deployment::ResourceDeploymentDescription::property
    //@{
    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ResourceDeploymentDescription& s);

  private:
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// ResourceDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ResourceDeploymentDescriptions
  typedef std::vector < ResourceDeploymentDescription> ResourceDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ArtifactDeploymentDescription
  class ArtifactDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ArtifactDeploymentDescription () = default;
    /// Destructor
    ~ArtifactDeploymentDescription () = default;
    /// Copy constructor
    ArtifactDeploymentDescription (const ArtifactDeploymentDescription&) = default;
    /// Move constructor
    ArtifactDeploymentDescription (ArtifactDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ArtifactDeploymentDescription (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq location,
      std::string node,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      ::Deployment::Properties execParameter,
      ::Deployment::Requirements deployRequirement,
      ::Deployment::ResourceDeploymentDescriptions deployedResource);
    /// Copy assignment operator
    ArtifactDeploymentDescription& operator= (const ArtifactDeploymentDescription&) = default;
    /// Move assignment operator
    ArtifactDeploymentDescription& operator= (ArtifactDeploymentDescription&&) = default;

    /// @copydoc Deployment::ArtifactDeploymentDescription::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::ArtifactDeploymentDescription::location
    //@{
    inline void location (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _location);
    inline void location (::TAOX11_NAMESPACE::CORBA::StringSeq&& _location);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& location () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& location ();
    //@}

    /// @copydoc Deployment::ArtifactDeploymentDescription::node
    //@{
    inline void node (const std::string& _node);
    inline void node (std::string&& _node);
    inline const std::string& node () const;
    inline std::string& node ();
    //@}

    /// @copydoc Deployment::ArtifactDeploymentDescription::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source);
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source ();
    //@}

    /// @copydoc Deployment::ArtifactDeploymentDescription::execParameter
    //@{
    inline void execParameter (const ::Deployment::Properties& _execParameter);
    inline void execParameter (::Deployment::Properties&& _execParameter);
    inline const ::Deployment::Properties& execParameter () const;
    inline ::Deployment::Properties& execParameter ();
    //@}

    /// @copydoc Deployment::ArtifactDeploymentDescription::deployRequirement
    //@{
    inline void deployRequirement (const ::Deployment::Requirements& _deployRequirement);
    inline void deployRequirement (::Deployment::Requirements&& _deployRequirement);
    inline const ::Deployment::Requirements& deployRequirement () const;
    inline ::Deployment::Requirements& deployRequirement ();
    //@}

    /// @copydoc Deployment::ArtifactDeploymentDescription::deployedResource
    //@{
    inline void deployedResource (const ::Deployment::ResourceDeploymentDescriptions& _deployedResource);
    inline void deployedResource (::Deployment::ResourceDeploymentDescriptions&& _deployedResource);
    inline const ::Deployment::ResourceDeploymentDescriptions& deployedResource () const;
    inline ::Deployment::ResourceDeploymentDescriptions& deployedResource ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ArtifactDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq location_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ResourceDeploymentDescriptions deployedResource_;
  };// ArtifactDeploymentDescription

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ArtifactDeploymentDescriptions
  typedef std::vector < ArtifactDeploymentDescription> ArtifactDeploymentDescriptions;

  // generated from c++11/templates/cli/hdr/enum.erb

  /// @copydoc Deployment::PlanLocalityKind
  enum class PlanLocalityKind : uint32_t
  {
    /// @copydoc Deployment::PlanLocalityKind::PlanSameProcess
    PlanSameProcess,
    /// @copydoc Deployment::PlanLocalityKind::PlanDifferentProcess
    PlanDifferentProcess,
    /// @copydoc Deployment::PlanLocalityKind::PlanNoConstraint
    PlanNoConstraint
  };// PlanLocalityKind


  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::PlanLocality
  class PlanLocality
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    PlanLocality () = default;
    /// Destructor
    ~PlanLocality () = default;
    /// Copy constructor
    PlanLocality (const PlanLocality&) = default;
    /// Move constructor
    PlanLocality (PlanLocality&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanLocality (
      ::Deployment::PlanLocalityKind constraint,
      ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef);
    /// Copy assignment operator
    PlanLocality& operator= (const PlanLocality&) = default;
    /// Move assignment operator
    PlanLocality& operator= (PlanLocality&&) = default;

    /// @copydoc Deployment::PlanLocality::constraint
    //@{
    inline void constraint (::Deployment::PlanLocalityKind _constraint);
    inline ::Deployment::PlanLocalityKind constraint () const;
    inline ::Deployment::PlanLocalityKind& constraint ();
    //@}

    /// @copydoc Deployment::PlanLocality::constrainedInstanceRef
    //@{
    inline void constrainedInstanceRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _constrainedInstanceRef);
    inline void constrainedInstanceRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _constrainedInstanceRef);
    inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef () const;
    inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanLocality& s);

  private:
    ::Deployment::PlanLocalityKind constraint_ {};
    ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef_;
  };// PlanLocality

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::PlanLocalities
  typedef std::vector < PlanLocality> PlanLocalities;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::DeploymentPlan
  class DeploymentPlan
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    DeploymentPlan () = default;
    /// Destructor
    ~DeploymentPlan () = default;
    /// Copy constructor
    DeploymentPlan (const DeploymentPlan&) = default;
    /// Move constructor
    DeploymentPlan (DeploymentPlan&&) = default;
    /// Constructor which accepts value for all members
    explicit inline DeploymentPlan (
      std::string label,
      std::string UUID,
      ::Deployment::ComponentInterfaceDescription realizes,
      ::Deployment::MonolithicDeploymentDescriptions implementation,
      ::Deployment::InstanceDeploymentDescriptions instance,
      ::Deployment::PlanConnectionDescriptions connection,
      ::Deployment::PlanPropertyMappings externalProperty,
      ::Deployment::ImplementationDependencies dependsOn,
      ::Deployment::ArtifactDeploymentDescriptions artifact,
      ::Deployment::Properties infoProperty,
      ::Deployment::PlanLocalities localityConstraint);
    /// Copy assignment operator
    DeploymentPlan& operator= (const DeploymentPlan&) = default;
    /// Move assignment operator
    DeploymentPlan& operator= (DeploymentPlan&&) = default;

    /// @copydoc Deployment::DeploymentPlan::label
    //@{
    inline void label (const std::string& _label);
    inline void label (std::string&& _label);
    inline const std::string& label () const;
    inline std::string& label ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::UUID
    //@{
    inline void UUID (const std::string& _UUID);
    inline void UUID (std::string&& _UUID);
    inline const std::string& UUID () const;
    inline std::string& UUID ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::realizes
    //@{
    inline void realizes (const ::Deployment::ComponentInterfaceDescription& _realizes);
    inline void realizes (::Deployment::ComponentInterfaceDescription&& _realizes);
    inline const ::Deployment::ComponentInterfaceDescription& realizes () const;
    inline ::Deployment::ComponentInterfaceDescription& realizes ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::implementation
    //@{
    inline void implementation (const ::Deployment::MonolithicDeploymentDescriptions& _implementation);
    inline void implementation (::Deployment::MonolithicDeploymentDescriptions&& _implementation);
    inline const ::Deployment::MonolithicDeploymentDescriptions& implementation () const;
    inline ::Deployment::MonolithicDeploymentDescriptions& implementation ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::instance
    //@{
    inline void instance (const ::Deployment::InstanceDeploymentDescriptions& _instance);
    inline void instance (::Deployment::InstanceDeploymentDescriptions&& _instance);
    inline const ::Deployment::InstanceDeploymentDescriptions& instance () const;
    inline ::Deployment::InstanceDeploymentDescriptions& instance ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::connection
    //@{
    inline void connection (const ::Deployment::PlanConnectionDescriptions& _connection);
    inline void connection (::Deployment::PlanConnectionDescriptions&& _connection);
    inline const ::Deployment::PlanConnectionDescriptions& connection () const;
    inline ::Deployment::PlanConnectionDescriptions& connection ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::externalProperty
    //@{
    inline void externalProperty (const ::Deployment::PlanPropertyMappings& _externalProperty);
    inline void externalProperty (::Deployment::PlanPropertyMappings&& _externalProperty);
    inline const ::Deployment::PlanPropertyMappings& externalProperty () const;
    inline ::Deployment::PlanPropertyMappings& externalProperty ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::dependsOn
    //@{
    inline void dependsOn (const ::Deployment::ImplementationDependencies& _dependsOn);
    inline void dependsOn (::Deployment::ImplementationDependencies&& _dependsOn);
    inline const ::Deployment::ImplementationDependencies& dependsOn () const;
    inline ::Deployment::ImplementationDependencies& dependsOn ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::artifact
    //@{
    inline void artifact (const ::Deployment::ArtifactDeploymentDescriptions& _artifact);
    inline void artifact (::Deployment::ArtifactDeploymentDescriptions&& _artifact);
    inline const ::Deployment::ArtifactDeploymentDescriptions& artifact () const;
    inline ::Deployment::ArtifactDeploymentDescriptions& artifact ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::infoProperty
    //@{
    inline void infoProperty (const ::Deployment::Properties& _infoProperty);
    inline void infoProperty (::Deployment::Properties&& _infoProperty);
    inline const ::Deployment::Properties& infoProperty () const;
    inline ::Deployment::Properties& infoProperty ();
    //@}

    /// @copydoc Deployment::DeploymentPlan::localityConstraint
    //@{
    inline void localityConstraint (const ::Deployment::PlanLocalities& _localityConstraint);
    inline void localityConstraint (::Deployment::PlanLocalities&& _localityConstraint);
    inline const ::Deployment::PlanLocalities& localityConstraint () const;
    inline ::Deployment::PlanLocalities& localityConstraint ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (DeploymentPlan& s);

  private:
    std::string label_;
    std::string UUID_;
    ::Deployment::ComponentInterfaceDescription realizes_;
    ::Deployment::MonolithicDeploymentDescriptions implementation_;
    ::Deployment::InstanceDeploymentDescriptions instance_;
    ::Deployment::PlanConnectionDescriptions connection_;
    ::Deployment::PlanPropertyMappings externalProperty_;
    ::Deployment::ImplementationDependencies dependsOn_;
    ::Deployment::ArtifactDeploymentDescriptions artifact_;
    ::Deployment::Properties infoProperty_;
    ::Deployment::PlanLocalities localityConstraint_;
  };// DeploymentPlan
} // namespace Deployment


// generated from StubHeaderWriter#enter_module
/// @copydoc Deployment
namespace Deployment
{

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ComponentPackageReference
  class ComponentPackageReference
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ComponentPackageReference () = default;
    /// Destructor
    ~ComponentPackageReference () = default;
    /// Copy constructor
    ComponentPackageReference (const ComponentPackageReference&) = default;
    /// Move constructor
    ComponentPackageReference (ComponentPackageReference&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentPackageReference (
      std::string requiredUUID,
      std::string requiredName,
      ::Deployment::ComponentInterfaceDescription requiredType);
    /// Copy assignment operator
    ComponentPackageReference& operator= (const ComponentPackageReference&) = default;
    /// Move assignment operator
    ComponentPackageReference& operator= (ComponentPackageReference&&) = default;

    /// @copydoc Deployment::ComponentPackageReference::requiredUUID
    //@{
    inline void requiredUUID (const std::string& _requiredUUID);
    inline void requiredUUID (std::string&& _requiredUUID);
    inline const std::string& requiredUUID () const;
    inline std::string& requiredUUID ();
    //@}

    /// @copydoc Deployment::ComponentPackageReference::requiredName
    //@{
    inline void requiredName (const std::string& _requiredName);
    inline void requiredName (std::string&& _requiredName);
    inline const std::string& requiredName () const;
    inline std::string& requiredName ();
    //@}

    /// @copydoc Deployment::ComponentPackageReference::requiredType
    //@{
    inline void requiredType (const ::Deployment::ComponentInterfaceDescription& _requiredType);
    inline void requiredType (::Deployment::ComponentInterfaceDescription&& _requiredType);
    inline const ::Deployment::ComponentInterfaceDescription& requiredType () const;
    inline ::Deployment::ComponentInterfaceDescription& requiredType ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentPackageReference& s);

  private:
    std::string requiredUUID_;
    std::string requiredName_;
    ::Deployment::ComponentInterfaceDescription requiredType_;
  };// ComponentPackageReference

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ComponentPackageReferences
  typedef std::vector < ComponentPackageReference> ComponentPackageReferences;

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ResourceUsageKinds
  typedef std::vector < ::Deployment::ResourceUsageKind> ResourceUsageKinds;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::ImplementationRequirement
  class ImplementationRequirement
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    ImplementationRequirement () = default;
    /// Destructor
    ~ImplementationRequirement () = default;
    /// Copy constructor
    ImplementationRequirement (const ImplementationRequirement&) = default;
    /// Move constructor
    ImplementationRequirement (ImplementationRequirement&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ImplementationRequirement (
      ::Deployment::ResourceUsageKinds resourceUsage,
      std::string resourcePort,
      std::string componentPort,
      std::string name,
      std::string resourceType,
      ::Deployment::Properties property);
    /// Copy assignment operator
    ImplementationRequirement& operator= (const ImplementationRequirement&) = default;
    /// Move assignment operator
    ImplementationRequirement& operator= (ImplementationRequirement&&) = default;

    /// @copydoc Deployment::ImplementationRequirement::resourceUsage
    //@{
    inline void resourceUsage (const ::Deployment::ResourceUsageKinds& _resourceUsage);
    inline void resourceUsage (::Deployment::ResourceUsageKinds&& _resourceUsage);
    inline const ::Deployment::ResourceUsageKinds& resourceUsage () const;
    inline ::Deployment::ResourceUsageKinds& resourceUsage ();
    //@}

    /// @copydoc Deployment::ImplementationRequirement::resourcePort
    //@{
    inline void resourcePort (const std::string& _resourcePort);
    inline void resourcePort (std::string&& _resourcePort);
    inline const std::string& resourcePort () const;
    inline std::string& resourcePort ();
    //@}

    /// @copydoc Deployment::ImplementationRequirement::componentPort
    //@{
    inline void componentPort (const std::string& _componentPort);
    inline void componentPort (std::string&& _componentPort);
    inline const std::string& componentPort () const;
    inline std::string& componentPort ();
    //@}

    /// @copydoc Deployment::ImplementationRequirement::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::ImplementationRequirement::resourceType
    //@{
    inline void resourceType (const std::string& _resourceType);
    inline void resourceType (std::string&& _resourceType);
    inline const std::string& resourceType () const;
    inline std::string& resourceType ();
    //@}

    /// @copydoc Deployment::ImplementationRequirement::property
    //@{
    inline void property (const ::Deployment::Properties& _property);
    inline void property (::Deployment::Properties&& _property);
    inline const ::Deployment::Properties& property () const;
    inline ::Deployment::Properties& property ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ImplementationRequirement& s);

  private:
    ::Deployment::ResourceUsageKinds resourceUsage_;
    std::string resourcePort_;
    std::string componentPort_;
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  };// ImplementationRequirement

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::ImplementationRequirements
  typedef std::vector < ImplementationRequirement> ImplementationRequirements;

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Deployment::Capability
  class Capability
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    Capability () = default;
    /// Destructor
    ~Capability () = default;
    /// Copy constructor
    Capability (const Capability&) = default;
    /// Move constructor
    Capability (Capability&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Capability (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType,
      ::Deployment::SatisfierProperties property);
    /// Copy assignment operator
    Capability& operator= (const Capability&) = default;
    /// Move assignment operator
    Capability& operator= (Capability&&) = default;

    /// @copydoc Deployment::Capability::name
    //@{
    inline void name (const std::string& _name);
    inline void name (std::string&& _name);
    inline const std::string& name () const;
    inline std::string& name ();
    //@}

    /// @copydoc Deployment::Capability::resourceType
    //@{
    inline void resourceType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _resourceType);
    inline void resourceType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _resourceType);
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType () const;
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType ();
    //@}

    /// @copydoc Deployment::Capability::property
    //@{
    inline void property (const ::Deployment::SatisfierProperties& _property);
    inline void property (::Deployment::SatisfierProperties&& _property);
    inline const ::Deployment::SatisfierProperties& property () const;
    inline ::Deployment::SatisfierProperties& property ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (Capability& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType_;
    ::Deployment::SatisfierProperties property_;
  };// Capability

  // generated from c++11/templates/cli/hdr/typedef.erb
  /// @copydoc Deployment::Capabilities
  typedef std::vector < Capability> Capabilities;
} // namespace Deployment


// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PROPERTY_TRAITS_)
#define _STRUCT_DEPLOYMENT_PROPERTY_TRAITS_
    template<>
    struct traits < ::Deployment::Property>
      : IDL::common_traits< ::Deployment::Property>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::Property, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::Property>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_PROPERTY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::Property>
    // MD5            : 9FA54C1D0A4E5ABC4A2486AD7C463745
#if !defined(_ALIAS_9FA54C1D0A4E5ABC4A2486AD7C463745_TRAITS_DECL_)
#define _ALIAS_9FA54C1D0A4E5ABC4A2486AD7C463745_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::Properties>
      : IDL::common_traits< ::Deployment::Properties>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::Property> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Properties>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::Properties>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::Properties, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::Properties>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_REQUIREMENT_TRAITS_)
#define _STRUCT_DEPLOYMENT_REQUIREMENT_TRAITS_
    template<>
    struct traits < ::Deployment::Requirement>
      : IDL::common_traits< ::Deployment::Requirement>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::Requirement, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::Requirement>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_REQUIREMENT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::Requirement>
    // MD5            : B5D61CF43DC976264FCA09DAEF6B439D
#if !defined(_ALIAS_B5D61CF43DC976264FCA09DAEF6B439D_TRAITS_DECL_)
#define _ALIAS_B5D61CF43DC976264FCA09DAEF6B439D_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::Requirements>
      : IDL::common_traits< ::Deployment::Requirements>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::Requirement> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Requirements>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::Requirements>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::Requirements, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::Requirements>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::SatisfierPropertyKind>
      : IDL::common_traits< ::Deployment::SatisfierPropertyKind>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::SatisfierPropertyKind, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Deployment::SatisfierPropertyKind val_)
      {
        switch (val_)
        {
          case Deployment::SatisfierPropertyKind::Quantity: return os_ << "Deployment::SatisfierPropertyKind::Quantity"; break;
          case Deployment::SatisfierPropertyKind::Capacity: return os_ << "Deployment::SatisfierPropertyKind::Capacity"; break;
          case Deployment::SatisfierPropertyKind::Minimum: return os_ << "Deployment::SatisfierPropertyKind::Minimum"; break;
          case Deployment::SatisfierPropertyKind::Maximum: return os_ << "Deployment::SatisfierPropertyKind::Maximum"; break;
          case Deployment::SatisfierPropertyKind::Attribute: return os_ << "Deployment::SatisfierPropertyKind::Attribute"; break;
          case Deployment::SatisfierPropertyKind::Selection: return os_ << "Deployment::SatisfierPropertyKind::Selection"; break;
          default: return os_;
        }
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::SatisfierPropertyKind>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::SatisfierPropertyKind>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::SatisfierPropertyKind, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::SatisfierPropertyKind>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_SATISFIERPROPERTY_TRAITS_)
#define _STRUCT_DEPLOYMENT_SATISFIERPROPERTY_TRAITS_
    template<>
    struct traits < ::Deployment::SatisfierProperty>
      : IDL::common_traits< ::Deployment::SatisfierProperty>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::SatisfierProperty, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::SatisfierProperty>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_SATISFIERPROPERTY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::SatisfierProperty>
    // MD5            : AAB77A9CDD8FCC93D26F3C8F9DA5CB57
#if !defined(_ALIAS_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_TRAITS_DECL_)
#define _ALIAS_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::SatisfierProperties>
      : IDL::common_traits< ::Deployment::SatisfierProperties>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::SatisfierProperty> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::SatisfierProperties>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::SatisfierProperties>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::SatisfierProperties, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::SatisfierProperties>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::CCMComponentPortKind>
      : IDL::common_traits< ::Deployment::CCMComponentPortKind>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::CCMComponentPortKind, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Deployment::CCMComponentPortKind val_)
      {
        switch (val_)
        {
          case Deployment::CCMComponentPortKind::Facet: return os_ << "Deployment::CCMComponentPortKind::Facet"; break;
          case Deployment::CCMComponentPortKind::SimplexReceptacle: return os_ << "Deployment::CCMComponentPortKind::SimplexReceptacle"; break;
          case Deployment::CCMComponentPortKind::MultiplexReceptacle: return os_ << "Deployment::CCMComponentPortKind::MultiplexReceptacle"; break;
          case Deployment::CCMComponentPortKind::EventEmitter: return os_ << "Deployment::CCMComponentPortKind::EventEmitter"; break;
          case Deployment::CCMComponentPortKind::EventPublisher: return os_ << "Deployment::CCMComponentPortKind::EventPublisher"; break;
          case Deployment::CCMComponentPortKind::EventConsumer: return os_ << "Deployment::CCMComponentPortKind::EventConsumer"; break;
          case Deployment::CCMComponentPortKind::ExtendedPort: return os_ << "Deployment::CCMComponentPortKind::ExtendedPort"; break;
          case Deployment::CCMComponentPortKind::MirrorPort: return os_ << "Deployment::CCMComponentPortKind::MirrorPort"; break;
          default: return os_;
        }
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::CCMComponentPortKind>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::CCMComponentPortKind>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::CCMComponentPortKind, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::CCMComponentPortKind>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTPORTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTPORTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPortDescription>
      : IDL::common_traits< ::Deployment::ComponentPortDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPortDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentPortDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_COMPONENTPORTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ComponentPortDescription>
    // MD5            : C5E370E71060EF02CAD31E10FF9B9A83
#if !defined(_ALIAS_C5E370E71060EF02CAD31E10FF9B9A83_TRAITS_DECL_)
#define _ALIAS_C5E370E71060EF02CAD31E10FF9B9A83_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentPortDescriptions>
      : IDL::common_traits< ::Deployment::ComponentPortDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ComponentPortDescription> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPortDescriptions>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ComponentPortDescriptions>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ComponentPortDescriptions, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ComponentPortDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPropertyDescription>
      : IDL::common_traits< ::Deployment::ComponentPropertyDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPropertyDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentPropertyDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_COMPONENTPROPERTYDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ComponentPropertyDescription>
    // MD5            : C38B325CAEA1E1A5249DC3C8B0654824
#if !defined(_ALIAS_C38B325CAEA1E1A5249DC3C8B0654824_TRAITS_DECL_)
#define _ALIAS_C38B325CAEA1E1A5249DC3C8B0654824_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentPropertyDescriptions>
      : IDL::common_traits< ::Deployment::ComponentPropertyDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ComponentPropertyDescription> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPropertyDescriptions>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ComponentPropertyDescriptions>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ComponentPropertyDescriptions, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ComponentPropertyDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTINTERFACEDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTINTERFACEDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentInterfaceDescription>
      : IDL::common_traits< ::Deployment::ComponentInterfaceDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentInterfaceDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentInterfaceDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_COMPONENTINTERFACEDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::MonolithicDeploymentDescription>
      : IDL::common_traits< ::Deployment::MonolithicDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::MonolithicDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::MonolithicDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::MonolithicDeploymentDescription>
    // MD5            : 80C54C15F1FCF891188F93122A3F1653
#if !defined(_ALIAS_80C54C15F1FCF891188F93122A3F1653_TRAITS_DECL_)
#define _ALIAS_80C54C15F1FCF891188F93122A3F1653_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::MonolithicDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::MonolithicDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::MonolithicDeploymentDescription> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::MonolithicDeploymentDescriptions, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::ResourceUsageKind>
      : IDL::common_traits< ::Deployment::ResourceUsageKind>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ResourceUsageKind, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Deployment::ResourceUsageKind val_)
      {
        switch (val_)
        {
          case Deployment::ResourceUsageKind::None: return os_ << "Deployment::ResourceUsageKind::None"; break;
          case Deployment::ResourceUsageKind::InstanceUsesResource: return os_ << "Deployment::ResourceUsageKind::InstanceUsesResource"; break;
          case Deployment::ResourceUsageKind::ResourceUsesInstance: return os_ << "Deployment::ResourceUsageKind::ResourceUsesInstance"; break;
          case Deployment::ResourceUsageKind::PortUsesResource: return os_ << "Deployment::ResourceUsageKind::PortUsesResource"; break;
          case Deployment::ResourceUsageKind::ResourceUsesPort: return os_ << "Deployment::ResourceUsageKind::ResourceUsesPort"; break;
          default: return os_;
        }
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ResourceUsageKind>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ResourceUsageKind>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ResourceUsageKind, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ResourceUsageKind>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::InstanceResourceDeploymentDescription>
      : IDL::common_traits< ::Deployment::InstanceResourceDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::InstanceResourceDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::InstanceResourceDeploymentDescription>
    // MD5            : EECAFA244583FB042136539EF2209665
#if !defined(_ALIAS_EECAFA244583FB042136539EF2209665_TRAITS_DECL_)
#define _ALIAS_EECAFA244583FB042136539EF2209665_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::InstanceResourceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::InstanceResourceDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::InstanceResourceDeploymentDescription> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::InstanceResourceDeploymentDescriptions, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::InstanceDeploymentDescription>
      : IDL::common_traits< ::Deployment::InstanceDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::InstanceDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::InstanceDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::InstanceDeploymentDescription>
    // MD5            : 5DAB54D520633DBBAAC64AB44B5264EF
#if !defined(_ALIAS_5DAB54D520633DBBAAC64AB44B5264EF_TRAITS_DECL_)
#define _ALIAS_5DAB54D520633DBBAAC64AB44B5264EF_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::InstanceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::InstanceDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::InstanceDeploymentDescription> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::InstanceDeploymentDescriptions, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentExternalPortEndpoint>
      : IDL::common_traits< ::Deployment::ComponentExternalPortEndpoint>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentExternalPortEndpoint, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_COMPONENTEXTERNALPORTENDPOINT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ComponentExternalPortEndpoint>
    // MD5            : D55B5CF95C9426C6D2C98C3A5D478A08
#if !defined(_ALIAS_D55B5CF95C9426C6D2C98C3A5D478A08_TRAITS_DECL_)
#define _ALIAS_D55B5CF95C9426C6D2C98C3A5D478A08_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentExternalPortEndpoints>
      : IDL::common_traits< ::Deployment::ComponentExternalPortEndpoints>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ComponentExternalPortEndpoint> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ComponentExternalPortEndpoints, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::PlanSubcomponentPortEndpoint>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPortEndpoint>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanSubcomponentPortEndpoint, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPORTENDPOINT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanSubcomponentPortEndpoint>
    // MD5            : B166E528DC38CC7B9823B4A707AF73F7
#if !defined(_ALIAS_B166E528DC38CC7B9823B4A707AF73F7_TRAITS_DECL_)
#define _ALIAS_B166E528DC38CC7B9823B4A707AF73F7_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanSubcomponentPortEndpoints>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPortEndpoints>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanSubcomponentPortEndpoints, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_EXTERNALREFERENCEENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT_EXTERNALREFERENCEENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::ExternalReferenceEndpoint>
      : IDL::common_traits< ::Deployment::ExternalReferenceEndpoint>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ExternalReferenceEndpoint, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ExternalReferenceEndpoint>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_EXTERNALREFERENCEENDPOINT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ExternalReferenceEndpoint>
    // MD5            : 05A01CE11A8BFF9D44BAB053FE399734
#if !defined(_ALIAS_05A01CE11A8BFF9D44BAB053FE399734_TRAITS_DECL_)
#define _ALIAS_05A01CE11A8BFF9D44BAB053FE399734_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ExternalReferenceEndpoints>
      : IDL::common_traits< ::Deployment::ExternalReferenceEndpoints>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ExternalReferenceEndpoint> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ExternalReferenceEndpoints>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ExternalReferenceEndpoints>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ExternalReferenceEndpoints, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ExternalReferenceEndpoints>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ConnectionResourceDeploymentDescription>
      : IDL::common_traits< ::Deployment::ConnectionResourceDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ConnectionResourceDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ConnectionResourceDeploymentDescription>
    // MD5            : AF4F2101DCE0C79A0EDE886BDCAFC611
#if !defined(_ALIAS_AF4F2101DCE0C79A0EDE886BDCAFC611_TRAITS_DECL_)
#define _ALIAS_AF4F2101DCE0C79A0EDE886BDCAFC611_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ConnectionResourceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::ConnectionResourceDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ConnectionResourceDeploymentDescriptions, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANCONNECTIONDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANCONNECTIONDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::PlanConnectionDescription>
      : IDL::common_traits< ::Deployment::PlanConnectionDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanConnectionDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanConnectionDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_PLANCONNECTIONDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanConnectionDescription>
    // MD5            : CFA31BAC8967655A8F41210E634352C1
#if !defined(_ALIAS_CFA31BAC8967655A8F41210E634352C1_TRAITS_DECL_)
#define _ALIAS_CFA31BAC8967655A8F41210E634352C1_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanConnectionDescriptions>
      : IDL::common_traits< ::Deployment::PlanConnectionDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::PlanConnectionDescription> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanConnectionDescriptions>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanConnectionDescriptions>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanConnectionDescriptions, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanConnectionDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_
    template<>
    struct traits < ::Deployment::PlanSubcomponentPropertyReference>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPropertyReference>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanSubcomponentPropertyReference, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanSubcomponentPropertyReference>
    // MD5            : AEBC73EB559A636E52F4DAEA9332277F
#if !defined(_ALIAS_AEBC73EB559A636E52F4DAEA9332277F_TRAITS_DECL_)
#define _ALIAS_AEBC73EB559A636E52F4DAEA9332277F_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanSubcomponentPropertyReferences>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPropertyReferences>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::PlanSubcomponentPropertyReference> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanSubcomponentPropertyReferences, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANPROPERTYMAPPING_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANPROPERTYMAPPING_TRAITS_
    template<>
    struct traits < ::Deployment::PlanPropertyMapping>
      : IDL::common_traits< ::Deployment::PlanPropertyMapping>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanPropertyMapping, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanPropertyMapping>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_PLANPROPERTYMAPPING_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanPropertyMapping>
    // MD5            : F12B7FF5B966394695A4C3B62A60769E
#if !defined(_ALIAS_F12B7FF5B966394695A4C3B62A60769E_TRAITS_DECL_)
#define _ALIAS_F12B7FF5B966394695A4C3B62A60769E_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanPropertyMappings>
      : IDL::common_traits< ::Deployment::PlanPropertyMappings>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::PlanPropertyMapping> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanPropertyMappings>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanPropertyMappings>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanPropertyMappings, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanPropertyMappings>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY_TRAITS_)
#define _STRUCT_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY_TRAITS_
    template<>
    struct traits < ::Deployment::ImplementationDependency>
      : IDL::common_traits< ::Deployment::ImplementationDependency>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ImplementationDependency, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ImplementationDependency>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_IMPLEMENTATIONDEPENDENCY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ImplementationDependency>
    // MD5            : 99A76A2AEA0FB19B92F7E3C2DE89FFF6
#if !defined(_ALIAS_99A76A2AEA0FB19B92F7E3C2DE89FFF6_TRAITS_DECL_)
#define _ALIAS_99A76A2AEA0FB19B92F7E3C2DE89FFF6_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ImplementationDependencies>
      : IDL::common_traits< ::Deployment::ImplementationDependencies>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ImplementationDependency> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ImplementationDependencies>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ImplementationDependencies>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ImplementationDependencies, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ImplementationDependencies>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ResourceDeploymentDescription>
      : IDL::common_traits< ::Deployment::ResourceDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ResourceDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ResourceDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ResourceDeploymentDescription>
    // MD5            : DF993C9C6EABFC782FDDA1D9B825B8FC
#if !defined(_ALIAS_DF993C9C6EABFC782FDDA1D9B825B8FC_TRAITS_DECL_)
#define _ALIAS_DF993C9C6EABFC782FDDA1D9B825B8FC_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ResourceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::ResourceDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ResourceDeploymentDescription> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ResourceDeploymentDescriptions, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ArtifactDeploymentDescription>
      : IDL::common_traits< ::Deployment::ArtifactDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ArtifactDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ArtifactDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ArtifactDeploymentDescription>
    // MD5            : 9366314FF053E4C8C2B7FE26CA476674
#if !defined(_ALIAS_9366314FF053E4C8C2B7FE26CA476674_TRAITS_DECL_)
#define _ALIAS_9366314FF053E4C8C2B7FE26CA476674_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ArtifactDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::ArtifactDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ArtifactDeploymentDescription> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ArtifactDeploymentDescriptions, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Deployment::PlanLocalityKind>
      : IDL::common_traits< ::Deployment::PlanLocalityKind>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanLocalityKind, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Deployment::PlanLocalityKind val_)
      {
        switch (val_)
        {
          case Deployment::PlanLocalityKind::PlanSameProcess: return os_ << "Deployment::PlanLocalityKind::PlanSameProcess"; break;
          case Deployment::PlanLocalityKind::PlanDifferentProcess: return os_ << "Deployment::PlanLocalityKind::PlanDifferentProcess"; break;
          case Deployment::PlanLocalityKind::PlanNoConstraint: return os_ << "Deployment::PlanLocalityKind::PlanNoConstraint"; break;
          default: return os_;
        }
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanLocalityKind>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanLocalityKind>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanLocalityKind, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanLocalityKind>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_PLANLOCALITY_TRAITS_)
#define _STRUCT_DEPLOYMENT_PLANLOCALITY_TRAITS_
    template<>
    struct traits < ::Deployment::PlanLocality>
      : IDL::common_traits< ::Deployment::PlanLocality>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanLocality, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanLocality>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_PLANLOCALITY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::PlanLocality>
    // MD5            : DDE38066805242B88FC17943CB38328B
#if !defined(_ALIAS_DDE38066805242B88FC17943CB38328B_TRAITS_DECL_)
#define _ALIAS_DDE38066805242B88FC17943CB38328B_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanLocalities>
      : IDL::common_traits< ::Deployment::PlanLocalities>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::PlanLocality> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanLocalities>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanLocalities>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanLocalities, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanLocalities>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_DEPLOYMENTPLAN_TRAITS_)
#define _STRUCT_DEPLOYMENT_DEPLOYMENTPLAN_TRAITS_
    template<>
    struct traits < ::Deployment::DeploymentPlan>
      : IDL::common_traits< ::Deployment::DeploymentPlan>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::DeploymentPlan, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::DeploymentPlan>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_DEPLOYMENTPLAN_TRAITS_

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_COMPONENTPACKAGEREFERENCE_TRAITS_)
#define _STRUCT_DEPLOYMENT_COMPONENTPACKAGEREFERENCE_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPackageReference>
      : IDL::common_traits< ::Deployment::ComponentPackageReference>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPackageReference, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentPackageReference>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_COMPONENTPACKAGEREFERENCE_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ComponentPackageReference>
    // MD5            : 0C9FEC96A49604B9CC5DF59C48DE88F1
#if !defined(_ALIAS_0C9FEC96A49604B9CC5DF59C48DE88F1_TRAITS_DECL_)
#define _ALIAS_0C9FEC96A49604B9CC5DF59C48DE88F1_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentPackageReferences>
      : IDL::common_traits< ::Deployment::ComponentPackageReferences>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ComponentPackageReference> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPackageReferences>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ComponentPackageReferences>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ComponentPackageReferences, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ComponentPackageReferences>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ResourceUsageKind>
    // MD5            : 25B5A7D7E8D2341751079BEB8A44717A
#if !defined(_ALIAS_25B5A7D7E8D2341751079BEB8A44717A_TRAITS_DECL_)
#define _ALIAS_25B5A7D7E8D2341751079BEB8A44717A_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ResourceUsageKinds>
      : IDL::common_traits< ::Deployment::ResourceUsageKinds>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ResourceUsageKind> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ResourceUsageKinds>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ResourceUsageKinds>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ResourceUsageKinds, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ResourceUsageKinds>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT_TRAITS_)
#define _STRUCT_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT_TRAITS_
    template<>
    struct traits < ::Deployment::ImplementationRequirement>
      : IDL::common_traits< ::Deployment::ImplementationRequirement>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ImplementationRequirement, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ImplementationRequirement>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_IMPLEMENTATIONREQUIREMENT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::ImplementationRequirement>
    // MD5            : 58B3838A8CD6CA5F0D66B307C6BD6467
#if !defined(_ALIAS_58B3838A8CD6CA5F0D66B307C6BD6467_TRAITS_DECL_)
#define _ALIAS_58B3838A8CD6CA5F0D66B307C6BD6467_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ImplementationRequirements>
      : IDL::common_traits< ::Deployment::ImplementationRequirements>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::ImplementationRequirement> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ImplementationRequirements>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ImplementationRequirements>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ImplementationRequirements, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ImplementationRequirements>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_DEPLOYMENT_CAPABILITY_TRAITS_)
#define _STRUCT_DEPLOYMENT_CAPABILITY_TRAITS_
    template<>
    struct traits < ::Deployment::Capability>
      : IDL::common_traits< ::Deployment::Capability>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::Capability, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::Capability>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT_CAPABILITY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits.erb
    // Unaliased type : std::vector < ::Deployment::Capability>
    // MD5            : 67A5FF62ED49ECC3F7373CDDDBC3DFAD
#if !defined(_ALIAS_67A5FF62ED49ECC3F7373CDDDBC3DFAD_TRAITS_DECL_)
#define _ALIAS_67A5FF62ED49ECC3F7373CDDDBC3DFAD_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::Capabilities>
      : IDL::common_traits< ::Deployment::Capabilities>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      typedef std::false_type is_bounded;
      /// IDL::traits<> for the element of the sequence
      typedef IDL::traits< ::Deployment::Capability> element_traits;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val} ; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Capabilities>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::Capabilities>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::Capabilities, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::Capabilities>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::Property, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::Property& val_)
      {
        return os_ << "Deployment::Property"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",value=" << IDL::traits< TAOX11_NAMESPACE::CORBA::Any>::write(val_.value ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Property>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::Property>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::Property, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::Property>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::Requirement, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::Requirement& val_)
      {
        return os_ << "Deployment::Requirement"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",resourceType=" << IDL::traits< std::string>::write(val_.resourceType ())
                   << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Requirement>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::Requirement>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::Requirement, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::Requirement>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::SatisfierProperty, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::SatisfierProperty& val_)
      {
        return os_ << "Deployment::SatisfierProperty"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",kind=" << IDL::traits< ::Deployment::SatisfierPropertyKind>::write(val_.kind ())
                   << ",dynamic=" << IDL::traits< bool>::write(val_.dynamic ())
                   << ",value=" << IDL::traits< TAOX11_NAMESPACE::CORBA::Any>::write(val_.value ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::SatisfierProperty>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::SatisfierProperty>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::SatisfierProperty, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::SatisfierProperty>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPortDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentPortDescription& val_)
      {
        return os_ << "Deployment::ComponentPortDescription"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",specificType=" << IDL::traits< std::string>::write(val_.specificType ())
                   << ",supportedType=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.supportedType ())
                   << ",provider=" << IDL::traits< bool>::write(val_.provider ())
                   << ",exclusiveProvider=" << IDL::traits< bool>::write(val_.exclusiveProvider ())
                   << ",exclusiveUser=" << IDL::traits< bool>::write(val_.exclusiveUser ())
                   << ",optional=" << IDL::traits< bool>::write(val_.optional ())
                   << ",kind=" << IDL::traits< ::Deployment::CCMComponentPortKind>::write(val_.kind ())
                   << ",templateParam=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.templateParam ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPortDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ComponentPortDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ComponentPortDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ComponentPortDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPropertyDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentPropertyDescription& val_)
      {
        return os_ << "Deployment::ComponentPropertyDescription"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",type=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::write(val_.type ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPropertyDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ComponentPropertyDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ComponentPropertyDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ComponentPropertyDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentInterfaceDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentInterfaceDescription& val_)
      {
        return os_ << "Deployment::ComponentInterfaceDescription"
                   << '{'
                   << "label=" << IDL::traits< std::string>::write(val_.label ())
                   << ",UUID=" << IDL::traits< std::string>::write(val_.UUID ())
                   << ",specificType=" << IDL::traits< std::string>::write(val_.specificType ())
                   << ",supportedType=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.supportedType ())
                   << ",idlFile=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.idlFile ())
                   << ",configProperty=" << IDL::traits< ::Deployment::Properties>::write(val_.configProperty ())
                   << ",port=" << IDL::traits< ::Deployment::ComponentPortDescriptions>::write(val_.port ())
                   << ",property=" << IDL::traits< ::Deployment::ComponentPropertyDescriptions>::write(val_.property ())
                   << ",infoProperty=" << IDL::traits< ::Deployment::Properties>::write(val_.infoProperty ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentInterfaceDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ComponentInterfaceDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ComponentInterfaceDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ComponentInterfaceDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::MonolithicDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::MonolithicDeploymentDescription& val_)
      {
        return os_ << "Deployment::MonolithicDeploymentDescription"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
                   << ",artifactRef=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::ULongSeq>::write(val_.artifactRef ())
                   << ",execParameter=" << IDL::traits< ::Deployment::Properties>::write(val_.execParameter ())
                   << ",deployRequirement=" << IDL::traits< ::Deployment::Requirements>::write(val_.deployRequirement ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::MonolithicDeploymentDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::MonolithicDeploymentDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::MonolithicDeploymentDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::MonolithicDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::InstanceResourceDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::InstanceResourceDeploymentDescription& val_)
      {
        return os_ << "Deployment::InstanceResourceDeploymentDescription"
                   << '{'
                   << "resourceUsage=" << IDL::traits< ::Deployment::ResourceUsageKind>::write(val_.resourceUsage ())
                   << ",requirementName=" << IDL::traits< std::string>::write(val_.requirementName ())
                   << ",resourceName=" << IDL::traits< std::string>::write(val_.resourceName ())
                   << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::InstanceResourceDeploymentDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::InstanceDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::InstanceDeploymentDescription& val_)
      {
        return os_ << "Deployment::InstanceDeploymentDescription"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",node=" << IDL::traits< std::string>::write(val_.node ())
                   << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
                   << ",implementationRef=" << IDL::traits< uint32_t>::write(val_.implementationRef ())
                   << ",configProperty=" << IDL::traits< ::Deployment::Properties>::write(val_.configProperty ())
                   << ",deployedResource=" << IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::write(val_.deployedResource ())
                   << ",deployedSharedResource=" << IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::write(val_.deployedSharedResource ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::InstanceDeploymentDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::InstanceDeploymentDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::InstanceDeploymentDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::InstanceDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentExternalPortEndpoint, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentExternalPortEndpoint& val_)
      {
        return os_ << "Deployment::ComponentExternalPortEndpoint"
                   << '{'
                   << "portName=" << IDL::traits< std::string>::write(val_.portName ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ComponentExternalPortEndpoint, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanSubcomponentPortEndpoint, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanSubcomponentPortEndpoint& val_)
      {
        return os_ << "Deployment::PlanSubcomponentPortEndpoint"
                   << '{'
                   << "portName=" << IDL::traits< std::string>::write(val_.portName ())
                   << ",provider=" << IDL::traits< bool>::write(val_.provider ())
                   << ",kind=" << IDL::traits< ::Deployment::CCMComponentPortKind>::write(val_.kind ())
                   << ",instanceRef=" << IDL::traits< uint32_t>::write(val_.instanceRef ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanSubcomponentPortEndpoint, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ExternalReferenceEndpoint, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ExternalReferenceEndpoint& val_)
      {
        return os_ << "Deployment::ExternalReferenceEndpoint"
                   << '{'
                   << "location=" << IDL::traits< std::string>::write(val_.location ())
                   << ",provider=" << IDL::traits< bool>::write(val_.provider ())
                   << ",portName=" << IDL::traits< std::string>::write(val_.portName ())
                   << ",supportedType=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.supportedType ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ExternalReferenceEndpoint>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ExternalReferenceEndpoint>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ExternalReferenceEndpoint, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ExternalReferenceEndpoint>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ConnectionResourceDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ConnectionResourceDeploymentDescription& val_)
      {
        return os_ << "Deployment::ConnectionResourceDeploymentDescription"
                   << '{'
                   << "targetName=" << IDL::traits< std::string>::write(val_.targetName ())
                   << ",requirementName=" << IDL::traits< std::string>::write(val_.requirementName ())
                   << ",resourceName=" << IDL::traits< std::string>::write(val_.resourceName ())
                   << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ConnectionResourceDeploymentDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanConnectionDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanConnectionDescription& val_)
      {
        return os_ << "Deployment::PlanConnectionDescription"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
                   << ",deployRequirement=" << IDL::traits< ::Deployment::Requirements>::write(val_.deployRequirement ())
                   << ",externalEndpoint=" << IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::write(val_.externalEndpoint ())
                   << ",internalEndpoint=" << IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::write(val_.internalEndpoint ())
                   << ",externalReference=" << IDL::traits< ::Deployment::ExternalReferenceEndpoints>::write(val_.externalReference ())
                   << ",deployedResource=" << IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::write(val_.deployedResource ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanConnectionDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanConnectionDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanConnectionDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanConnectionDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanSubcomponentPropertyReference, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanSubcomponentPropertyReference& val_)
      {
        return os_ << "Deployment::PlanSubcomponentPropertyReference"
                   << '{'
                   << "propertyName=" << IDL::traits< std::string>::write(val_.propertyName ())
                   << ",instanceRef=" << IDL::traits< uint32_t>::write(val_.instanceRef ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanSubcomponentPropertyReference, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanPropertyMapping, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanPropertyMapping& val_)
      {
        return os_ << "Deployment::PlanPropertyMapping"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
                   << ",externalName=" << IDL::traits< std::string>::write(val_.externalName ())
                   << ",delegatesTo=" << IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::write(val_.delegatesTo ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanPropertyMapping>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanPropertyMapping>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanPropertyMapping, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanPropertyMapping>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ImplementationDependency, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ImplementationDependency& val_)
      {
        return os_ << "Deployment::ImplementationDependency"
                   << '{'
                   << "requiredType=" << IDL::traits< std::string>::write(val_.requiredType ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ImplementationDependency>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ImplementationDependency>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ImplementationDependency, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ImplementationDependency>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ResourceDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ResourceDeploymentDescription& val_)
      {
        return os_ << "Deployment::ResourceDeploymentDescription"
                   << '{'
                   << "requirementName=" << IDL::traits< std::string>::write(val_.requirementName ())
                   << ",resourceName=" << IDL::traits< std::string>::write(val_.resourceName ())
                   << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ResourceDeploymentDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ResourceDeploymentDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ResourceDeploymentDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ResourceDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ArtifactDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ArtifactDeploymentDescription& val_)
      {
        return os_ << "Deployment::ArtifactDeploymentDescription"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",location=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.location ())
                   << ",node=" << IDL::traits< std::string>::write(val_.node ())
                   << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
                   << ",execParameter=" << IDL::traits< ::Deployment::Properties>::write(val_.execParameter ())
                   << ",deployRequirement=" << IDL::traits< ::Deployment::Requirements>::write(val_.deployRequirement ())
                   << ",deployedResource=" << IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::write(val_.deployedResource ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ArtifactDeploymentDescription>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ArtifactDeploymentDescription>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ArtifactDeploymentDescription, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ArtifactDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanLocality, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanLocality& val_)
      {
        return os_ << "Deployment::PlanLocality"
                   << '{'
                   << "constraint=" << IDL::traits< ::Deployment::PlanLocalityKind>::write(val_.constraint ())
                   << ",constrainedInstanceRef=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::ULongSeq>::write(val_.constrainedInstanceRef ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanLocality>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::PlanLocality>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::PlanLocality, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::PlanLocality>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::DeploymentPlan, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::DeploymentPlan& val_)
      {
        return os_ << "Deployment::DeploymentPlan"
                   << '{'
                   << "label=" << IDL::traits< std::string>::write(val_.label ())
                   << ",UUID=" << IDL::traits< std::string>::write(val_.UUID ())
                   << ",realizes=" << IDL::traits< ::Deployment::ComponentInterfaceDescription>::write(val_.realizes ())
                   << ",implementation=" << IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::write(val_.implementation ())
                   << ",instance=" << IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::write(val_.instance ())
                   << ",connection=" << IDL::traits< ::Deployment::PlanConnectionDescriptions>::write(val_.connection ())
                   << ",externalProperty=" << IDL::traits< ::Deployment::PlanPropertyMappings>::write(val_.externalProperty ())
                   << ",dependsOn=" << IDL::traits< ::Deployment::ImplementationDependencies>::write(val_.dependsOn ())
                   << ",artifact=" << IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::write(val_.artifact ())
                   << ",infoProperty=" << IDL::traits< ::Deployment::Properties>::write(val_.infoProperty ())
                   << ",localityConstraint=" << IDL::traits< ::Deployment::PlanLocalities>::write(val_.localityConstraint ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::DeploymentPlan>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::DeploymentPlan>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::DeploymentPlan, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::DeploymentPlan>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPackageReference, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentPackageReference& val_)
      {
        return os_ << "Deployment::ComponentPackageReference"
                   << '{'
                   << "requiredUUID=" << IDL::traits< std::string>::write(val_.requiredUUID ())
                   << ",requiredName=" << IDL::traits< std::string>::write(val_.requiredName ())
                   << ",requiredType=" << IDL::traits< ::Deployment::ComponentInterfaceDescription>::write(val_.requiredType ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPackageReference>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ComponentPackageReference>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ComponentPackageReference, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ComponentPackageReference>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::ImplementationRequirement, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ImplementationRequirement& val_)
      {
        return os_ << "Deployment::ImplementationRequirement"
                   << '{'
                   << "resourceUsage=" << IDL::traits< ::Deployment::ResourceUsageKinds>::write(val_.resourceUsage ())
                   << ",resourcePort=" << IDL::traits< std::string>::write(val_.resourcePort ())
                   << ",componentPort=" << IDL::traits< std::string>::write(val_.componentPort ())
                   << ",name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",resourceType=" << IDL::traits< std::string>::write(val_.resourceType ())
                   << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ImplementationRequirement>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::ImplementationRequirement>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::ImplementationRequirement, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::ImplementationRequirement>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Deployment::Capability, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::Capability& val_)
      {
        return os_ << "Deployment::Capability"
                   << '{'
                   << "name=" << IDL::traits< std::string>::write(val_.name ())
                   << ",resourceType=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.resourceType ())
                   << ",property=" << IDL::traits< ::Deployment::SatisfierProperties>::write(val_.property ())
                   << '}';
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Capability>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Deployment::Capability>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Deployment::Capability, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Deployment::Capability>::write_on (
          os, w.val_,
          formatter_t ());
    }
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::Property& m1, ::Deployment::Property& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::Requirement& m1, ::Deployment::Requirement& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::SatisfierProperty& m1, ::Deployment::SatisfierProperty& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPortDescription& m1, ::Deployment::ComponentPortDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPropertyDescription& m1, ::Deployment::ComponentPropertyDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentInterfaceDescription& m1, ::Deployment::ComponentInterfaceDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::MonolithicDeploymentDescription& m1, ::Deployment::MonolithicDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::InstanceResourceDeploymentDescription& m1, ::Deployment::InstanceResourceDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::InstanceDeploymentDescription& m1, ::Deployment::InstanceDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentExternalPortEndpoint& m1, ::Deployment::ComponentExternalPortEndpoint& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanSubcomponentPortEndpoint& m1, ::Deployment::PlanSubcomponentPortEndpoint& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ExternalReferenceEndpoint& m1, ::Deployment::ExternalReferenceEndpoint& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ConnectionResourceDeploymentDescription& m1, ::Deployment::ConnectionResourceDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanConnectionDescription& m1, ::Deployment::PlanConnectionDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanSubcomponentPropertyReference& m1, ::Deployment::PlanSubcomponentPropertyReference& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanPropertyMapping& m1, ::Deployment::PlanPropertyMapping& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ImplementationDependency& m1, ::Deployment::ImplementationDependency& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ResourceDeploymentDescription& m1, ::Deployment::ResourceDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ArtifactDeploymentDescription& m1, ::Deployment::ArtifactDeploymentDescription& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::PlanLocality& m1, ::Deployment::PlanLocality& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::DeploymentPlan& m1, ::Deployment::DeploymentPlan& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ComponentPackageReference& m1, ::Deployment::ComponentPackageReference& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::ImplementationRequirement& m1, ::Deployment::ImplementationRequirement& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Deployment::Capability& m1, ::Deployment::Capability& m2);
} // namespace std

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::Property::Property (
  std::string name,
  TAOX11_NAMESPACE::CORBA::Any value)
  : name_ (std::move (name))
  , value_ (std::move (value))
{
}

inline void Deployment::Property::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::Property::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::Property::name () const { return this->name_; }
inline std::string& Deployment::Property::name () { return this->name_; }

inline void Deployment::Property::value (const TAOX11_NAMESPACE::CORBA::Any& _value) { this->value_ = _value; }
inline void Deployment::Property::value (TAOX11_NAMESPACE::CORBA::Any&& _value) { this->value_ = std::move (_value); }
inline const TAOX11_NAMESPACE::CORBA::Any& Deployment::Property::value () const { return this->value_; }
inline TAOX11_NAMESPACE::CORBA::Any& Deployment::Property::value () { return this->value_; }

inline void Deployment::Property::swap (::Deployment::Property& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->value_, s.value_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::Requirement::Requirement (
  std::string name,
  std::string resourceType,
  ::Deployment::Properties property)
  : name_ (std::move (name))
  , resourceType_ (std::move (resourceType))
  , property_ (std::move (property))
{
}

inline void Deployment::Requirement::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::Requirement::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::Requirement::name () const { return this->name_; }
inline std::string& Deployment::Requirement::name () { return this->name_; }

inline void Deployment::Requirement::resourceType (const std::string& _resourceType) { this->resourceType_ = _resourceType; }
inline void Deployment::Requirement::resourceType (std::string&& _resourceType) { this->resourceType_ = std::move (_resourceType); }
inline const std::string& Deployment::Requirement::resourceType () const { return this->resourceType_; }
inline std::string& Deployment::Requirement::resourceType () { return this->resourceType_; }

inline void Deployment::Requirement::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::Requirement::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::Requirement::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::Requirement::property () { return this->property_; }

inline void Deployment::Requirement::swap (::Deployment::Requirement& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::SatisfierProperty::SatisfierProperty (
  std::string name,
  ::Deployment::SatisfierPropertyKind kind,
  bool dynamic,
  TAOX11_NAMESPACE::CORBA::Any value)
  : name_ (std::move (name))
  , kind_ (std::move (kind))
  , dynamic_ (std::move (dynamic))
  , value_ (std::move (value))
{
}

inline void Deployment::SatisfierProperty::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::SatisfierProperty::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::SatisfierProperty::name () const { return this->name_; }
inline std::string& Deployment::SatisfierProperty::name () { return this->name_; }

inline void Deployment::SatisfierProperty::kind (::Deployment::SatisfierPropertyKind _kind) { this->kind_ = _kind; }
inline ::Deployment::SatisfierPropertyKind Deployment::SatisfierProperty::kind () const { return this->kind_; }
inline ::Deployment::SatisfierPropertyKind& Deployment::SatisfierProperty::kind () { return this->kind_; }

inline void Deployment::SatisfierProperty::dynamic (bool _dynamic) { this->dynamic_ = _dynamic; }
inline bool Deployment::SatisfierProperty::dynamic () const { return this->dynamic_; }
inline bool& Deployment::SatisfierProperty::dynamic () { return this->dynamic_; }

inline void Deployment::SatisfierProperty::value (const TAOX11_NAMESPACE::CORBA::Any& _value) { this->value_ = _value; }
inline void Deployment::SatisfierProperty::value (TAOX11_NAMESPACE::CORBA::Any&& _value) { this->value_ = std::move (_value); }
inline const TAOX11_NAMESPACE::CORBA::Any& Deployment::SatisfierProperty::value () const { return this->value_; }
inline TAOX11_NAMESPACE::CORBA::Any& Deployment::SatisfierProperty::value () { return this->value_; }

inline void Deployment::SatisfierProperty::swap (::Deployment::SatisfierProperty& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->dynamic_, s.dynamic_);
  std::swap (this->value_, s.value_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentPortDescription::ComponentPortDescription (
  std::string name,
  std::string specificType,
  ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
  bool provider,
  bool exclusiveProvider,
  bool exclusiveUser,
  bool optional,
  CCMComponentPortKind kind,
  ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam)
  : name_ (std::move (name))
  , specificType_ (std::move (specificType))
  , supportedType_ (std::move (supportedType))
  , provider_ (std::move (provider))
  , exclusiveProvider_ (std::move (exclusiveProvider))
  , exclusiveUser_ (std::move (exclusiveUser))
  , optional_ (std::move (optional))
  , kind_ (std::move (kind))
  , templateParam_ (std::move (templateParam))
{
}

inline void Deployment::ComponentPortDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ComponentPortDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ComponentPortDescription::name () const { return this->name_; }
inline std::string& Deployment::ComponentPortDescription::name () { return this->name_; }

inline void Deployment::ComponentPortDescription::specificType (const std::string& _specificType) { this->specificType_ = _specificType; }
inline void Deployment::ComponentPortDescription::specificType (std::string&& _specificType) { this->specificType_ = std::move (_specificType); }
inline const std::string& Deployment::ComponentPortDescription::specificType () const { return this->specificType_; }
inline std::string& Deployment::ComponentPortDescription::specificType () { return this->specificType_; }

inline void Deployment::ComponentPortDescription::supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType) { this->supportedType_ = _supportedType; }
inline void Deployment::ComponentPortDescription::supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType) { this->supportedType_ = std::move (_supportedType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::supportedType () const { return this->supportedType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::supportedType () { return this->supportedType_; }

inline void Deployment::ComponentPortDescription::provider (bool _provider) { this->provider_ = _provider; }
inline bool Deployment::ComponentPortDescription::provider () const { return this->provider_; }
inline bool& Deployment::ComponentPortDescription::provider () { return this->provider_; }

inline void Deployment::ComponentPortDescription::exclusiveProvider (bool _exclusiveProvider) { this->exclusiveProvider_ = _exclusiveProvider; }
inline bool Deployment::ComponentPortDescription::exclusiveProvider () const { return this->exclusiveProvider_; }
inline bool& Deployment::ComponentPortDescription::exclusiveProvider () { return this->exclusiveProvider_; }

inline void Deployment::ComponentPortDescription::exclusiveUser (bool _exclusiveUser) { this->exclusiveUser_ = _exclusiveUser; }
inline bool Deployment::ComponentPortDescription::exclusiveUser () const { return this->exclusiveUser_; }
inline bool& Deployment::ComponentPortDescription::exclusiveUser () { return this->exclusiveUser_; }

inline void Deployment::ComponentPortDescription::optional (bool _optional) { this->optional_ = _optional; }
inline bool Deployment::ComponentPortDescription::optional () const { return this->optional_; }
inline bool& Deployment::ComponentPortDescription::optional () { return this->optional_; }

inline void Deployment::ComponentPortDescription::kind (CCMComponentPortKind _kind) { this->kind_ = _kind; }
inline ::Deployment::CCMComponentPortKind Deployment::ComponentPortDescription::kind () const { return this->kind_; }
inline ::Deployment::CCMComponentPortKind& Deployment::ComponentPortDescription::kind () { return this->kind_; }

inline void Deployment::ComponentPortDescription::templateParam (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _templateParam) { this->templateParam_ = _templateParam; }
inline void Deployment::ComponentPortDescription::templateParam (::TAOX11_NAMESPACE::CORBA::StringSeq&& _templateParam) { this->templateParam_ = std::move (_templateParam); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::templateParam () const { return this->templateParam_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentPortDescription::templateParam () { return this->templateParam_; }

inline void Deployment::ComponentPortDescription::swap (::Deployment::ComponentPortDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->specificType_, s.specificType_);
  std::swap (this->supportedType_, s.supportedType_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->exclusiveProvider_, s.exclusiveProvider_);
  std::swap (this->exclusiveUser_, s.exclusiveUser_);
  std::swap (this->optional_, s.optional_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->templateParam_, s.templateParam_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentPropertyDescription::ComponentPropertyDescription (
  std::string name,
  TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type)
  : name_ (std::move (name))
  , type_ (std::move (type))
{
}

inline void Deployment::ComponentPropertyDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ComponentPropertyDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ComponentPropertyDescription::name () const { return this->name_; }
inline std::string& Deployment::ComponentPropertyDescription::name () { return this->name_; }

inline void Deployment::ComponentPropertyDescription::type (TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type _type) { this->type_ = _type; }
inline TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type Deployment::ComponentPropertyDescription::type () const { return this->type_; }
inline TAOX11_IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type& Deployment::ComponentPropertyDescription::type () { return this->type_; }

inline void Deployment::ComponentPropertyDescription::swap (::Deployment::ComponentPropertyDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->type_, s.type_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentInterfaceDescription::ComponentInterfaceDescription (
  std::string label,
  std::string UUID,
  std::string specificType,
  ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
  ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile,
  ::Deployment::Properties configProperty,
  ::Deployment::ComponentPortDescriptions port,
  ::Deployment::ComponentPropertyDescriptions property,
  ::Deployment::Properties infoProperty)
  : label_ (std::move (label))
  , UUID_ (std::move (UUID))
  , specificType_ (std::move (specificType))
  , supportedType_ (std::move (supportedType))
  , idlFile_ (std::move (idlFile))
  , configProperty_ (std::move (configProperty))
  , port_ (std::move (port))
  , property_ (std::move (property))
  , infoProperty_ (std::move (infoProperty))
{
}

inline void Deployment::ComponentInterfaceDescription::label (const std::string& _label) { this->label_ = _label; }
inline void Deployment::ComponentInterfaceDescription::label (std::string&& _label) { this->label_ = std::move (_label); }
inline const std::string& Deployment::ComponentInterfaceDescription::label () const { return this->label_; }
inline std::string& Deployment::ComponentInterfaceDescription::label () { return this->label_; }

inline void Deployment::ComponentInterfaceDescription::UUID (const std::string& _UUID) { this->UUID_ = _UUID; }
inline void Deployment::ComponentInterfaceDescription::UUID (std::string&& _UUID) { this->UUID_ = std::move (_UUID); }
inline const std::string& Deployment::ComponentInterfaceDescription::UUID () const { return this->UUID_; }
inline std::string& Deployment::ComponentInterfaceDescription::UUID () { return this->UUID_; }

inline void Deployment::ComponentInterfaceDescription::specificType (const std::string& _specificType) { this->specificType_ = _specificType; }
inline void Deployment::ComponentInterfaceDescription::specificType (std::string&& _specificType) { this->specificType_ = std::move (_specificType); }
inline const std::string& Deployment::ComponentInterfaceDescription::specificType () const { return this->specificType_; }
inline std::string& Deployment::ComponentInterfaceDescription::specificType () { return this->specificType_; }

inline void Deployment::ComponentInterfaceDescription::supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType) { this->supportedType_ = _supportedType; }
inline void Deployment::ComponentInterfaceDescription::supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType) { this->supportedType_ = std::move (_supportedType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::supportedType () const { return this->supportedType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::supportedType () { return this->supportedType_; }

inline void Deployment::ComponentInterfaceDescription::idlFile (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _idlFile) { this->idlFile_ = _idlFile; }
inline void Deployment::ComponentInterfaceDescription::idlFile (::TAOX11_NAMESPACE::CORBA::StringSeq&& _idlFile) { this->idlFile_ = std::move (_idlFile); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::idlFile () const { return this->idlFile_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ComponentInterfaceDescription::idlFile () { return this->idlFile_; }

inline void Deployment::ComponentInterfaceDescription::configProperty (const ::Deployment::Properties& _configProperty) { this->configProperty_ = _configProperty; }
inline void Deployment::ComponentInterfaceDescription::configProperty (::Deployment::Properties&& _configProperty) { this->configProperty_ = std::move (_configProperty); }
inline const ::Deployment::Properties& Deployment::ComponentInterfaceDescription::configProperty () const { return this->configProperty_; }
inline ::Deployment::Properties& Deployment::ComponentInterfaceDescription::configProperty () { return this->configProperty_; }

inline void Deployment::ComponentInterfaceDescription::port (const ::Deployment::ComponentPortDescriptions& _port) { this->port_ = _port; }
inline void Deployment::ComponentInterfaceDescription::port (::Deployment::ComponentPortDescriptions&& _port) { this->port_ = std::move (_port); }
inline const ::Deployment::ComponentPortDescriptions& Deployment::ComponentInterfaceDescription::port () const { return this->port_; }
inline ::Deployment::ComponentPortDescriptions& Deployment::ComponentInterfaceDescription::port () { return this->port_; }

inline void Deployment::ComponentInterfaceDescription::property (const ::Deployment::ComponentPropertyDescriptions& _property) { this->property_ = _property; }
inline void Deployment::ComponentInterfaceDescription::property (::Deployment::ComponentPropertyDescriptions&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::ComponentPropertyDescriptions& Deployment::ComponentInterfaceDescription::property () const { return this->property_; }
inline ::Deployment::ComponentPropertyDescriptions& Deployment::ComponentInterfaceDescription::property () { return this->property_; }

inline void Deployment::ComponentInterfaceDescription::infoProperty (const ::Deployment::Properties& _infoProperty) { this->infoProperty_ = _infoProperty; }
inline void Deployment::ComponentInterfaceDescription::infoProperty (::Deployment::Properties&& _infoProperty) { this->infoProperty_ = std::move (_infoProperty); }
inline const ::Deployment::Properties& Deployment::ComponentInterfaceDescription::infoProperty () const { return this->infoProperty_; }
inline ::Deployment::Properties& Deployment::ComponentInterfaceDescription::infoProperty () { return this->infoProperty_; }

inline void Deployment::ComponentInterfaceDescription::swap (::Deployment::ComponentInterfaceDescription& s)
{
  std::swap (this->label_, s.label_);
  std::swap (this->UUID_, s.UUID_);
  std::swap (this->specificType_, s.specificType_);
  std::swap (this->supportedType_, s.supportedType_);
  std::swap (this->idlFile_, s.idlFile_);
  std::swap (this->configProperty_, s.configProperty_);
  std::swap (this->port_, s.port_);
  std::swap (this->property_, s.property_);
  std::swap (this->infoProperty_, s.infoProperty_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::MonolithicDeploymentDescription::MonolithicDeploymentDescription (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef,
  ::Deployment::Properties execParameter,
  ::Deployment::Requirements deployRequirement)
  : name_ (std::move (name))
  , source_ (std::move (source))
  , artifactRef_ (std::move (artifactRef))
  , execParameter_ (std::move (execParameter))
  , deployRequirement_ (std::move (deployRequirement))
{
}

inline void Deployment::MonolithicDeploymentDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::MonolithicDeploymentDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::MonolithicDeploymentDescription::name () const { return this->name_; }
inline std::string& Deployment::MonolithicDeploymentDescription::name () { return this->name_; }

inline void Deployment::MonolithicDeploymentDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::MonolithicDeploymentDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::MonolithicDeploymentDescription::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::MonolithicDeploymentDescription::source () { return this->source_; }

inline void Deployment::MonolithicDeploymentDescription::artifactRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _artifactRef) { this->artifactRef_ = _artifactRef; }
inline void Deployment::MonolithicDeploymentDescription::artifactRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _artifactRef) { this->artifactRef_ = std::move (_artifactRef); }
inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::MonolithicDeploymentDescription::artifactRef () const { return this->artifactRef_; }
inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::MonolithicDeploymentDescription::artifactRef () { return this->artifactRef_; }

inline void Deployment::MonolithicDeploymentDescription::execParameter (const ::Deployment::Properties& _execParameter) { this->execParameter_ = _execParameter; }
inline void Deployment::MonolithicDeploymentDescription::execParameter (::Deployment::Properties&& _execParameter) { this->execParameter_ = std::move (_execParameter); }
inline const ::Deployment::Properties& Deployment::MonolithicDeploymentDescription::execParameter () const { return this->execParameter_; }
inline ::Deployment::Properties& Deployment::MonolithicDeploymentDescription::execParameter () { return this->execParameter_; }

inline void Deployment::MonolithicDeploymentDescription::deployRequirement (const ::Deployment::Requirements& _deployRequirement) { this->deployRequirement_ = _deployRequirement; }
inline void Deployment::MonolithicDeploymentDescription::deployRequirement (::Deployment::Requirements&& _deployRequirement) { this->deployRequirement_ = std::move (_deployRequirement); }
inline const ::Deployment::Requirements& Deployment::MonolithicDeploymentDescription::deployRequirement () const { return this->deployRequirement_; }
inline ::Deployment::Requirements& Deployment::MonolithicDeploymentDescription::deployRequirement () { return this->deployRequirement_; }

inline void Deployment::MonolithicDeploymentDescription::swap (::Deployment::MonolithicDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->artifactRef_, s.artifactRef_);
  std::swap (this->execParameter_, s.execParameter_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription (
  ::Deployment::ResourceUsageKind resourceUsage,
  std::string requirementName,
  std::string resourceName,
  ::Deployment::Properties property)
  : resourceUsage_ (std::move (resourceUsage))
  , requirementName_ (std::move (requirementName))
  , resourceName_ (std::move (resourceName))
  , property_ (std::move (property))
{
}

inline void Deployment::InstanceResourceDeploymentDescription::resourceUsage (::Deployment::ResourceUsageKind _resourceUsage) { this->resourceUsage_ = _resourceUsage; }
inline ::Deployment::ResourceUsageKind Deployment::InstanceResourceDeploymentDescription::resourceUsage () const { return this->resourceUsage_; }
inline ::Deployment::ResourceUsageKind& Deployment::InstanceResourceDeploymentDescription::resourceUsage () { return this->resourceUsage_; }

inline void Deployment::InstanceResourceDeploymentDescription::requirementName (const std::string& _requirementName) { this->requirementName_ = _requirementName; }
inline void Deployment::InstanceResourceDeploymentDescription::requirementName (std::string&& _requirementName) { this->requirementName_ = std::move (_requirementName); }
inline const std::string& Deployment::InstanceResourceDeploymentDescription::requirementName () const { return this->requirementName_; }
inline std::string& Deployment::InstanceResourceDeploymentDescription::requirementName () { return this->requirementName_; }

inline void Deployment::InstanceResourceDeploymentDescription::resourceName (const std::string& _resourceName) { this->resourceName_ = _resourceName; }
inline void Deployment::InstanceResourceDeploymentDescription::resourceName (std::string&& _resourceName) { this->resourceName_ = std::move (_resourceName); }
inline const std::string& Deployment::InstanceResourceDeploymentDescription::resourceName () const { return this->resourceName_; }
inline std::string& Deployment::InstanceResourceDeploymentDescription::resourceName () { return this->resourceName_; }

inline void Deployment::InstanceResourceDeploymentDescription::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::InstanceResourceDeploymentDescription::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::InstanceResourceDeploymentDescription::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::InstanceResourceDeploymentDescription::property () { return this->property_; }

inline void Deployment::InstanceResourceDeploymentDescription::swap (::Deployment::InstanceResourceDeploymentDescription& s)
{
  std::swap (this->resourceUsage_, s.resourceUsage_);
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::InstanceDeploymentDescription::InstanceDeploymentDescription (
  std::string name,
  std::string node,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  uint32_t implementationRef,
  ::Deployment::Properties configProperty,
  ::Deployment::InstanceResourceDeploymentDescriptions deployedResource,
  ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource)
  : name_ (std::move (name))
  , node_ (std::move (node))
  , source_ (std::move (source))
  , implementationRef_ (std::move (implementationRef))
  , configProperty_ (std::move (configProperty))
  , deployedResource_ (std::move (deployedResource))
  , deployedSharedResource_ (std::move (deployedSharedResource))
{
}

inline void Deployment::InstanceDeploymentDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::InstanceDeploymentDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::InstanceDeploymentDescription::name () const { return this->name_; }
inline std::string& Deployment::InstanceDeploymentDescription::name () { return this->name_; }

inline void Deployment::InstanceDeploymentDescription::node (const std::string& _node) { this->node_ = _node; }
inline void Deployment::InstanceDeploymentDescription::node (std::string&& _node) { this->node_ = std::move (_node); }
inline const std::string& Deployment::InstanceDeploymentDescription::node () const { return this->node_; }
inline std::string& Deployment::InstanceDeploymentDescription::node () { return this->node_; }

inline void Deployment::InstanceDeploymentDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::InstanceDeploymentDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::InstanceDeploymentDescription::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::InstanceDeploymentDescription::source () { return this->source_; }

inline void Deployment::InstanceDeploymentDescription::implementationRef (uint32_t _implementationRef) { this->implementationRef_ = _implementationRef; }
inline uint32_t Deployment::InstanceDeploymentDescription::implementationRef () const { return this->implementationRef_; }
inline uint32_t& Deployment::InstanceDeploymentDescription::implementationRef () { return this->implementationRef_; }

inline void Deployment::InstanceDeploymentDescription::configProperty (const ::Deployment::Properties& _configProperty) { this->configProperty_ = _configProperty; }
inline void Deployment::InstanceDeploymentDescription::configProperty (::Deployment::Properties&& _configProperty) { this->configProperty_ = std::move (_configProperty); }
inline const ::Deployment::Properties& Deployment::InstanceDeploymentDescription::configProperty () const { return this->configProperty_; }
inline ::Deployment::Properties& Deployment::InstanceDeploymentDescription::configProperty () { return this->configProperty_; }

inline void Deployment::InstanceDeploymentDescription::deployedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedResource) { this->deployedResource_ = _deployedResource; }
inline void Deployment::InstanceDeploymentDescription::deployedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedResource) { this->deployedResource_ = std::move (_deployedResource); }
inline const ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedResource () const { return this->deployedResource_; }
inline ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedResource () { return this->deployedResource_; }

inline void Deployment::InstanceDeploymentDescription::deployedSharedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _deployedSharedResource) { this->deployedSharedResource_ = _deployedSharedResource; }
inline void Deployment::InstanceDeploymentDescription::deployedSharedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _deployedSharedResource) { this->deployedSharedResource_ = std::move (_deployedSharedResource); }
inline const ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedSharedResource () const { return this->deployedSharedResource_; }
inline ::Deployment::InstanceResourceDeploymentDescriptions& Deployment::InstanceDeploymentDescription::deployedSharedResource () { return this->deployedSharedResource_; }

inline void Deployment::InstanceDeploymentDescription::swap (::Deployment::InstanceDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->node_, s.node_);
  std::swap (this->source_, s.source_);
  std::swap (this->implementationRef_, s.implementationRef_);
  std::swap (this->configProperty_, s.configProperty_);
  std::swap (this->deployedResource_, s.deployedResource_);
  std::swap (this->deployedSharedResource_, s.deployedSharedResource_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentExternalPortEndpoint::ComponentExternalPortEndpoint (
  std::string portName)
  : portName_ (std::move (portName))
{
}

inline void Deployment::ComponentExternalPortEndpoint::portName (const std::string& _portName) { this->portName_ = _portName; }
inline void Deployment::ComponentExternalPortEndpoint::portName (std::string&& _portName) { this->portName_ = std::move (_portName); }
inline const std::string& Deployment::ComponentExternalPortEndpoint::portName () const { return this->portName_; }
inline std::string& Deployment::ComponentExternalPortEndpoint::portName () { return this->portName_; }

inline void Deployment::ComponentExternalPortEndpoint::swap (::Deployment::ComponentExternalPortEndpoint& s)
{
  std::swap (this->portName_, s.portName_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint (
  std::string portName,
  bool provider,
  ::Deployment::CCMComponentPortKind kind,
  uint32_t instanceRef)
  : portName_ (std::move (portName))
  , provider_ (std::move (provider))
  , kind_ (std::move (kind))
  , instanceRef_ (std::move (instanceRef))
{
}

inline void Deployment::PlanSubcomponentPortEndpoint::portName (const std::string& _portName) { this->portName_ = _portName; }
inline void Deployment::PlanSubcomponentPortEndpoint::portName (std::string&& _portName) { this->portName_ = std::move (_portName); }
inline const std::string& Deployment::PlanSubcomponentPortEndpoint::portName () const { return this->portName_; }
inline std::string& Deployment::PlanSubcomponentPortEndpoint::portName () { return this->portName_; }

inline void Deployment::PlanSubcomponentPortEndpoint::provider (bool _provider) { this->provider_ = _provider; }
inline bool Deployment::PlanSubcomponentPortEndpoint::provider () const { return this->provider_; }
inline bool& Deployment::PlanSubcomponentPortEndpoint::provider () { return this->provider_; }

inline void Deployment::PlanSubcomponentPortEndpoint::kind (::Deployment::CCMComponentPortKind _kind) { this->kind_ = _kind; }
inline ::Deployment::CCMComponentPortKind Deployment::PlanSubcomponentPortEndpoint::kind () const { return this->kind_; }
inline ::Deployment::CCMComponentPortKind& Deployment::PlanSubcomponentPortEndpoint::kind () { return this->kind_; }

inline void Deployment::PlanSubcomponentPortEndpoint::instanceRef (uint32_t _instanceRef) { this->instanceRef_ = _instanceRef; }
inline uint32_t Deployment::PlanSubcomponentPortEndpoint::instanceRef () const { return this->instanceRef_; }
inline uint32_t& Deployment::PlanSubcomponentPortEndpoint::instanceRef () { return this->instanceRef_; }

inline void Deployment::PlanSubcomponentPortEndpoint::swap (::Deployment::PlanSubcomponentPortEndpoint& s)
{
  std::swap (this->portName_, s.portName_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->instanceRef_, s.instanceRef_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ExternalReferenceEndpoint::ExternalReferenceEndpoint (
  std::string location,
  bool provider,
  std::string portName,
  ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType)
  : location_ (std::move (location))
  , provider_ (std::move (provider))
  , portName_ (std::move (portName))
  , supportedType_ (std::move (supportedType))
{
}

inline void Deployment::ExternalReferenceEndpoint::location (const std::string& _location) { this->location_ = _location; }
inline void Deployment::ExternalReferenceEndpoint::location (std::string&& _location) { this->location_ = std::move (_location); }
inline const std::string& Deployment::ExternalReferenceEndpoint::location () const { return this->location_; }
inline std::string& Deployment::ExternalReferenceEndpoint::location () { return this->location_; }

inline void Deployment::ExternalReferenceEndpoint::provider (bool _provider) { this->provider_ = _provider; }
inline bool Deployment::ExternalReferenceEndpoint::provider () const { return this->provider_; }
inline bool& Deployment::ExternalReferenceEndpoint::provider () { return this->provider_; }

inline void Deployment::ExternalReferenceEndpoint::portName (const std::string& _portName) { this->portName_ = _portName; }
inline void Deployment::ExternalReferenceEndpoint::portName (std::string&& _portName) { this->portName_ = std::move (_portName); }
inline const std::string& Deployment::ExternalReferenceEndpoint::portName () const { return this->portName_; }
inline std::string& Deployment::ExternalReferenceEndpoint::portName () { return this->portName_; }

inline void Deployment::ExternalReferenceEndpoint::supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _supportedType) { this->supportedType_ = _supportedType; }
inline void Deployment::ExternalReferenceEndpoint::supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _supportedType) { this->supportedType_ = std::move (_supportedType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ExternalReferenceEndpoint::supportedType () const { return this->supportedType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ExternalReferenceEndpoint::supportedType () { return this->supportedType_; }

inline void Deployment::ExternalReferenceEndpoint::swap (::Deployment::ExternalReferenceEndpoint& s)
{
  std::swap (this->location_, s.location_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->portName_, s.portName_);
  std::swap (this->supportedType_, s.supportedType_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription (
  std::string targetName,
  std::string requirementName,
  std::string resourceName,
  ::Deployment::Properties property)
  : targetName_ (std::move (targetName))
  , requirementName_ (std::move (requirementName))
  , resourceName_ (std::move (resourceName))
  , property_ (std::move (property))
{
}

inline void Deployment::ConnectionResourceDeploymentDescription::targetName (const std::string& _targetName) { this->targetName_ = _targetName; }
inline void Deployment::ConnectionResourceDeploymentDescription::targetName (std::string&& _targetName) { this->targetName_ = std::move (_targetName); }
inline const std::string& Deployment::ConnectionResourceDeploymentDescription::targetName () const { return this->targetName_; }
inline std::string& Deployment::ConnectionResourceDeploymentDescription::targetName () { return this->targetName_; }

inline void Deployment::ConnectionResourceDeploymentDescription::requirementName (const std::string& _requirementName) { this->requirementName_ = _requirementName; }
inline void Deployment::ConnectionResourceDeploymentDescription::requirementName (std::string&& _requirementName) { this->requirementName_ = std::move (_requirementName); }
inline const std::string& Deployment::ConnectionResourceDeploymentDescription::requirementName () const { return this->requirementName_; }
inline std::string& Deployment::ConnectionResourceDeploymentDescription::requirementName () { return this->requirementName_; }

inline void Deployment::ConnectionResourceDeploymentDescription::resourceName (const std::string& _resourceName) { this->resourceName_ = _resourceName; }
inline void Deployment::ConnectionResourceDeploymentDescription::resourceName (std::string&& _resourceName) { this->resourceName_ = std::move (_resourceName); }
inline const std::string& Deployment::ConnectionResourceDeploymentDescription::resourceName () const { return this->resourceName_; }
inline std::string& Deployment::ConnectionResourceDeploymentDescription::resourceName () { return this->resourceName_; }

inline void Deployment::ConnectionResourceDeploymentDescription::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::ConnectionResourceDeploymentDescription::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::ConnectionResourceDeploymentDescription::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::ConnectionResourceDeploymentDescription::property () { return this->property_; }

inline void Deployment::ConnectionResourceDeploymentDescription::swap (::Deployment::ConnectionResourceDeploymentDescription& s)
{
  std::swap (this->targetName_, s.targetName_);
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanConnectionDescription::PlanConnectionDescription (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  ::Deployment::Requirements deployRequirement,
  ::Deployment::ComponentExternalPortEndpoints externalEndpoint,
  ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint,
  ::Deployment::ExternalReferenceEndpoints externalReference,
  ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource)
  : name_ (std::move (name))
  , source_ (std::move (source))
  , deployRequirement_ (std::move (deployRequirement))
  , externalEndpoint_ (std::move (externalEndpoint))
  , internalEndpoint_ (std::move (internalEndpoint))
  , externalReference_ (std::move (externalReference))
  , deployedResource_ (std::move (deployedResource))
{
}

inline void Deployment::PlanConnectionDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::PlanConnectionDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::PlanConnectionDescription::name () const { return this->name_; }
inline std::string& Deployment::PlanConnectionDescription::name () { return this->name_; }

inline void Deployment::PlanConnectionDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::PlanConnectionDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanConnectionDescription::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanConnectionDescription::source () { return this->source_; }

inline void Deployment::PlanConnectionDescription::deployRequirement (const ::Deployment::Requirements& _deployRequirement) { this->deployRequirement_ = _deployRequirement; }
inline void Deployment::PlanConnectionDescription::deployRequirement (::Deployment::Requirements&& _deployRequirement) { this->deployRequirement_ = std::move (_deployRequirement); }
inline const ::Deployment::Requirements& Deployment::PlanConnectionDescription::deployRequirement () const { return this->deployRequirement_; }
inline ::Deployment::Requirements& Deployment::PlanConnectionDescription::deployRequirement () { return this->deployRequirement_; }

inline void Deployment::PlanConnectionDescription::externalEndpoint (const ::Deployment::ComponentExternalPortEndpoints& _externalEndpoint) { this->externalEndpoint_ = _externalEndpoint; }
inline void Deployment::PlanConnectionDescription::externalEndpoint (::Deployment::ComponentExternalPortEndpoints&& _externalEndpoint) { this->externalEndpoint_ = std::move (_externalEndpoint); }
inline const ::Deployment::ComponentExternalPortEndpoints& Deployment::PlanConnectionDescription::externalEndpoint () const { return this->externalEndpoint_; }
inline ::Deployment::ComponentExternalPortEndpoints& Deployment::PlanConnectionDescription::externalEndpoint () { return this->externalEndpoint_; }

inline void Deployment::PlanConnectionDescription::internalEndpoint (const ::Deployment::PlanSubcomponentPortEndpoints& _internalEndpoint) { this->internalEndpoint_ = _internalEndpoint; }
inline void Deployment::PlanConnectionDescription::internalEndpoint (::Deployment::PlanSubcomponentPortEndpoints&& _internalEndpoint) { this->internalEndpoint_ = std::move (_internalEndpoint); }
inline const ::Deployment::PlanSubcomponentPortEndpoints& Deployment::PlanConnectionDescription::internalEndpoint () const { return this->internalEndpoint_; }
inline ::Deployment::PlanSubcomponentPortEndpoints& Deployment::PlanConnectionDescription::internalEndpoint () { return this->internalEndpoint_; }

inline void Deployment::PlanConnectionDescription::externalReference (const ::Deployment::ExternalReferenceEndpoints& _externalReference) { this->externalReference_ = _externalReference; }
inline void Deployment::PlanConnectionDescription::externalReference (::Deployment::ExternalReferenceEndpoints&& _externalReference) { this->externalReference_ = std::move (_externalReference); }
inline const ::Deployment::ExternalReferenceEndpoints& Deployment::PlanConnectionDescription::externalReference () const { return this->externalReference_; }
inline ::Deployment::ExternalReferenceEndpoints& Deployment::PlanConnectionDescription::externalReference () { return this->externalReference_; }

inline void Deployment::PlanConnectionDescription::deployedResource (const ::Deployment::ConnectionResourceDeploymentDescriptions& _deployedResource) { this->deployedResource_ = _deployedResource; }
inline void Deployment::PlanConnectionDescription::deployedResource (::Deployment::ConnectionResourceDeploymentDescriptions&& _deployedResource) { this->deployedResource_ = std::move (_deployedResource); }
inline const ::Deployment::ConnectionResourceDeploymentDescriptions& Deployment::PlanConnectionDescription::deployedResource () const { return this->deployedResource_; }
inline ::Deployment::ConnectionResourceDeploymentDescriptions& Deployment::PlanConnectionDescription::deployedResource () { return this->deployedResource_; }

inline void Deployment::PlanConnectionDescription::swap (::Deployment::PlanConnectionDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
  std::swap (this->externalEndpoint_, s.externalEndpoint_);
  std::swap (this->internalEndpoint_, s.internalEndpoint_);
  std::swap (this->externalReference_, s.externalReference_);
  std::swap (this->deployedResource_, s.deployedResource_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanSubcomponentPropertyReference::PlanSubcomponentPropertyReference (
  std::string propertyName,
  uint32_t instanceRef)
  : propertyName_ (std::move (propertyName))
  , instanceRef_ (std::move (instanceRef))
{
}

inline void Deployment::PlanSubcomponentPropertyReference::propertyName (const std::string& _propertyName) { this->propertyName_ = _propertyName; }
inline void Deployment::PlanSubcomponentPropertyReference::propertyName (std::string&& _propertyName) { this->propertyName_ = std::move (_propertyName); }
inline const std::string& Deployment::PlanSubcomponentPropertyReference::propertyName () const { return this->propertyName_; }
inline std::string& Deployment::PlanSubcomponentPropertyReference::propertyName () { return this->propertyName_; }

inline void Deployment::PlanSubcomponentPropertyReference::instanceRef (uint32_t _instanceRef) { this->instanceRef_ = _instanceRef; }
inline uint32_t Deployment::PlanSubcomponentPropertyReference::instanceRef () const { return this->instanceRef_; }
inline uint32_t& Deployment::PlanSubcomponentPropertyReference::instanceRef () { return this->instanceRef_; }

inline void Deployment::PlanSubcomponentPropertyReference::swap (::Deployment::PlanSubcomponentPropertyReference& s)
{
  std::swap (this->propertyName_, s.propertyName_);
  std::swap (this->instanceRef_, s.instanceRef_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanPropertyMapping::PlanPropertyMapping (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  std::string externalName,
  ::Deployment::PlanSubcomponentPropertyReferences delegatesTo)
  : name_ (std::move (name))
  , source_ (std::move (source))
  , externalName_ (std::move (externalName))
  , delegatesTo_ (std::move (delegatesTo))
{
}

inline void Deployment::PlanPropertyMapping::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::PlanPropertyMapping::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::PlanPropertyMapping::name () const { return this->name_; }
inline std::string& Deployment::PlanPropertyMapping::name () { return this->name_; }

inline void Deployment::PlanPropertyMapping::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::PlanPropertyMapping::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanPropertyMapping::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::PlanPropertyMapping::source () { return this->source_; }

inline void Deployment::PlanPropertyMapping::externalName (const std::string& _externalName) { this->externalName_ = _externalName; }
inline void Deployment::PlanPropertyMapping::externalName (std::string&& _externalName) { this->externalName_ = std::move (_externalName); }
inline const std::string& Deployment::PlanPropertyMapping::externalName () const { return this->externalName_; }
inline std::string& Deployment::PlanPropertyMapping::externalName () { return this->externalName_; }

inline void Deployment::PlanPropertyMapping::delegatesTo (const ::Deployment::PlanSubcomponentPropertyReferences& _delegatesTo) { this->delegatesTo_ = _delegatesTo; }
inline void Deployment::PlanPropertyMapping::delegatesTo (::Deployment::PlanSubcomponentPropertyReferences&& _delegatesTo) { this->delegatesTo_ = std::move (_delegatesTo); }
inline const ::Deployment::PlanSubcomponentPropertyReferences& Deployment::PlanPropertyMapping::delegatesTo () const { return this->delegatesTo_; }
inline ::Deployment::PlanSubcomponentPropertyReferences& Deployment::PlanPropertyMapping::delegatesTo () { return this->delegatesTo_; }

inline void Deployment::PlanPropertyMapping::swap (::Deployment::PlanPropertyMapping& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->externalName_, s.externalName_);
  std::swap (this->delegatesTo_, s.delegatesTo_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ImplementationDependency::ImplementationDependency (
  std::string requiredType)
  : requiredType_ (std::move (requiredType))
{
}

inline void Deployment::ImplementationDependency::requiredType (const std::string& _requiredType) { this->requiredType_ = _requiredType; }
inline void Deployment::ImplementationDependency::requiredType (std::string&& _requiredType) { this->requiredType_ = std::move (_requiredType); }
inline const std::string& Deployment::ImplementationDependency::requiredType () const { return this->requiredType_; }
inline std::string& Deployment::ImplementationDependency::requiredType () { return this->requiredType_; }

inline void Deployment::ImplementationDependency::swap (::Deployment::ImplementationDependency& s)
{
  std::swap (this->requiredType_, s.requiredType_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ResourceDeploymentDescription::ResourceDeploymentDescription (
  std::string requirementName,
  std::string resourceName,
  ::Deployment::Properties property)
  : requirementName_ (std::move (requirementName))
  , resourceName_ (std::move (resourceName))
  , property_ (std::move (property))
{
}

inline void Deployment::ResourceDeploymentDescription::requirementName (const std::string& _requirementName) { this->requirementName_ = _requirementName; }
inline void Deployment::ResourceDeploymentDescription::requirementName (std::string&& _requirementName) { this->requirementName_ = std::move (_requirementName); }
inline const std::string& Deployment::ResourceDeploymentDescription::requirementName () const { return this->requirementName_; }
inline std::string& Deployment::ResourceDeploymentDescription::requirementName () { return this->requirementName_; }

inline void Deployment::ResourceDeploymentDescription::resourceName (const std::string& _resourceName) { this->resourceName_ = _resourceName; }
inline void Deployment::ResourceDeploymentDescription::resourceName (std::string&& _resourceName) { this->resourceName_ = std::move (_resourceName); }
inline const std::string& Deployment::ResourceDeploymentDescription::resourceName () const { return this->resourceName_; }
inline std::string& Deployment::ResourceDeploymentDescription::resourceName () { return this->resourceName_; }

inline void Deployment::ResourceDeploymentDescription::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::ResourceDeploymentDescription::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::ResourceDeploymentDescription::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::ResourceDeploymentDescription::property () { return this->property_; }

inline void Deployment::ResourceDeploymentDescription::swap (::Deployment::ResourceDeploymentDescription& s)
{
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ArtifactDeploymentDescription::ArtifactDeploymentDescription (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq location,
  std::string node,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  ::Deployment::Properties execParameter,
  ::Deployment::Requirements deployRequirement,
  ::Deployment::ResourceDeploymentDescriptions deployedResource)
  : name_ (std::move (name))
  , location_ (std::move (location))
  , node_ (std::move (node))
  , source_ (std::move (source))
  , execParameter_ (std::move (execParameter))
  , deployRequirement_ (std::move (deployRequirement))
  , deployedResource_ (std::move (deployedResource))
{
}

inline void Deployment::ArtifactDeploymentDescription::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ArtifactDeploymentDescription::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ArtifactDeploymentDescription::name () const { return this->name_; }
inline std::string& Deployment::ArtifactDeploymentDescription::name () { return this->name_; }

inline void Deployment::ArtifactDeploymentDescription::location (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _location) { this->location_ = _location; }
inline void Deployment::ArtifactDeploymentDescription::location (::TAOX11_NAMESPACE::CORBA::StringSeq&& _location) { this->location_ = std::move (_location); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::location () const { return this->location_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::location () { return this->location_; }

inline void Deployment::ArtifactDeploymentDescription::node (const std::string& _node) { this->node_ = _node; }
inline void Deployment::ArtifactDeploymentDescription::node (std::string&& _node) { this->node_ = std::move (_node); }
inline const std::string& Deployment::ArtifactDeploymentDescription::node () const { return this->node_; }
inline std::string& Deployment::ArtifactDeploymentDescription::node () { return this->node_; }

inline void Deployment::ArtifactDeploymentDescription::source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _source) { this->source_ = _source; }
inline void Deployment::ArtifactDeploymentDescription::source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _source) { this->source_ = std::move (_source); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::source () const { return this->source_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::ArtifactDeploymentDescription::source () { return this->source_; }

inline void Deployment::ArtifactDeploymentDescription::execParameter (const ::Deployment::Properties& _execParameter) { this->execParameter_ = _execParameter; }
inline void Deployment::ArtifactDeploymentDescription::execParameter (::Deployment::Properties&& _execParameter) { this->execParameter_ = std::move (_execParameter); }
inline const ::Deployment::Properties& Deployment::ArtifactDeploymentDescription::execParameter () const { return this->execParameter_; }
inline ::Deployment::Properties& Deployment::ArtifactDeploymentDescription::execParameter () { return this->execParameter_; }

inline void Deployment::ArtifactDeploymentDescription::deployRequirement (const ::Deployment::Requirements& _deployRequirement) { this->deployRequirement_ = _deployRequirement; }
inline void Deployment::ArtifactDeploymentDescription::deployRequirement (::Deployment::Requirements&& _deployRequirement) { this->deployRequirement_ = std::move (_deployRequirement); }
inline const ::Deployment::Requirements& Deployment::ArtifactDeploymentDescription::deployRequirement () const { return this->deployRequirement_; }
inline ::Deployment::Requirements& Deployment::ArtifactDeploymentDescription::deployRequirement () { return this->deployRequirement_; }

inline void Deployment::ArtifactDeploymentDescription::deployedResource (const ::Deployment::ResourceDeploymentDescriptions& _deployedResource) { this->deployedResource_ = _deployedResource; }
inline void Deployment::ArtifactDeploymentDescription::deployedResource (::Deployment::ResourceDeploymentDescriptions&& _deployedResource) { this->deployedResource_ = std::move (_deployedResource); }
inline const ::Deployment::ResourceDeploymentDescriptions& Deployment::ArtifactDeploymentDescription::deployedResource () const { return this->deployedResource_; }
inline ::Deployment::ResourceDeploymentDescriptions& Deployment::ArtifactDeploymentDescription::deployedResource () { return this->deployedResource_; }

inline void Deployment::ArtifactDeploymentDescription::swap (::Deployment::ArtifactDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->location_, s.location_);
  std::swap (this->node_, s.node_);
  std::swap (this->source_, s.source_);
  std::swap (this->execParameter_, s.execParameter_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
  std::swap (this->deployedResource_, s.deployedResource_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::PlanLocality::PlanLocality (
  ::Deployment::PlanLocalityKind constraint,
  ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef)
  : constraint_ (std::move (constraint))
  , constrainedInstanceRef_ (std::move (constrainedInstanceRef))
{
}

inline void Deployment::PlanLocality::constraint (::Deployment::PlanLocalityKind _constraint) { this->constraint_ = _constraint; }
inline ::Deployment::PlanLocalityKind Deployment::PlanLocality::constraint () const { return this->constraint_; }
inline ::Deployment::PlanLocalityKind& Deployment::PlanLocality::constraint () { return this->constraint_; }

inline void Deployment::PlanLocality::constrainedInstanceRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _constrainedInstanceRef) { this->constrainedInstanceRef_ = _constrainedInstanceRef; }
inline void Deployment::PlanLocality::constrainedInstanceRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _constrainedInstanceRef) { this->constrainedInstanceRef_ = std::move (_constrainedInstanceRef); }
inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::PlanLocality::constrainedInstanceRef () const { return this->constrainedInstanceRef_; }
inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& Deployment::PlanLocality::constrainedInstanceRef () { return this->constrainedInstanceRef_; }

inline void Deployment::PlanLocality::swap (::Deployment::PlanLocality& s)
{
  std::swap (this->constraint_, s.constraint_);
  std::swap (this->constrainedInstanceRef_, s.constrainedInstanceRef_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::DeploymentPlan::DeploymentPlan (
  std::string label,
  std::string UUID,
  ::Deployment::ComponentInterfaceDescription realizes,
  ::Deployment::MonolithicDeploymentDescriptions implementation,
  ::Deployment::InstanceDeploymentDescriptions instance,
  ::Deployment::PlanConnectionDescriptions connection,
  ::Deployment::PlanPropertyMappings externalProperty,
  ::Deployment::ImplementationDependencies dependsOn,
  ::Deployment::ArtifactDeploymentDescriptions artifact,
  ::Deployment::Properties infoProperty,
  ::Deployment::PlanLocalities localityConstraint)
  : label_ (std::move (label))
  , UUID_ (std::move (UUID))
  , realizes_ (std::move (realizes))
  , implementation_ (std::move (implementation))
  , instance_ (std::move (instance))
  , connection_ (std::move (connection))
  , externalProperty_ (std::move (externalProperty))
  , dependsOn_ (std::move (dependsOn))
  , artifact_ (std::move (artifact))
  , infoProperty_ (std::move (infoProperty))
  , localityConstraint_ (std::move (localityConstraint))
{
}

inline void Deployment::DeploymentPlan::label (const std::string& _label) { this->label_ = _label; }
inline void Deployment::DeploymentPlan::label (std::string&& _label) { this->label_ = std::move (_label); }
inline const std::string& Deployment::DeploymentPlan::label () const { return this->label_; }
inline std::string& Deployment::DeploymentPlan::label () { return this->label_; }

inline void Deployment::DeploymentPlan::UUID (const std::string& _UUID) { this->UUID_ = _UUID; }
inline void Deployment::DeploymentPlan::UUID (std::string&& _UUID) { this->UUID_ = std::move (_UUID); }
inline const std::string& Deployment::DeploymentPlan::UUID () const { return this->UUID_; }
inline std::string& Deployment::DeploymentPlan::UUID () { return this->UUID_; }

inline void Deployment::DeploymentPlan::realizes (const ::Deployment::ComponentInterfaceDescription& _realizes) { this->realizes_ = _realizes; }
inline void Deployment::DeploymentPlan::realizes (::Deployment::ComponentInterfaceDescription&& _realizes) { this->realizes_ = std::move (_realizes); }
inline const ::Deployment::ComponentInterfaceDescription& Deployment::DeploymentPlan::realizes () const { return this->realizes_; }
inline ::Deployment::ComponentInterfaceDescription& Deployment::DeploymentPlan::realizes () { return this->realizes_; }

inline void Deployment::DeploymentPlan::implementation (const ::Deployment::MonolithicDeploymentDescriptions& _implementation) { this->implementation_ = _implementation; }
inline void Deployment::DeploymentPlan::implementation (::Deployment::MonolithicDeploymentDescriptions&& _implementation) { this->implementation_ = std::move (_implementation); }
inline const ::Deployment::MonolithicDeploymentDescriptions& Deployment::DeploymentPlan::implementation () const { return this->implementation_; }
inline ::Deployment::MonolithicDeploymentDescriptions& Deployment::DeploymentPlan::implementation () { return this->implementation_; }

inline void Deployment::DeploymentPlan::instance (const ::Deployment::InstanceDeploymentDescriptions& _instance) { this->instance_ = _instance; }
inline void Deployment::DeploymentPlan::instance (::Deployment::InstanceDeploymentDescriptions&& _instance) { this->instance_ = std::move (_instance); }
inline const ::Deployment::InstanceDeploymentDescriptions& Deployment::DeploymentPlan::instance () const { return this->instance_; }
inline ::Deployment::InstanceDeploymentDescriptions& Deployment::DeploymentPlan::instance () { return this->instance_; }

inline void Deployment::DeploymentPlan::connection (const ::Deployment::PlanConnectionDescriptions& _connection) { this->connection_ = _connection; }
inline void Deployment::DeploymentPlan::connection (::Deployment::PlanConnectionDescriptions&& _connection) { this->connection_ = std::move (_connection); }
inline const ::Deployment::PlanConnectionDescriptions& Deployment::DeploymentPlan::connection () const { return this->connection_; }
inline ::Deployment::PlanConnectionDescriptions& Deployment::DeploymentPlan::connection () { return this->connection_; }

inline void Deployment::DeploymentPlan::externalProperty (const ::Deployment::PlanPropertyMappings& _externalProperty) { this->externalProperty_ = _externalProperty; }
inline void Deployment::DeploymentPlan::externalProperty (::Deployment::PlanPropertyMappings&& _externalProperty) { this->externalProperty_ = std::move (_externalProperty); }
inline const ::Deployment::PlanPropertyMappings& Deployment::DeploymentPlan::externalProperty () const { return this->externalProperty_; }
inline ::Deployment::PlanPropertyMappings& Deployment::DeploymentPlan::externalProperty () { return this->externalProperty_; }

inline void Deployment::DeploymentPlan::dependsOn (const ::Deployment::ImplementationDependencies& _dependsOn) { this->dependsOn_ = _dependsOn; }
inline void Deployment::DeploymentPlan::dependsOn (::Deployment::ImplementationDependencies&& _dependsOn) { this->dependsOn_ = std::move (_dependsOn); }
inline const ::Deployment::ImplementationDependencies& Deployment::DeploymentPlan::dependsOn () const { return this->dependsOn_; }
inline ::Deployment::ImplementationDependencies& Deployment::DeploymentPlan::dependsOn () { return this->dependsOn_; }

inline void Deployment::DeploymentPlan::artifact (const ::Deployment::ArtifactDeploymentDescriptions& _artifact) { this->artifact_ = _artifact; }
inline void Deployment::DeploymentPlan::artifact (::Deployment::ArtifactDeploymentDescriptions&& _artifact) { this->artifact_ = std::move (_artifact); }
inline const ::Deployment::ArtifactDeploymentDescriptions& Deployment::DeploymentPlan::artifact () const { return this->artifact_; }
inline ::Deployment::ArtifactDeploymentDescriptions& Deployment::DeploymentPlan::artifact () { return this->artifact_; }

inline void Deployment::DeploymentPlan::infoProperty (const ::Deployment::Properties& _infoProperty) { this->infoProperty_ = _infoProperty; }
inline void Deployment::DeploymentPlan::infoProperty (::Deployment::Properties&& _infoProperty) { this->infoProperty_ = std::move (_infoProperty); }
inline const ::Deployment::Properties& Deployment::DeploymentPlan::infoProperty () const { return this->infoProperty_; }
inline ::Deployment::Properties& Deployment::DeploymentPlan::infoProperty () { return this->infoProperty_; }

inline void Deployment::DeploymentPlan::localityConstraint (const ::Deployment::PlanLocalities& _localityConstraint) { this->localityConstraint_ = _localityConstraint; }
inline void Deployment::DeploymentPlan::localityConstraint (::Deployment::PlanLocalities&& _localityConstraint) { this->localityConstraint_ = std::move (_localityConstraint); }
inline const ::Deployment::PlanLocalities& Deployment::DeploymentPlan::localityConstraint () const { return this->localityConstraint_; }
inline ::Deployment::PlanLocalities& Deployment::DeploymentPlan::localityConstraint () { return this->localityConstraint_; }

inline void Deployment::DeploymentPlan::swap (::Deployment::DeploymentPlan& s)
{
  std::swap (this->label_, s.label_);
  std::swap (this->UUID_, s.UUID_);
  std::swap (this->realizes_, s.realizes_);
  std::swap (this->implementation_, s.implementation_);
  std::swap (this->instance_, s.instance_);
  std::swap (this->connection_, s.connection_);
  std::swap (this->externalProperty_, s.externalProperty_);
  std::swap (this->dependsOn_, s.dependsOn_);
  std::swap (this->artifact_, s.artifact_);
  std::swap (this->infoProperty_, s.infoProperty_);
  std::swap (this->localityConstraint_, s.localityConstraint_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ComponentPackageReference::ComponentPackageReference (
  std::string requiredUUID,
  std::string requiredName,
  ::Deployment::ComponentInterfaceDescription requiredType)
  : requiredUUID_ (std::move (requiredUUID))
  , requiredName_ (std::move (requiredName))
  , requiredType_ (std::move (requiredType))
{
}

inline void Deployment::ComponentPackageReference::requiredUUID (const std::string& _requiredUUID) { this->requiredUUID_ = _requiredUUID; }
inline void Deployment::ComponentPackageReference::requiredUUID (std::string&& _requiredUUID) { this->requiredUUID_ = std::move (_requiredUUID); }
inline const std::string& Deployment::ComponentPackageReference::requiredUUID () const { return this->requiredUUID_; }
inline std::string& Deployment::ComponentPackageReference::requiredUUID () { return this->requiredUUID_; }

inline void Deployment::ComponentPackageReference::requiredName (const std::string& _requiredName) { this->requiredName_ = _requiredName; }
inline void Deployment::ComponentPackageReference::requiredName (std::string&& _requiredName) { this->requiredName_ = std::move (_requiredName); }
inline const std::string& Deployment::ComponentPackageReference::requiredName () const { return this->requiredName_; }
inline std::string& Deployment::ComponentPackageReference::requiredName () { return this->requiredName_; }

inline void Deployment::ComponentPackageReference::requiredType (const ::Deployment::ComponentInterfaceDescription& _requiredType) { this->requiredType_ = _requiredType; }
inline void Deployment::ComponentPackageReference::requiredType (::Deployment::ComponentInterfaceDescription&& _requiredType) { this->requiredType_ = std::move (_requiredType); }
inline const ::Deployment::ComponentInterfaceDescription& Deployment::ComponentPackageReference::requiredType () const { return this->requiredType_; }
inline ::Deployment::ComponentInterfaceDescription& Deployment::ComponentPackageReference::requiredType () { return this->requiredType_; }

inline void Deployment::ComponentPackageReference::swap (::Deployment::ComponentPackageReference& s)
{
  std::swap (this->requiredUUID_, s.requiredUUID_);
  std::swap (this->requiredName_, s.requiredName_);
  std::swap (this->requiredType_, s.requiredType_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::ImplementationRequirement::ImplementationRequirement (
  ::Deployment::ResourceUsageKinds resourceUsage,
  std::string resourcePort,
  std::string componentPort,
  std::string name,
  std::string resourceType,
  ::Deployment::Properties property)
  : resourceUsage_ (std::move (resourceUsage))
  , resourcePort_ (std::move (resourcePort))
  , componentPort_ (std::move (componentPort))
  , name_ (std::move (name))
  , resourceType_ (std::move (resourceType))
  , property_ (std::move (property))
{
}

inline void Deployment::ImplementationRequirement::resourceUsage (const ::Deployment::ResourceUsageKinds& _resourceUsage) { this->resourceUsage_ = _resourceUsage; }
inline void Deployment::ImplementationRequirement::resourceUsage (::Deployment::ResourceUsageKinds&& _resourceUsage) { this->resourceUsage_ = std::move (_resourceUsage); }
inline const ::Deployment::ResourceUsageKinds& Deployment::ImplementationRequirement::resourceUsage () const { return this->resourceUsage_; }
inline ::Deployment::ResourceUsageKinds& Deployment::ImplementationRequirement::resourceUsage () { return this->resourceUsage_; }

inline void Deployment::ImplementationRequirement::resourcePort (const std::string& _resourcePort) { this->resourcePort_ = _resourcePort; }
inline void Deployment::ImplementationRequirement::resourcePort (std::string&& _resourcePort) { this->resourcePort_ = std::move (_resourcePort); }
inline const std::string& Deployment::ImplementationRequirement::resourcePort () const { return this->resourcePort_; }
inline std::string& Deployment::ImplementationRequirement::resourcePort () { return this->resourcePort_; }

inline void Deployment::ImplementationRequirement::componentPort (const std::string& _componentPort) { this->componentPort_ = _componentPort; }
inline void Deployment::ImplementationRequirement::componentPort (std::string&& _componentPort) { this->componentPort_ = std::move (_componentPort); }
inline const std::string& Deployment::ImplementationRequirement::componentPort () const { return this->componentPort_; }
inline std::string& Deployment::ImplementationRequirement::componentPort () { return this->componentPort_; }

inline void Deployment::ImplementationRequirement::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::ImplementationRequirement::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::ImplementationRequirement::name () const { return this->name_; }
inline std::string& Deployment::ImplementationRequirement::name () { return this->name_; }

inline void Deployment::ImplementationRequirement::resourceType (const std::string& _resourceType) { this->resourceType_ = _resourceType; }
inline void Deployment::ImplementationRequirement::resourceType (std::string&& _resourceType) { this->resourceType_ = std::move (_resourceType); }
inline const std::string& Deployment::ImplementationRequirement::resourceType () const { return this->resourceType_; }
inline std::string& Deployment::ImplementationRequirement::resourceType () { return this->resourceType_; }

inline void Deployment::ImplementationRequirement::property (const ::Deployment::Properties& _property) { this->property_ = _property; }
inline void Deployment::ImplementationRequirement::property (::Deployment::Properties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::Properties& Deployment::ImplementationRequirement::property () const { return this->property_; }
inline ::Deployment::Properties& Deployment::ImplementationRequirement::property () { return this->property_; }

inline void Deployment::ImplementationRequirement::swap (::Deployment::ImplementationRequirement& s)
{
  std::swap (this->resourceUsage_, s.resourceUsage_);
  std::swap (this->resourcePort_, s.resourcePort_);
  std::swap (this->componentPort_, s.componentPort_);
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Deployment::Capability::Capability (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType,
  ::Deployment::SatisfierProperties property)
  : name_ (std::move (name))
  , resourceType_ (std::move (resourceType))
  , property_ (std::move (property))
{
}

inline void Deployment::Capability::name (const std::string& _name) { this->name_ = _name; }
inline void Deployment::Capability::name (std::string&& _name) { this->name_ = std::move (_name); }
inline const std::string& Deployment::Capability::name () const { return this->name_; }
inline std::string& Deployment::Capability::name () { return this->name_; }

inline void Deployment::Capability::resourceType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _resourceType) { this->resourceType_ = _resourceType; }
inline void Deployment::Capability::resourceType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _resourceType) { this->resourceType_ = std::move (_resourceType); }
inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::Capability::resourceType () const { return this->resourceType_; }
inline ::TAOX11_NAMESPACE::CORBA::StringSeq& Deployment::Capability::resourceType () { return this->resourceType_; }

inline void Deployment::Capability::property (const ::Deployment::SatisfierProperties& _property) { this->property_ = _property; }
inline void Deployment::Capability::property (::Deployment::SatisfierProperties&& _property) { this->property_ = std::move (_property); }
inline const ::Deployment::SatisfierProperties& Deployment::Capability::property () const { return this->property_; }
inline ::Deployment::SatisfierProperties& Deployment::Capability::property () { return this->property_; }

inline void Deployment::Capability::swap (::Deployment::Capability& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Property& m1, ::Deployment::Property& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Requirement& m1, ::Deployment::Requirement& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::SatisfierProperty& m1, ::Deployment::SatisfierProperty& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPortDescription& m1, ::Deployment::ComponentPortDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPropertyDescription& m1, ::Deployment::ComponentPropertyDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentInterfaceDescription& m1, ::Deployment::ComponentInterfaceDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::MonolithicDeploymentDescription& m1, ::Deployment::MonolithicDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::InstanceResourceDeploymentDescription& m1, ::Deployment::InstanceResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::InstanceDeploymentDescription& m1, ::Deployment::InstanceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentExternalPortEndpoint& m1, ::Deployment::ComponentExternalPortEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanSubcomponentPortEndpoint& m1, ::Deployment::PlanSubcomponentPortEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ExternalReferenceEndpoint& m1, ::Deployment::ExternalReferenceEndpoint& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ConnectionResourceDeploymentDescription& m1, ::Deployment::ConnectionResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanConnectionDescription& m1, ::Deployment::PlanConnectionDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanSubcomponentPropertyReference& m1, ::Deployment::PlanSubcomponentPropertyReference& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanPropertyMapping& m1, ::Deployment::PlanPropertyMapping& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ImplementationDependency& m1, ::Deployment::ImplementationDependency& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ResourceDeploymentDescription& m1, ::Deployment::ResourceDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ArtifactDeploymentDescription& m1, ::Deployment::ArtifactDeploymentDescription& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::PlanLocality& m1, ::Deployment::PlanLocality& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::DeploymentPlan& m1, ::Deployment::DeploymentPlan& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ComponentPackageReference& m1, ::Deployment::ComponentPackageReference& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::ImplementationRequirement& m1, ::Deployment::ImplementationRequirement& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Deployment::Capability& m1, ::Deployment::Capability& m2)
  {
    m1.swap (m2);
  }
} // namespace std

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::Property& _v)
{
  return IDL::traits< ::Deployment::Property>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::Property>
// MD5            : 9FA54C1D0A4E5ABC4A2486AD7C463745
#if !defined (_ALIAS_OSTREAM_9FA54C1D0A4E5ABC4A2486AD7C463745_DECL_)
#define _ALIAS_OSTREAM_9FA54C1D0A4E5ABC4A2486AD7C463745_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::Properties& _v)
{
  return IDL::traits< ::Deployment::Properties>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_9FA54C1D0A4E5ABC4A2486AD7C463745_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::Requirement& _v)
{
  return IDL::traits< ::Deployment::Requirement>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::Requirement>
// MD5            : B5D61CF43DC976264FCA09DAEF6B439D
#if !defined (_ALIAS_OSTREAM_B5D61CF43DC976264FCA09DAEF6B439D_DECL_)
#define _ALIAS_OSTREAM_B5D61CF43DC976264FCA09DAEF6B439D_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::Requirements& _v)
{
  return IDL::traits< ::Deployment::Requirements>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_B5D61CF43DC976264FCA09DAEF6B439D_DECL_

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::SatisfierPropertyKind _v)
{
  return IDL::traits< ::Deployment::SatisfierPropertyKind>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::SatisfierProperty& _v)
{
  return IDL::traits< ::Deployment::SatisfierProperty>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::SatisfierProperty>
// MD5            : AAB77A9CDD8FCC93D26F3C8F9DA5CB57
#if !defined (_ALIAS_OSTREAM_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_DECL_)
#define _ALIAS_OSTREAM_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::SatisfierProperties& _v)
{
  return IDL::traits< ::Deployment::SatisfierProperties>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_AAB77A9CDD8FCC93D26F3C8F9DA5CB57_DECL_

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::CCMComponentPortKind _v)
{
  return IDL::traits< ::Deployment::CCMComponentPortKind>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPortDescription& _v)
{
  return IDL::traits< ::Deployment::ComponentPortDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ComponentPortDescription>
// MD5            : C5E370E71060EF02CAD31E10FF9B9A83
#if !defined (_ALIAS_OSTREAM_C5E370E71060EF02CAD31E10FF9B9A83_DECL_)
#define _ALIAS_OSTREAM_C5E370E71060EF02CAD31E10FF9B9A83_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPortDescriptions& _v)
{
  return IDL::traits< ::Deployment::ComponentPortDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_C5E370E71060EF02CAD31E10FF9B9A83_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPropertyDescription& _v)
{
  return IDL::traits< ::Deployment::ComponentPropertyDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ComponentPropertyDescription>
// MD5            : C38B325CAEA1E1A5249DC3C8B0654824
#if !defined (_ALIAS_OSTREAM_C38B325CAEA1E1A5249DC3C8B0654824_DECL_)
#define _ALIAS_OSTREAM_C38B325CAEA1E1A5249DC3C8B0654824_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPropertyDescriptions& _v)
{
  return IDL::traits< ::Deployment::ComponentPropertyDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_C38B325CAEA1E1A5249DC3C8B0654824_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentInterfaceDescription& _v)
{
  return IDL::traits< ::Deployment::ComponentInterfaceDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::MonolithicDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::MonolithicDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::MonolithicDeploymentDescription>
// MD5            : 80C54C15F1FCF891188F93122A3F1653
#if !defined (_ALIAS_OSTREAM_80C54C15F1FCF891188F93122A3F1653_DECL_)
#define _ALIAS_OSTREAM_80C54C15F1FCF891188F93122A3F1653_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::MonolithicDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_80C54C15F1FCF891188F93122A3F1653_DECL_

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::ResourceUsageKind _v)
{
  return IDL::traits< ::Deployment::ResourceUsageKind>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceResourceDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::InstanceResourceDeploymentDescription>
// MD5            : EECAFA244583FB042136539EF2209665
#if !defined (_ALIAS_OSTREAM_EECAFA244583FB042136539EF2209665_DECL_)
#define _ALIAS_OSTREAM_EECAFA244583FB042136539EF2209665_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceResourceDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_EECAFA244583FB042136539EF2209665_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::InstanceDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::InstanceDeploymentDescription>
// MD5            : 5DAB54D520633DBBAAC64AB44B5264EF
#if !defined (_ALIAS_OSTREAM_5DAB54D520633DBBAAC64AB44B5264EF_DECL_)
#define _ALIAS_OSTREAM_5DAB54D520633DBBAAC64AB44B5264EF_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_5DAB54D520633DBBAAC64AB44B5264EF_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentExternalPortEndpoint& _v)
{
  return IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ComponentExternalPortEndpoint>
// MD5            : D55B5CF95C9426C6D2C98C3A5D478A08
#if !defined (_ALIAS_OSTREAM_D55B5CF95C9426C6D2C98C3A5D478A08_DECL_)
#define _ALIAS_OSTREAM_D55B5CF95C9426C6D2C98C3A5D478A08_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentExternalPortEndpoints& _v)
{
  return IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_D55B5CF95C9426C6D2C98C3A5D478A08_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPortEndpoint& _v)
{
  return IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanSubcomponentPortEndpoint>
// MD5            : B166E528DC38CC7B9823B4A707AF73F7
#if !defined (_ALIAS_OSTREAM_B166E528DC38CC7B9823B4A707AF73F7_DECL_)
#define _ALIAS_OSTREAM_B166E528DC38CC7B9823B4A707AF73F7_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPortEndpoints& _v)
{
  return IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_B166E528DC38CC7B9823B4A707AF73F7_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ExternalReferenceEndpoint& _v)
{
  return IDL::traits< ::Deployment::ExternalReferenceEndpoint>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ExternalReferenceEndpoint>
// MD5            : 05A01CE11A8BFF9D44BAB053FE399734
#if !defined (_ALIAS_OSTREAM_05A01CE11A8BFF9D44BAB053FE399734_DECL_)
#define _ALIAS_OSTREAM_05A01CE11A8BFF9D44BAB053FE399734_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ExternalReferenceEndpoints& _v)
{
  return IDL::traits< ::Deployment::ExternalReferenceEndpoints>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_05A01CE11A8BFF9D44BAB053FE399734_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ConnectionResourceDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ConnectionResourceDeploymentDescription>
// MD5            : AF4F2101DCE0C79A0EDE886BDCAFC611
#if !defined (_ALIAS_OSTREAM_AF4F2101DCE0C79A0EDE886BDCAFC611_DECL_)
#define _ALIAS_OSTREAM_AF4F2101DCE0C79A0EDE886BDCAFC611_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ConnectionResourceDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_AF4F2101DCE0C79A0EDE886BDCAFC611_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanConnectionDescription& _v)
{
  return IDL::traits< ::Deployment::PlanConnectionDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanConnectionDescription>
// MD5            : CFA31BAC8967655A8F41210E634352C1
#if !defined (_ALIAS_OSTREAM_CFA31BAC8967655A8F41210E634352C1_DECL_)
#define _ALIAS_OSTREAM_CFA31BAC8967655A8F41210E634352C1_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanConnectionDescriptions& _v)
{
  return IDL::traits< ::Deployment::PlanConnectionDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_CFA31BAC8967655A8F41210E634352C1_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPropertyReference& _v)
{
  return IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanSubcomponentPropertyReference>
// MD5            : AEBC73EB559A636E52F4DAEA9332277F
#if !defined (_ALIAS_OSTREAM_AEBC73EB559A636E52F4DAEA9332277F_DECL_)
#define _ALIAS_OSTREAM_AEBC73EB559A636E52F4DAEA9332277F_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPropertyReferences& _v)
{
  return IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_AEBC73EB559A636E52F4DAEA9332277F_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanPropertyMapping& _v)
{
  return IDL::traits< ::Deployment::PlanPropertyMapping>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanPropertyMapping>
// MD5            : F12B7FF5B966394695A4C3B62A60769E
#if !defined (_ALIAS_OSTREAM_F12B7FF5B966394695A4C3B62A60769E_DECL_)
#define _ALIAS_OSTREAM_F12B7FF5B966394695A4C3B62A60769E_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanPropertyMappings& _v)
{
  return IDL::traits< ::Deployment::PlanPropertyMappings>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_F12B7FF5B966394695A4C3B62A60769E_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationDependency& _v)
{
  return IDL::traits< ::Deployment::ImplementationDependency>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ImplementationDependency>
// MD5            : 99A76A2AEA0FB19B92F7E3C2DE89FFF6
#if !defined (_ALIAS_OSTREAM_99A76A2AEA0FB19B92F7E3C2DE89FFF6_DECL_)
#define _ALIAS_OSTREAM_99A76A2AEA0FB19B92F7E3C2DE89FFF6_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationDependencies& _v)
{
  return IDL::traits< ::Deployment::ImplementationDependencies>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_99A76A2AEA0FB19B92F7E3C2DE89FFF6_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ResourceDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::ResourceDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ResourceDeploymentDescription>
// MD5            : DF993C9C6EABFC782FDDA1D9B825B8FC
#if !defined (_ALIAS_OSTREAM_DF993C9C6EABFC782FDDA1D9B825B8FC_DECL_)
#define _ALIAS_OSTREAM_DF993C9C6EABFC782FDDA1D9B825B8FC_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ResourceDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_DF993C9C6EABFC782FDDA1D9B825B8FC_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ArtifactDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::ArtifactDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ArtifactDeploymentDescription>
// MD5            : 9366314FF053E4C8C2B7FE26CA476674
#if !defined (_ALIAS_OSTREAM_9366314FF053E4C8C2B7FE26CA476674_DECL_)
#define _ALIAS_OSTREAM_9366314FF053E4C8C2B7FE26CA476674_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ArtifactDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_9366314FF053E4C8C2B7FE26CA476674_DECL_

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::PlanLocalityKind _v)
{
  return IDL::traits< ::Deployment::PlanLocalityKind>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanLocality& _v)
{
  return IDL::traits< ::Deployment::PlanLocality>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::PlanLocality>
// MD5            : DDE38066805242B88FC17943CB38328B
#if !defined (_ALIAS_OSTREAM_DDE38066805242B88FC17943CB38328B_DECL_)
#define _ALIAS_OSTREAM_DDE38066805242B88FC17943CB38328B_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanLocalities& _v)
{
  return IDL::traits< ::Deployment::PlanLocalities>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_DDE38066805242B88FC17943CB38328B_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::DeploymentPlan& _v)
{
  return IDL::traits< ::Deployment::DeploymentPlan>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPackageReference& _v)
{
  return IDL::traits< ::Deployment::ComponentPackageReference>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ComponentPackageReference>
// MD5            : 0C9FEC96A49604B9CC5DF59C48DE88F1
#if !defined (_ALIAS_OSTREAM_0C9FEC96A49604B9CC5DF59C48DE88F1_DECL_)
#define _ALIAS_OSTREAM_0C9FEC96A49604B9CC5DF59C48DE88F1_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPackageReferences& _v)
{
  return IDL::traits< ::Deployment::ComponentPackageReferences>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_0C9FEC96A49604B9CC5DF59C48DE88F1_DECL_

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ResourceUsageKind>
// MD5            : 25B5A7D7E8D2341751079BEB8A44717A
#if !defined (_ALIAS_OSTREAM_25B5A7D7E8D2341751079BEB8A44717A_DECL_)
#define _ALIAS_OSTREAM_25B5A7D7E8D2341751079BEB8A44717A_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ResourceUsageKinds& _v)
{
  return IDL::traits< ::Deployment::ResourceUsageKinds>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_25B5A7D7E8D2341751079BEB8A44717A_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationRequirement& _v)
{
  return IDL::traits< ::Deployment::ImplementationRequirement>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::ImplementationRequirement>
// MD5            : 58B3838A8CD6CA5F0D66B307C6BD6467
#if !defined (_ALIAS_OSTREAM_58B3838A8CD6CA5F0D66B307C6BD6467_DECL_)
#define _ALIAS_OSTREAM_58B3838A8CD6CA5F0D66B307C6BD6467_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationRequirements& _v)
{
  return IDL::traits< ::Deployment::ImplementationRequirements>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_58B3838A8CD6CA5F0D66B307C6BD6467_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::Capability& _v)
{
  return IDL::traits< ::Deployment::Capability>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os.erb
// Unaliased type : std::vector < ::Deployment::Capability>
// MD5            : 67A5FF62ED49ECC3F7373CDDDBC3DFAD
#if !defined (_ALIAS_OSTREAM_67A5FF62ED49ECC3F7373CDDDBC3DFAD_DECL_)
#define _ALIAS_OSTREAM_67A5FF62ED49ECC3F7373CDDDBC3DFAD_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::Capabilities& _v)
{
  return IDL::traits< ::Deployment::Capabilities>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_67A5FF62ED49ECC3F7373CDDDBC3DFAD_DECL_

// generated from c++11/templates/cli/hdr/post.erb
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testCP.h"
#endif

#include /**/ "ace/post.h"

#endif /* __RIDL_TESTC_H_HFCDCFJD_INCLUDED__ */

// -*- END -*-
