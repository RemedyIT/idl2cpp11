/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_TESTC_H_DFFBAEHG_INCLUDED__
#define __RIDL_TESTC_H_DFFBAEHG_INCLUDED__

#pragma once

#include /**/ "ace/pre.h"
#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/anytypecode/any.h"
#include "tao/x11/corba_ostream.h"

#include /**/ "tao/x11/versionx11.h"

#if TAOX11_MAJOR_VERSION != 1 || TAOX11_MINOR_VERSION != 8 || TAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (1.8.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from StubHeaderWriter#enter_module
/// @copydoc test.idl::Deployment
namespace Deployment
{

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::Property
  class Property
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    Property () = default;
    /// Destructor
    ~Property () = default;
    /// Copy constructor
    Property (const Property&) = default;
    /// Move constructor
    Property (Property&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Property (
      std::string name,
      TAOX11_NAMESPACE::CORBA::Any value);
    /// Copy assignment operator
    Property& operator= (const Property&) = default;
    /// Move assignment operator
    Property& operator= (Property&&) = default;

    /// @copydoc test.idl::Deployment::Property::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::Property::value
    //@{
    inline void value (const TAOX11_NAMESPACE::CORBA::Any& _x11_value) { this->value_ = _x11_value; }
    inline void value (TAOX11_NAMESPACE::CORBA::Any&& _x11_value) { this->value_ = std::move (_x11_value); }
    inline const TAOX11_NAMESPACE::CORBA::Any& value () const { return this->value_; }
    inline TAOX11_NAMESPACE::CORBA::Any& value () { return this->value_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (Property& s);

  private:
    std::string name_;
    TAOX11_NAMESPACE::CORBA::Any value_;
  };// Property

  inline void swap (::Deployment::Property& m1, ::Deployment::Property& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::Properties
  using Properties = std::vector< Property>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::Requirement
  class Requirement
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    Requirement () = default;
    /// Destructor
    ~Requirement () = default;
    /// Copy constructor
    Requirement (const Requirement&) = default;
    /// Move constructor
    Requirement (Requirement&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Requirement (
      std::string name,
      std::string resourceType,
      ::Deployment::Properties property);
    /// Copy assignment operator
    Requirement& operator= (const Requirement&) = default;
    /// Move assignment operator
    Requirement& operator= (Requirement&&) = default;

    /// @copydoc test.idl::Deployment::Requirement::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::Requirement::resourceType
    //@{
    inline void resourceType (const std::string& _x11_resourceType) { this->resourceType_ = _x11_resourceType; }
    inline void resourceType (std::string&& _x11_resourceType) { this->resourceType_ = std::move (_x11_resourceType); }
    inline const std::string& resourceType () const { return this->resourceType_; }
    inline std::string& resourceType () { return this->resourceType_; }
    //@}

    /// @copydoc test.idl::Deployment::Requirement::property
    //@{
    inline void property (const ::Deployment::Properties& _x11_property) { this->property_ = _x11_property; }
    inline void property (::Deployment::Properties&& _x11_property) { this->property_ = std::move (_x11_property); }
    inline const ::Deployment::Properties& property () const { return this->property_; }
    inline ::Deployment::Properties& property () { return this->property_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (Requirement& s);

  private:
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  };// Requirement

  inline void swap (::Deployment::Requirement& m1, ::Deployment::Requirement& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::Requirements
  using Requirements = std::vector< Requirement>;

  // generated from c++11/templates/cli/hdr/enum

  /// @copydoc test.idl::Deployment::SatisfierPropertyKind
  enum class SatisfierPropertyKind : uint32_t
  {
    /// @copydoc test.idl::Deployment::SatisfierPropertyKind::Quantity
    Quantity,
    /// @copydoc test.idl::Deployment::SatisfierPropertyKind::Capacity
    Capacity,
    /// @copydoc test.idl::Deployment::SatisfierPropertyKind::Minimum
    Minimum,
    /// @copydoc test.idl::Deployment::SatisfierPropertyKind::Maximum
    Maximum,
    /// @copydoc test.idl::Deployment::SatisfierPropertyKind::Attribute
    Attribute,
    /// @copydoc test.idl::Deployment::SatisfierPropertyKind::Selection
    Selection
  };// SatisfierPropertyKind


  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::SatisfierProperty
  class SatisfierProperty
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    SatisfierProperty () = default;
    /// Destructor
    ~SatisfierProperty () = default;
    /// Copy constructor
    SatisfierProperty (const SatisfierProperty&) = default;
    /// Move constructor
    SatisfierProperty (SatisfierProperty&&) = default;
    /// Constructor which accepts value for all members
    explicit inline SatisfierProperty (
      std::string name,
      ::Deployment::SatisfierPropertyKind kind,
      bool dynamic,
      TAOX11_NAMESPACE::CORBA::Any value);
    /// Copy assignment operator
    SatisfierProperty& operator= (const SatisfierProperty&) = default;
    /// Move assignment operator
    SatisfierProperty& operator= (SatisfierProperty&&) = default;

    /// @copydoc test.idl::Deployment::SatisfierProperty::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::SatisfierProperty::kind
    //@{
    inline void kind (::Deployment::SatisfierPropertyKind _x11_kind) { this->kind_ = _x11_kind; }
    inline ::Deployment::SatisfierPropertyKind kind () const { return this->kind_; }
    inline ::Deployment::SatisfierPropertyKind& kind () { return this->kind_; }
    //@}

    /// @copydoc test.idl::Deployment::SatisfierProperty::dynamic
    //@{
    inline void dynamic (bool _x11_dynamic) { this->dynamic_ = _x11_dynamic; }
    inline bool dynamic () const { return this->dynamic_; }
    inline bool& dynamic () { return this->dynamic_; }
    //@}

    /// @copydoc test.idl::Deployment::SatisfierProperty::value
    //@{
    inline void value (const TAOX11_NAMESPACE::CORBA::Any& _x11_value) { this->value_ = _x11_value; }
    inline void value (TAOX11_NAMESPACE::CORBA::Any&& _x11_value) { this->value_ = std::move (_x11_value); }
    inline const TAOX11_NAMESPACE::CORBA::Any& value () const { return this->value_; }
    inline TAOX11_NAMESPACE::CORBA::Any& value () { return this->value_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (SatisfierProperty& s);

  private:
    std::string name_;
    ::Deployment::SatisfierPropertyKind kind_ {};
    bool dynamic_ {};
    TAOX11_NAMESPACE::CORBA::Any value_;
  };// SatisfierProperty

  inline void swap (::Deployment::SatisfierProperty& m1, ::Deployment::SatisfierProperty& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::SatisfierProperties
  using SatisfierProperties = std::vector< SatisfierProperty>;
} // namespace Deployment


// generated from StubHeaderWriter#enter_module
/// @copydoc test.idl::Deployment
namespace Deployment
{

  // generated from c++11/templates/cli/hdr/enum

  /// @copydoc test.idl::Deployment::CCMComponentPortKind
  enum class CCMComponentPortKind : uint32_t
  {
    /// @copydoc test.idl::Deployment::CCMComponentPortKind::Facet
    Facet,
    /// @copydoc test.idl::Deployment::CCMComponentPortKind::SimplexReceptacle
    SimplexReceptacle,
    /// @copydoc test.idl::Deployment::CCMComponentPortKind::MultiplexReceptacle
    MultiplexReceptacle,
    /// @copydoc test.idl::Deployment::CCMComponentPortKind::EventEmitter
    EventEmitter,
    /// @copydoc test.idl::Deployment::CCMComponentPortKind::EventPublisher
    EventPublisher,
    /// @copydoc test.idl::Deployment::CCMComponentPortKind::EventConsumer
    EventConsumer,
    /// @copydoc test.idl::Deployment::CCMComponentPortKind::ExtendedPort
    ExtendedPort,
    /// @copydoc test.idl::Deployment::CCMComponentPortKind::MirrorPort
    MirrorPort
  };// CCMComponentPortKind


  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ComponentPortDescription
  class ComponentPortDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ComponentPortDescription () = default;
    /// Destructor
    ~ComponentPortDescription () = default;
    /// Copy constructor
    ComponentPortDescription (const ComponentPortDescription&) = default;
    /// Move constructor
    ComponentPortDescription (ComponentPortDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentPortDescription (
      std::string name,
      std::string specificType,
      ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
      bool provider,
      bool exclusiveProvider,
      bool exclusiveUser,
      bool optional,
      ::Deployment::CCMComponentPortKind kind,
      ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam);
    /// Copy assignment operator
    ComponentPortDescription& operator= (const ComponentPortDescription&) = default;
    /// Move assignment operator
    ComponentPortDescription& operator= (ComponentPortDescription&&) = default;

    /// @copydoc test.idl::Deployment::ComponentPortDescription::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPortDescription::specificType
    //@{
    inline void specificType (const std::string& _x11_specificType) { this->specificType_ = _x11_specificType; }
    inline void specificType (std::string&& _x11_specificType) { this->specificType_ = std::move (_x11_specificType); }
    inline const std::string& specificType () const { return this->specificType_; }
    inline std::string& specificType () { return this->specificType_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPortDescription::supportedType
    //@{
    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_supportedType) { this->supportedType_ = _x11_supportedType; }
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_supportedType) { this->supportedType_ = std::move (_x11_supportedType); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () const { return this->supportedType_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () { return this->supportedType_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPortDescription::provider
    //@{
    inline void provider (bool _x11_provider) { this->provider_ = _x11_provider; }
    inline bool provider () const { return this->provider_; }
    inline bool& provider () { return this->provider_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPortDescription::exclusiveProvider
    //@{
    inline void exclusiveProvider (bool _x11_exclusiveProvider) { this->exclusiveProvider_ = _x11_exclusiveProvider; }
    inline bool exclusiveProvider () const { return this->exclusiveProvider_; }
    inline bool& exclusiveProvider () { return this->exclusiveProvider_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPortDescription::exclusiveUser
    //@{
    inline void exclusiveUser (bool _x11_exclusiveUser) { this->exclusiveUser_ = _x11_exclusiveUser; }
    inline bool exclusiveUser () const { return this->exclusiveUser_; }
    inline bool& exclusiveUser () { return this->exclusiveUser_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPortDescription::optional
    //@{
    inline void optional (bool _x11_optional) { this->optional_ = _x11_optional; }
    inline bool optional () const { return this->optional_; }
    inline bool& optional () { return this->optional_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPortDescription::kind
    //@{
    inline void kind (::Deployment::CCMComponentPortKind _x11_kind) { this->kind_ = _x11_kind; }
    inline ::Deployment::CCMComponentPortKind kind () const { return this->kind_; }
    inline ::Deployment::CCMComponentPortKind& kind () { return this->kind_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPortDescription::templateParam
    //@{
    inline void templateParam (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_templateParam) { this->templateParam_ = _x11_templateParam; }
    inline void templateParam (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_templateParam) { this->templateParam_ = std::move (_x11_templateParam); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam () const { return this->templateParam_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& templateParam () { return this->templateParam_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentPortDescription& s);

  private:
    std::string name_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    bool provider_ {};
    bool exclusiveProvider_ {};
    bool exclusiveUser_ {};
    bool optional_ {};
    ::Deployment::CCMComponentPortKind kind_ {};
    ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam_;
  };// ComponentPortDescription

  inline void swap (::Deployment::ComponentPortDescription& m1, ::Deployment::ComponentPortDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ComponentPortDescriptions
  using ComponentPortDescriptions = std::vector< ComponentPortDescription>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ComponentPropertyDescription
  class ComponentPropertyDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ComponentPropertyDescription () = default;
    /// Destructor
    ~ComponentPropertyDescription () = default;
    /// Copy constructor
    ComponentPropertyDescription (const ComponentPropertyDescription&) = default;
    /// Move constructor
    ComponentPropertyDescription (ComponentPropertyDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentPropertyDescription (
      std::string name,
      IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type);
    /// Copy assignment operator
    ComponentPropertyDescription& operator= (const ComponentPropertyDescription&) = default;
    /// Move assignment operator
    ComponentPropertyDescription& operator= (ComponentPropertyDescription&&) = default;

    /// @copydoc test.idl::Deployment::ComponentPropertyDescription::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPropertyDescription::type
    //@{
    inline void type (IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type _x11_type) { this->type_ = _x11_type; }
    inline IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type () const { return this->type_; }
    inline IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type& type () { return this->type_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentPropertyDescription& s);

  private:
    std::string name_;
    IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type_;
  };// ComponentPropertyDescription

  inline void swap (::Deployment::ComponentPropertyDescription& m1, ::Deployment::ComponentPropertyDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ComponentPropertyDescriptions
  using ComponentPropertyDescriptions = std::vector< ComponentPropertyDescription>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ComponentInterfaceDescription
  class ComponentInterfaceDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ComponentInterfaceDescription () = default;
    /// Destructor
    ~ComponentInterfaceDescription () = default;
    /// Copy constructor
    ComponentInterfaceDescription (const ComponentInterfaceDescription&) = default;
    /// Move constructor
    ComponentInterfaceDescription (ComponentInterfaceDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentInterfaceDescription (
      std::string label,
      std::string UUID,
      std::string specificType,
      ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
      ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile,
      ::Deployment::Properties configProperty,
      ::Deployment::ComponentPortDescriptions port,
      ::Deployment::ComponentPropertyDescriptions property,
      ::Deployment::Properties infoProperty);
    /// Copy assignment operator
    ComponentInterfaceDescription& operator= (const ComponentInterfaceDescription&) = default;
    /// Move assignment operator
    ComponentInterfaceDescription& operator= (ComponentInterfaceDescription&&) = default;

    /// @copydoc test.idl::Deployment::ComponentInterfaceDescription::label
    //@{
    inline void label (const std::string& _x11_label) { this->label_ = _x11_label; }
    inline void label (std::string&& _x11_label) { this->label_ = std::move (_x11_label); }
    inline const std::string& label () const { return this->label_; }
    inline std::string& label () { return this->label_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentInterfaceDescription::UUID
    //@{
    inline void UUID (const std::string& _x11_UUID) { this->UUID_ = _x11_UUID; }
    inline void UUID (std::string&& _x11_UUID) { this->UUID_ = std::move (_x11_UUID); }
    inline const std::string& UUID () const { return this->UUID_; }
    inline std::string& UUID () { return this->UUID_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentInterfaceDescription::specificType
    //@{
    inline void specificType (const std::string& _x11_specificType) { this->specificType_ = _x11_specificType; }
    inline void specificType (std::string&& _x11_specificType) { this->specificType_ = std::move (_x11_specificType); }
    inline const std::string& specificType () const { return this->specificType_; }
    inline std::string& specificType () { return this->specificType_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentInterfaceDescription::supportedType
    //@{
    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_supportedType) { this->supportedType_ = _x11_supportedType; }
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_supportedType) { this->supportedType_ = std::move (_x11_supportedType); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () const { return this->supportedType_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () { return this->supportedType_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentInterfaceDescription::idlFile
    //@{
    inline void idlFile (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_idlFile) { this->idlFile_ = _x11_idlFile; }
    inline void idlFile (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_idlFile) { this->idlFile_ = std::move (_x11_idlFile); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile () const { return this->idlFile_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& idlFile () { return this->idlFile_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentInterfaceDescription::configProperty
    //@{
    inline void configProperty (const ::Deployment::Properties& _x11_configProperty) { this->configProperty_ = _x11_configProperty; }
    inline void configProperty (::Deployment::Properties&& _x11_configProperty) { this->configProperty_ = std::move (_x11_configProperty); }
    inline const ::Deployment::Properties& configProperty () const { return this->configProperty_; }
    inline ::Deployment::Properties& configProperty () { return this->configProperty_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentInterfaceDescription::_port
    //@{
    inline void port (const ::Deployment::ComponentPortDescriptions& _x11_port) { this->port_ = _x11_port; }
    inline void port (::Deployment::ComponentPortDescriptions&& _x11_port) { this->port_ = std::move (_x11_port); }
    inline const ::Deployment::ComponentPortDescriptions& port () const { return this->port_; }
    inline ::Deployment::ComponentPortDescriptions& port () { return this->port_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentInterfaceDescription::property
    //@{
    inline void property (const ::Deployment::ComponentPropertyDescriptions& _x11_property) { this->property_ = _x11_property; }
    inline void property (::Deployment::ComponentPropertyDescriptions&& _x11_property) { this->property_ = std::move (_x11_property); }
    inline const ::Deployment::ComponentPropertyDescriptions& property () const { return this->property_; }
    inline ::Deployment::ComponentPropertyDescriptions& property () { return this->property_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentInterfaceDescription::infoProperty
    //@{
    inline void infoProperty (const ::Deployment::Properties& _x11_infoProperty) { this->infoProperty_ = _x11_infoProperty; }
    inline void infoProperty (::Deployment::Properties&& _x11_infoProperty) { this->infoProperty_ = std::move (_x11_infoProperty); }
    inline const ::Deployment::Properties& infoProperty () const { return this->infoProperty_; }
    inline ::Deployment::Properties& infoProperty () { return this->infoProperty_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentInterfaceDescription& s);

  private:
    std::string label_;
    std::string UUID_;
    std::string specificType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile_;
    ::Deployment::Properties configProperty_;
    ::Deployment::ComponentPortDescriptions port_;
    ::Deployment::ComponentPropertyDescriptions property_;
    ::Deployment::Properties infoProperty_;
  };// ComponentInterfaceDescription

  inline void swap (::Deployment::ComponentInterfaceDescription& m1, ::Deployment::ComponentInterfaceDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::MonolithicDeploymentDescription
  class MonolithicDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    MonolithicDeploymentDescription () = default;
    /// Destructor
    ~MonolithicDeploymentDescription () = default;
    /// Copy constructor
    MonolithicDeploymentDescription (const MonolithicDeploymentDescription&) = default;
    /// Move constructor
    MonolithicDeploymentDescription (MonolithicDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline MonolithicDeploymentDescription (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef,
      ::Deployment::Properties execParameter,
      ::Deployment::Requirements deployRequirement);
    /// Copy assignment operator
    MonolithicDeploymentDescription& operator= (const MonolithicDeploymentDescription&) = default;
    /// Move assignment operator
    MonolithicDeploymentDescription& operator= (MonolithicDeploymentDescription&&) = default;

    /// @copydoc test.idl::Deployment::MonolithicDeploymentDescription::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::MonolithicDeploymentDescription::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_source) { this->source_ = _x11_source; }
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_source) { this->source_ = std::move (_x11_source); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const { return this->source_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source () { return this->source_; }
    //@}

    /// @copydoc test.idl::Deployment::MonolithicDeploymentDescription::artifactRef
    //@{
    inline void artifactRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _x11_artifactRef) { this->artifactRef_ = _x11_artifactRef; }
    inline void artifactRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _x11_artifactRef) { this->artifactRef_ = std::move (_x11_artifactRef); }
    inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef () const { return this->artifactRef_; }
    inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& artifactRef () { return this->artifactRef_; }
    //@}

    /// @copydoc test.idl::Deployment::MonolithicDeploymentDescription::execParameter
    //@{
    inline void execParameter (const ::Deployment::Properties& _x11_execParameter) { this->execParameter_ = _x11_execParameter; }
    inline void execParameter (::Deployment::Properties&& _x11_execParameter) { this->execParameter_ = std::move (_x11_execParameter); }
    inline const ::Deployment::Properties& execParameter () const { return this->execParameter_; }
    inline ::Deployment::Properties& execParameter () { return this->execParameter_; }
    //@}

    /// @copydoc test.idl::Deployment::MonolithicDeploymentDescription::deployRequirement
    //@{
    inline void deployRequirement (const ::Deployment::Requirements& _x11_deployRequirement) { this->deployRequirement_ = _x11_deployRequirement; }
    inline void deployRequirement (::Deployment::Requirements&& _x11_deployRequirement) { this->deployRequirement_ = std::move (_x11_deployRequirement); }
    inline const ::Deployment::Requirements& deployRequirement () const { return this->deployRequirement_; }
    inline ::Deployment::Requirements& deployRequirement () { return this->deployRequirement_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (MonolithicDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
  };// MonolithicDeploymentDescription

  inline void swap (::Deployment::MonolithicDeploymentDescription& m1, ::Deployment::MonolithicDeploymentDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::MonolithicDeploymentDescriptions
  using MonolithicDeploymentDescriptions = std::vector< MonolithicDeploymentDescription>;

  // generated from c++11/templates/cli/hdr/enum

  /// @copydoc test.idl::Deployment::ResourceUsageKind
  enum class ResourceUsageKind : uint32_t
  {
    /// @copydoc test.idl::Deployment::ResourceUsageKind::None
    None,
    /// @copydoc test.idl::Deployment::ResourceUsageKind::InstanceUsesResource
    InstanceUsesResource,
    /// @copydoc test.idl::Deployment::ResourceUsageKind::ResourceUsesInstance
    ResourceUsesInstance,
    /// @copydoc test.idl::Deployment::ResourceUsageKind::PortUsesResource
    PortUsesResource,
    /// @copydoc test.idl::Deployment::ResourceUsageKind::ResourceUsesPort
    ResourceUsesPort
  };// ResourceUsageKind


  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::InstanceResourceDeploymentDescription
  class InstanceResourceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    InstanceResourceDeploymentDescription () = default;
    /// Destructor
    ~InstanceResourceDeploymentDescription () = default;
    /// Copy constructor
    InstanceResourceDeploymentDescription (const InstanceResourceDeploymentDescription&) = default;
    /// Move constructor
    InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline InstanceResourceDeploymentDescription (
      ::Deployment::ResourceUsageKind resourceUsage,
      std::string requirementName,
      std::string resourceName,
      ::Deployment::Properties property);
    /// Copy assignment operator
    InstanceResourceDeploymentDescription& operator= (const InstanceResourceDeploymentDescription&) = default;
    /// Move assignment operator
    InstanceResourceDeploymentDescription& operator= (InstanceResourceDeploymentDescription&&) = default;

    /// @copydoc test.idl::Deployment::InstanceResourceDeploymentDescription::resourceUsage
    //@{
    inline void resourceUsage (::Deployment::ResourceUsageKind _x11_resourceUsage) { this->resourceUsage_ = _x11_resourceUsage; }
    inline ::Deployment::ResourceUsageKind resourceUsage () const { return this->resourceUsage_; }
    inline ::Deployment::ResourceUsageKind& resourceUsage () { return this->resourceUsage_; }
    //@}

    /// @copydoc test.idl::Deployment::InstanceResourceDeploymentDescription::requirementName
    //@{
    inline void requirementName (const std::string& _x11_requirementName) { this->requirementName_ = _x11_requirementName; }
    inline void requirementName (std::string&& _x11_requirementName) { this->requirementName_ = std::move (_x11_requirementName); }
    inline const std::string& requirementName () const { return this->requirementName_; }
    inline std::string& requirementName () { return this->requirementName_; }
    //@}

    /// @copydoc test.idl::Deployment::InstanceResourceDeploymentDescription::resourceName
    //@{
    inline void resourceName (const std::string& _x11_resourceName) { this->resourceName_ = _x11_resourceName; }
    inline void resourceName (std::string&& _x11_resourceName) { this->resourceName_ = std::move (_x11_resourceName); }
    inline const std::string& resourceName () const { return this->resourceName_; }
    inline std::string& resourceName () { return this->resourceName_; }
    //@}

    /// @copydoc test.idl::Deployment::InstanceResourceDeploymentDescription::property
    //@{
    inline void property (const ::Deployment::Properties& _x11_property) { this->property_ = _x11_property; }
    inline void property (::Deployment::Properties&& _x11_property) { this->property_ = std::move (_x11_property); }
    inline const ::Deployment::Properties& property () const { return this->property_; }
    inline ::Deployment::Properties& property () { return this->property_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (InstanceResourceDeploymentDescription& s);

  private:
    ::Deployment::ResourceUsageKind resourceUsage_ {};
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// InstanceResourceDeploymentDescription

  inline void swap (::Deployment::InstanceResourceDeploymentDescription& m1, ::Deployment::InstanceResourceDeploymentDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::InstanceResourceDeploymentDescriptions
  using InstanceResourceDeploymentDescriptions = std::vector< InstanceResourceDeploymentDescription>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::InstanceDeploymentDescription
  class InstanceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    InstanceDeploymentDescription () = default;
    /// Destructor
    ~InstanceDeploymentDescription () = default;
    /// Copy constructor
    InstanceDeploymentDescription (const InstanceDeploymentDescription&) = default;
    /// Move constructor
    InstanceDeploymentDescription (InstanceDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline InstanceDeploymentDescription (
      std::string name,
      std::string node,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      uint32_t implementationRef,
      ::Deployment::Properties configProperty,
      ::Deployment::InstanceResourceDeploymentDescriptions deployedResource,
      ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource);
    /// Copy assignment operator
    InstanceDeploymentDescription& operator= (const InstanceDeploymentDescription&) = default;
    /// Move assignment operator
    InstanceDeploymentDescription& operator= (InstanceDeploymentDescription&&) = default;

    /// @copydoc test.idl::Deployment::InstanceDeploymentDescription::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::InstanceDeploymentDescription::node
    //@{
    inline void node (const std::string& _x11_node) { this->node_ = _x11_node; }
    inline void node (std::string&& _x11_node) { this->node_ = std::move (_x11_node); }
    inline const std::string& node () const { return this->node_; }
    inline std::string& node () { return this->node_; }
    //@}

    /// @copydoc test.idl::Deployment::InstanceDeploymentDescription::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_source) { this->source_ = _x11_source; }
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_source) { this->source_ = std::move (_x11_source); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const { return this->source_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source () { return this->source_; }
    //@}

    /// @copydoc test.idl::Deployment::InstanceDeploymentDescription::implementationRef
    //@{
    inline void implementationRef (uint32_t _x11_implementationRef) { this->implementationRef_ = _x11_implementationRef; }
    inline uint32_t implementationRef () const { return this->implementationRef_; }
    inline uint32_t& implementationRef () { return this->implementationRef_; }
    //@}

    /// @copydoc test.idl::Deployment::InstanceDeploymentDescription::configProperty
    //@{
    inline void configProperty (const ::Deployment::Properties& _x11_configProperty) { this->configProperty_ = _x11_configProperty; }
    inline void configProperty (::Deployment::Properties&& _x11_configProperty) { this->configProperty_ = std::move (_x11_configProperty); }
    inline const ::Deployment::Properties& configProperty () const { return this->configProperty_; }
    inline ::Deployment::Properties& configProperty () { return this->configProperty_; }
    //@}

    /// @copydoc test.idl::Deployment::InstanceDeploymentDescription::deployedResource
    //@{
    inline void deployedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _x11_deployedResource) { this->deployedResource_ = _x11_deployedResource; }
    inline void deployedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _x11_deployedResource) { this->deployedResource_ = std::move (_x11_deployedResource); }
    inline const ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource () const { return this->deployedResource_; }
    inline ::Deployment::InstanceResourceDeploymentDescriptions& deployedResource () { return this->deployedResource_; }
    //@}

    /// @copydoc test.idl::Deployment::InstanceDeploymentDescription::deployedSharedResource
    //@{
    inline void deployedSharedResource (const ::Deployment::InstanceResourceDeploymentDescriptions& _x11_deployedSharedResource) { this->deployedSharedResource_ = _x11_deployedSharedResource; }
    inline void deployedSharedResource (::Deployment::InstanceResourceDeploymentDescriptions&& _x11_deployedSharedResource) { this->deployedSharedResource_ = std::move (_x11_deployedSharedResource); }
    inline const ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource () const { return this->deployedSharedResource_; }
    inline ::Deployment::InstanceResourceDeploymentDescriptions& deployedSharedResource () { return this->deployedSharedResource_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (InstanceDeploymentDescription& s);

  private:
    std::string name_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    uint32_t implementationRef_ {};
    ::Deployment::Properties configProperty_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedResource_;
    ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource_;
  };// InstanceDeploymentDescription

  inline void swap (::Deployment::InstanceDeploymentDescription& m1, ::Deployment::InstanceDeploymentDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::InstanceDeploymentDescriptions
  using InstanceDeploymentDescriptions = std::vector< InstanceDeploymentDescription>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ComponentExternalPortEndpoint
  class ComponentExternalPortEndpoint
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ComponentExternalPortEndpoint () = default;
    /// Destructor
    ~ComponentExternalPortEndpoint () = default;
    /// Copy constructor
    ComponentExternalPortEndpoint (const ComponentExternalPortEndpoint&) = default;
    /// Move constructor
    ComponentExternalPortEndpoint (ComponentExternalPortEndpoint&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentExternalPortEndpoint (
      std::string portName);
    /// Copy assignment operator
    ComponentExternalPortEndpoint& operator= (const ComponentExternalPortEndpoint&) = default;
    /// Move assignment operator
    ComponentExternalPortEndpoint& operator= (ComponentExternalPortEndpoint&&) = default;

    /// @copydoc test.idl::Deployment::ComponentExternalPortEndpoint::portName
    //@{
    inline void portName (const std::string& _x11_portName) { this->portName_ = _x11_portName; }
    inline void portName (std::string&& _x11_portName) { this->portName_ = std::move (_x11_portName); }
    inline const std::string& portName () const { return this->portName_; }
    inline std::string& portName () { return this->portName_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentExternalPortEndpoint& s);

  private:
    std::string portName_;
  };// ComponentExternalPortEndpoint

  inline void swap (::Deployment::ComponentExternalPortEndpoint& m1, ::Deployment::ComponentExternalPortEndpoint& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ComponentExternalPortEndpoints
  using ComponentExternalPortEndpoints = std::vector< ComponentExternalPortEndpoint>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::PlanSubcomponentPortEndpoint
  class PlanSubcomponentPortEndpoint
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    PlanSubcomponentPortEndpoint () = default;
    /// Destructor
    ~PlanSubcomponentPortEndpoint () = default;
    /// Copy constructor
    PlanSubcomponentPortEndpoint (const PlanSubcomponentPortEndpoint&) = default;
    /// Move constructor
    PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanSubcomponentPortEndpoint (
      std::string portName,
      bool provider,
      ::Deployment::CCMComponentPortKind kind,
      uint32_t instanceRef);
    /// Copy assignment operator
    PlanSubcomponentPortEndpoint& operator= (const PlanSubcomponentPortEndpoint&) = default;
    /// Move assignment operator
    PlanSubcomponentPortEndpoint& operator= (PlanSubcomponentPortEndpoint&&) = default;

    /// @copydoc test.idl::Deployment::PlanSubcomponentPortEndpoint::portName
    //@{
    inline void portName (const std::string& _x11_portName) { this->portName_ = _x11_portName; }
    inline void portName (std::string&& _x11_portName) { this->portName_ = std::move (_x11_portName); }
    inline const std::string& portName () const { return this->portName_; }
    inline std::string& portName () { return this->portName_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanSubcomponentPortEndpoint::provider
    //@{
    inline void provider (bool _x11_provider) { this->provider_ = _x11_provider; }
    inline bool provider () const { return this->provider_; }
    inline bool& provider () { return this->provider_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanSubcomponentPortEndpoint::kind
    //@{
    inline void kind (::Deployment::CCMComponentPortKind _x11_kind) { this->kind_ = _x11_kind; }
    inline ::Deployment::CCMComponentPortKind kind () const { return this->kind_; }
    inline ::Deployment::CCMComponentPortKind& kind () { return this->kind_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanSubcomponentPortEndpoint::instanceRef
    //@{
    inline void instanceRef (uint32_t _x11_instanceRef) { this->instanceRef_ = _x11_instanceRef; }
    inline uint32_t instanceRef () const { return this->instanceRef_; }
    inline uint32_t& instanceRef () { return this->instanceRef_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanSubcomponentPortEndpoint& s);

  private:
    std::string portName_;
    bool provider_ {};
    ::Deployment::CCMComponentPortKind kind_ {};
    uint32_t instanceRef_ {};
  };// PlanSubcomponentPortEndpoint

  inline void swap (::Deployment::PlanSubcomponentPortEndpoint& m1, ::Deployment::PlanSubcomponentPortEndpoint& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::PlanSubcomponentPortEndpoints
  using PlanSubcomponentPortEndpoints = std::vector< PlanSubcomponentPortEndpoint>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ExternalReferenceEndpoint
  class ExternalReferenceEndpoint
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ExternalReferenceEndpoint () = default;
    /// Destructor
    ~ExternalReferenceEndpoint () = default;
    /// Copy constructor
    ExternalReferenceEndpoint (const ExternalReferenceEndpoint&) = default;
    /// Move constructor
    ExternalReferenceEndpoint (ExternalReferenceEndpoint&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ExternalReferenceEndpoint (
      std::string location,
      bool provider,
      std::string portName,
      ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType);
    /// Copy assignment operator
    ExternalReferenceEndpoint& operator= (const ExternalReferenceEndpoint&) = default;
    /// Move assignment operator
    ExternalReferenceEndpoint& operator= (ExternalReferenceEndpoint&&) = default;

    /// @copydoc test.idl::Deployment::ExternalReferenceEndpoint::location
    //@{
    inline void location (const std::string& _x11_location) { this->location_ = _x11_location; }
    inline void location (std::string&& _x11_location) { this->location_ = std::move (_x11_location); }
    inline const std::string& location () const { return this->location_; }
    inline std::string& location () { return this->location_; }
    //@}

    /// @copydoc test.idl::Deployment::ExternalReferenceEndpoint::provider
    //@{
    inline void provider (bool _x11_provider) { this->provider_ = _x11_provider; }
    inline bool provider () const { return this->provider_; }
    inline bool& provider () { return this->provider_; }
    //@}

    /// @copydoc test.idl::Deployment::ExternalReferenceEndpoint::portName
    //@{
    inline void portName (const std::string& _x11_portName) { this->portName_ = _x11_portName; }
    inline void portName (std::string&& _x11_portName) { this->portName_ = std::move (_x11_portName); }
    inline const std::string& portName () const { return this->portName_; }
    inline std::string& portName () { return this->portName_; }
    //@}

    /// @copydoc test.idl::Deployment::ExternalReferenceEndpoint::supportedType
    //@{
    inline void supportedType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_supportedType) { this->supportedType_ = _x11_supportedType; }
    inline void supportedType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_supportedType) { this->supportedType_ = std::move (_x11_supportedType); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () const { return this->supportedType_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& supportedType () { return this->supportedType_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ExternalReferenceEndpoint& s);

  private:
    std::string location_;
    bool provider_ {};
    std::string portName_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType_;
  };// ExternalReferenceEndpoint

  inline void swap (::Deployment::ExternalReferenceEndpoint& m1, ::Deployment::ExternalReferenceEndpoint& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ExternalReferenceEndpoints
  using ExternalReferenceEndpoints = std::vector< ExternalReferenceEndpoint>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ConnectionResourceDeploymentDescription
  class ConnectionResourceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ConnectionResourceDeploymentDescription () = default;
    /// Destructor
    ~ConnectionResourceDeploymentDescription () = default;
    /// Copy constructor
    ConnectionResourceDeploymentDescription (const ConnectionResourceDeploymentDescription&) = default;
    /// Move constructor
    ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ConnectionResourceDeploymentDescription (
      std::string targetName,
      std::string requirementName,
      std::string resourceName,
      ::Deployment::Properties property);
    /// Copy assignment operator
    ConnectionResourceDeploymentDescription& operator= (const ConnectionResourceDeploymentDescription&) = default;
    /// Move assignment operator
    ConnectionResourceDeploymentDescription& operator= (ConnectionResourceDeploymentDescription&&) = default;

    /// @copydoc test.idl::Deployment::ConnectionResourceDeploymentDescription::targetName
    //@{
    inline void targetName (const std::string& _x11_targetName) { this->targetName_ = _x11_targetName; }
    inline void targetName (std::string&& _x11_targetName) { this->targetName_ = std::move (_x11_targetName); }
    inline const std::string& targetName () const { return this->targetName_; }
    inline std::string& targetName () { return this->targetName_; }
    //@}

    /// @copydoc test.idl::Deployment::ConnectionResourceDeploymentDescription::requirementName
    //@{
    inline void requirementName (const std::string& _x11_requirementName) { this->requirementName_ = _x11_requirementName; }
    inline void requirementName (std::string&& _x11_requirementName) { this->requirementName_ = std::move (_x11_requirementName); }
    inline const std::string& requirementName () const { return this->requirementName_; }
    inline std::string& requirementName () { return this->requirementName_; }
    //@}

    /// @copydoc test.idl::Deployment::ConnectionResourceDeploymentDescription::resourceName
    //@{
    inline void resourceName (const std::string& _x11_resourceName) { this->resourceName_ = _x11_resourceName; }
    inline void resourceName (std::string&& _x11_resourceName) { this->resourceName_ = std::move (_x11_resourceName); }
    inline const std::string& resourceName () const { return this->resourceName_; }
    inline std::string& resourceName () { return this->resourceName_; }
    //@}

    /// @copydoc test.idl::Deployment::ConnectionResourceDeploymentDescription::property
    //@{
    inline void property (const ::Deployment::Properties& _x11_property) { this->property_ = _x11_property; }
    inline void property (::Deployment::Properties&& _x11_property) { this->property_ = std::move (_x11_property); }
    inline const ::Deployment::Properties& property () const { return this->property_; }
    inline ::Deployment::Properties& property () { return this->property_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ConnectionResourceDeploymentDescription& s);

  private:
    std::string targetName_;
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// ConnectionResourceDeploymentDescription

  inline void swap (::Deployment::ConnectionResourceDeploymentDescription& m1, ::Deployment::ConnectionResourceDeploymentDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ConnectionResourceDeploymentDescriptions
  using ConnectionResourceDeploymentDescriptions = std::vector< ConnectionResourceDeploymentDescription>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::PlanConnectionDescription
  class PlanConnectionDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    PlanConnectionDescription () = default;
    /// Destructor
    ~PlanConnectionDescription () = default;
    /// Copy constructor
    PlanConnectionDescription (const PlanConnectionDescription&) = default;
    /// Move constructor
    PlanConnectionDescription (PlanConnectionDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanConnectionDescription (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      ::Deployment::Requirements deployRequirement,
      ::Deployment::ComponentExternalPortEndpoints externalEndpoint,
      ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint,
      ::Deployment::ExternalReferenceEndpoints externalReference,
      ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource);
    /// Copy assignment operator
    PlanConnectionDescription& operator= (const PlanConnectionDescription&) = default;
    /// Move assignment operator
    PlanConnectionDescription& operator= (PlanConnectionDescription&&) = default;

    /// @copydoc test.idl::Deployment::PlanConnectionDescription::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanConnectionDescription::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_source) { this->source_ = _x11_source; }
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_source) { this->source_ = std::move (_x11_source); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const { return this->source_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source () { return this->source_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanConnectionDescription::deployRequirement
    //@{
    inline void deployRequirement (const ::Deployment::Requirements& _x11_deployRequirement) { this->deployRequirement_ = _x11_deployRequirement; }
    inline void deployRequirement (::Deployment::Requirements&& _x11_deployRequirement) { this->deployRequirement_ = std::move (_x11_deployRequirement); }
    inline const ::Deployment::Requirements& deployRequirement () const { return this->deployRequirement_; }
    inline ::Deployment::Requirements& deployRequirement () { return this->deployRequirement_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanConnectionDescription::externalEndpoint
    //@{
    inline void externalEndpoint (const ::Deployment::ComponentExternalPortEndpoints& _x11_externalEndpoint) { this->externalEndpoint_ = _x11_externalEndpoint; }
    inline void externalEndpoint (::Deployment::ComponentExternalPortEndpoints&& _x11_externalEndpoint) { this->externalEndpoint_ = std::move (_x11_externalEndpoint); }
    inline const ::Deployment::ComponentExternalPortEndpoints& externalEndpoint () const { return this->externalEndpoint_; }
    inline ::Deployment::ComponentExternalPortEndpoints& externalEndpoint () { return this->externalEndpoint_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanConnectionDescription::internalEndpoint
    //@{
    inline void internalEndpoint (const ::Deployment::PlanSubcomponentPortEndpoints& _x11_internalEndpoint) { this->internalEndpoint_ = _x11_internalEndpoint; }
    inline void internalEndpoint (::Deployment::PlanSubcomponentPortEndpoints&& _x11_internalEndpoint) { this->internalEndpoint_ = std::move (_x11_internalEndpoint); }
    inline const ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint () const { return this->internalEndpoint_; }
    inline ::Deployment::PlanSubcomponentPortEndpoints& internalEndpoint () { return this->internalEndpoint_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanConnectionDescription::externalReference
    //@{
    inline void externalReference (const ::Deployment::ExternalReferenceEndpoints& _x11_externalReference) { this->externalReference_ = _x11_externalReference; }
    inline void externalReference (::Deployment::ExternalReferenceEndpoints&& _x11_externalReference) { this->externalReference_ = std::move (_x11_externalReference); }
    inline const ::Deployment::ExternalReferenceEndpoints& externalReference () const { return this->externalReference_; }
    inline ::Deployment::ExternalReferenceEndpoints& externalReference () { return this->externalReference_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanConnectionDescription::deployedResource
    //@{
    inline void deployedResource (const ::Deployment::ConnectionResourceDeploymentDescriptions& _x11_deployedResource) { this->deployedResource_ = _x11_deployedResource; }
    inline void deployedResource (::Deployment::ConnectionResourceDeploymentDescriptions&& _x11_deployedResource) { this->deployedResource_ = std::move (_x11_deployedResource); }
    inline const ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource () const { return this->deployedResource_; }
    inline ::Deployment::ConnectionResourceDeploymentDescriptions& deployedResource () { return this->deployedResource_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanConnectionDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ComponentExternalPortEndpoints externalEndpoint_;
    ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint_;
    ::Deployment::ExternalReferenceEndpoints externalReference_;
    ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource_;
  };// PlanConnectionDescription

  inline void swap (::Deployment::PlanConnectionDescription& m1, ::Deployment::PlanConnectionDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::PlanConnectionDescriptions
  using PlanConnectionDescriptions = std::vector< PlanConnectionDescription>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::PlanSubcomponentPropertyReference
  class PlanSubcomponentPropertyReference
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    PlanSubcomponentPropertyReference () = default;
    /// Destructor
    ~PlanSubcomponentPropertyReference () = default;
    /// Copy constructor
    PlanSubcomponentPropertyReference (const PlanSubcomponentPropertyReference&) = default;
    /// Move constructor
    PlanSubcomponentPropertyReference (PlanSubcomponentPropertyReference&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanSubcomponentPropertyReference (
      std::string propertyName,
      uint32_t instanceRef);
    /// Copy assignment operator
    PlanSubcomponentPropertyReference& operator= (const PlanSubcomponentPropertyReference&) = default;
    /// Move assignment operator
    PlanSubcomponentPropertyReference& operator= (PlanSubcomponentPropertyReference&&) = default;

    /// @copydoc test.idl::Deployment::PlanSubcomponentPropertyReference::propertyName
    //@{
    inline void propertyName (const std::string& _x11_propertyName) { this->propertyName_ = _x11_propertyName; }
    inline void propertyName (std::string&& _x11_propertyName) { this->propertyName_ = std::move (_x11_propertyName); }
    inline const std::string& propertyName () const { return this->propertyName_; }
    inline std::string& propertyName () { return this->propertyName_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanSubcomponentPropertyReference::instanceRef
    //@{
    inline void instanceRef (uint32_t _x11_instanceRef) { this->instanceRef_ = _x11_instanceRef; }
    inline uint32_t instanceRef () const { return this->instanceRef_; }
    inline uint32_t& instanceRef () { return this->instanceRef_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanSubcomponentPropertyReference& s);

  private:
    std::string propertyName_;
    uint32_t instanceRef_ {};
  };// PlanSubcomponentPropertyReference

  inline void swap (::Deployment::PlanSubcomponentPropertyReference& m1, ::Deployment::PlanSubcomponentPropertyReference& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::PlanSubcomponentPropertyReferences
  using PlanSubcomponentPropertyReferences = std::vector< PlanSubcomponentPropertyReference>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::PlanPropertyMapping
  class PlanPropertyMapping
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    PlanPropertyMapping () = default;
    /// Destructor
    ~PlanPropertyMapping () = default;
    /// Copy constructor
    PlanPropertyMapping (const PlanPropertyMapping&) = default;
    /// Move constructor
    PlanPropertyMapping (PlanPropertyMapping&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanPropertyMapping (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      std::string externalName,
      ::Deployment::PlanSubcomponentPropertyReferences delegatesTo);
    /// Copy assignment operator
    PlanPropertyMapping& operator= (const PlanPropertyMapping&) = default;
    /// Move assignment operator
    PlanPropertyMapping& operator= (PlanPropertyMapping&&) = default;

    /// @copydoc test.idl::Deployment::PlanPropertyMapping::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanPropertyMapping::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_source) { this->source_ = _x11_source; }
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_source) { this->source_ = std::move (_x11_source); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const { return this->source_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source () { return this->source_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanPropertyMapping::externalName
    //@{
    inline void externalName (const std::string& _x11_externalName) { this->externalName_ = _x11_externalName; }
    inline void externalName (std::string&& _x11_externalName) { this->externalName_ = std::move (_x11_externalName); }
    inline const std::string& externalName () const { return this->externalName_; }
    inline std::string& externalName () { return this->externalName_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanPropertyMapping::delegatesTo
    //@{
    inline void delegatesTo (const ::Deployment::PlanSubcomponentPropertyReferences& _x11_delegatesTo) { this->delegatesTo_ = _x11_delegatesTo; }
    inline void delegatesTo (::Deployment::PlanSubcomponentPropertyReferences&& _x11_delegatesTo) { this->delegatesTo_ = std::move (_x11_delegatesTo); }
    inline const ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo () const { return this->delegatesTo_; }
    inline ::Deployment::PlanSubcomponentPropertyReferences& delegatesTo () { return this->delegatesTo_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanPropertyMapping& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    std::string externalName_;
    ::Deployment::PlanSubcomponentPropertyReferences delegatesTo_;
  };// PlanPropertyMapping

  inline void swap (::Deployment::PlanPropertyMapping& m1, ::Deployment::PlanPropertyMapping& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::PlanPropertyMappings
  using PlanPropertyMappings = std::vector< PlanPropertyMapping>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ImplementationDependency
  class ImplementationDependency
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ImplementationDependency () = default;
    /// Destructor
    ~ImplementationDependency () = default;
    /// Copy constructor
    ImplementationDependency (const ImplementationDependency&) = default;
    /// Move constructor
    ImplementationDependency (ImplementationDependency&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ImplementationDependency (
      std::string requiredType);
    /// Copy assignment operator
    ImplementationDependency& operator= (const ImplementationDependency&) = default;
    /// Move assignment operator
    ImplementationDependency& operator= (ImplementationDependency&&) = default;

    /// @copydoc test.idl::Deployment::ImplementationDependency::requiredType
    //@{
    inline void requiredType (const std::string& _x11_requiredType) { this->requiredType_ = _x11_requiredType; }
    inline void requiredType (std::string&& _x11_requiredType) { this->requiredType_ = std::move (_x11_requiredType); }
    inline const std::string& requiredType () const { return this->requiredType_; }
    inline std::string& requiredType () { return this->requiredType_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ImplementationDependency& s);

  private:
    std::string requiredType_;
  };// ImplementationDependency

  inline void swap (::Deployment::ImplementationDependency& m1, ::Deployment::ImplementationDependency& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ImplementationDependencies
  using ImplementationDependencies = std::vector< ImplementationDependency>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ResourceDeploymentDescription
  class ResourceDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ResourceDeploymentDescription () = default;
    /// Destructor
    ~ResourceDeploymentDescription () = default;
    /// Copy constructor
    ResourceDeploymentDescription (const ResourceDeploymentDescription&) = default;
    /// Move constructor
    ResourceDeploymentDescription (ResourceDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ResourceDeploymentDescription (
      std::string requirementName,
      std::string resourceName,
      ::Deployment::Properties property);
    /// Copy assignment operator
    ResourceDeploymentDescription& operator= (const ResourceDeploymentDescription&) = default;
    /// Move assignment operator
    ResourceDeploymentDescription& operator= (ResourceDeploymentDescription&&) = default;

    /// @copydoc test.idl::Deployment::ResourceDeploymentDescription::requirementName
    //@{
    inline void requirementName (const std::string& _x11_requirementName) { this->requirementName_ = _x11_requirementName; }
    inline void requirementName (std::string&& _x11_requirementName) { this->requirementName_ = std::move (_x11_requirementName); }
    inline const std::string& requirementName () const { return this->requirementName_; }
    inline std::string& requirementName () { return this->requirementName_; }
    //@}

    /// @copydoc test.idl::Deployment::ResourceDeploymentDescription::resourceName
    //@{
    inline void resourceName (const std::string& _x11_resourceName) { this->resourceName_ = _x11_resourceName; }
    inline void resourceName (std::string&& _x11_resourceName) { this->resourceName_ = std::move (_x11_resourceName); }
    inline const std::string& resourceName () const { return this->resourceName_; }
    inline std::string& resourceName () { return this->resourceName_; }
    //@}

    /// @copydoc test.idl::Deployment::ResourceDeploymentDescription::property
    //@{
    inline void property (const ::Deployment::Properties& _x11_property) { this->property_ = _x11_property; }
    inline void property (::Deployment::Properties&& _x11_property) { this->property_ = std::move (_x11_property); }
    inline const ::Deployment::Properties& property () const { return this->property_; }
    inline ::Deployment::Properties& property () { return this->property_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ResourceDeploymentDescription& s);

  private:
    std::string requirementName_;
    std::string resourceName_;
    ::Deployment::Properties property_;
  };// ResourceDeploymentDescription

  inline void swap (::Deployment::ResourceDeploymentDescription& m1, ::Deployment::ResourceDeploymentDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ResourceDeploymentDescriptions
  using ResourceDeploymentDescriptions = std::vector< ResourceDeploymentDescription>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ArtifactDeploymentDescription
  class ArtifactDeploymentDescription
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ArtifactDeploymentDescription () = default;
    /// Destructor
    ~ArtifactDeploymentDescription () = default;
    /// Copy constructor
    ArtifactDeploymentDescription (const ArtifactDeploymentDescription&) = default;
    /// Move constructor
    ArtifactDeploymentDescription (ArtifactDeploymentDescription&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ArtifactDeploymentDescription (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq location,
      std::string node,
      ::TAOX11_NAMESPACE::CORBA::StringSeq source,
      ::Deployment::Properties execParameter,
      ::Deployment::Requirements deployRequirement,
      ::Deployment::ResourceDeploymentDescriptions deployedResource);
    /// Copy assignment operator
    ArtifactDeploymentDescription& operator= (const ArtifactDeploymentDescription&) = default;
    /// Move assignment operator
    ArtifactDeploymentDescription& operator= (ArtifactDeploymentDescription&&) = default;

    /// @copydoc test.idl::Deployment::ArtifactDeploymentDescription::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::ArtifactDeploymentDescription::location
    //@{
    inline void location (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_location) { this->location_ = _x11_location; }
    inline void location (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_location) { this->location_ = std::move (_x11_location); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& location () const { return this->location_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& location () { return this->location_; }
    //@}

    /// @copydoc test.idl::Deployment::ArtifactDeploymentDescription::node
    //@{
    inline void node (const std::string& _x11_node) { this->node_ = _x11_node; }
    inline void node (std::string&& _x11_node) { this->node_ = std::move (_x11_node); }
    inline const std::string& node () const { return this->node_; }
    inline std::string& node () { return this->node_; }
    //@}

    /// @copydoc test.idl::Deployment::ArtifactDeploymentDescription::source
    //@{
    inline void source (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_source) { this->source_ = _x11_source; }
    inline void source (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_source) { this->source_ = std::move (_x11_source); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& source () const { return this->source_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& source () { return this->source_; }
    //@}

    /// @copydoc test.idl::Deployment::ArtifactDeploymentDescription::execParameter
    //@{
    inline void execParameter (const ::Deployment::Properties& _x11_execParameter) { this->execParameter_ = _x11_execParameter; }
    inline void execParameter (::Deployment::Properties&& _x11_execParameter) { this->execParameter_ = std::move (_x11_execParameter); }
    inline const ::Deployment::Properties& execParameter () const { return this->execParameter_; }
    inline ::Deployment::Properties& execParameter () { return this->execParameter_; }
    //@}

    /// @copydoc test.idl::Deployment::ArtifactDeploymentDescription::deployRequirement
    //@{
    inline void deployRequirement (const ::Deployment::Requirements& _x11_deployRequirement) { this->deployRequirement_ = _x11_deployRequirement; }
    inline void deployRequirement (::Deployment::Requirements&& _x11_deployRequirement) { this->deployRequirement_ = std::move (_x11_deployRequirement); }
    inline const ::Deployment::Requirements& deployRequirement () const { return this->deployRequirement_; }
    inline ::Deployment::Requirements& deployRequirement () { return this->deployRequirement_; }
    //@}

    /// @copydoc test.idl::Deployment::ArtifactDeploymentDescription::deployedResource
    //@{
    inline void deployedResource (const ::Deployment::ResourceDeploymentDescriptions& _x11_deployedResource) { this->deployedResource_ = _x11_deployedResource; }
    inline void deployedResource (::Deployment::ResourceDeploymentDescriptions&& _x11_deployedResource) { this->deployedResource_ = std::move (_x11_deployedResource); }
    inline const ::Deployment::ResourceDeploymentDescriptions& deployedResource () const { return this->deployedResource_; }
    inline ::Deployment::ResourceDeploymentDescriptions& deployedResource () { return this->deployedResource_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ArtifactDeploymentDescription& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq location_;
    std::string node_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq source_;
    ::Deployment::Properties execParameter_;
    ::Deployment::Requirements deployRequirement_;
    ::Deployment::ResourceDeploymentDescriptions deployedResource_;
  };// ArtifactDeploymentDescription

  inline void swap (::Deployment::ArtifactDeploymentDescription& m1, ::Deployment::ArtifactDeploymentDescription& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ArtifactDeploymentDescriptions
  using ArtifactDeploymentDescriptions = std::vector< ArtifactDeploymentDescription>;

  // generated from c++11/templates/cli/hdr/enum

  /// @copydoc test.idl::Deployment::PlanLocalityKind
  enum class PlanLocalityKind : uint32_t
  {
    /// @copydoc test.idl::Deployment::PlanLocalityKind::PlanSameProcess
    PlanSameProcess,
    /// @copydoc test.idl::Deployment::PlanLocalityKind::PlanDifferentProcess
    PlanDifferentProcess,
    /// @copydoc test.idl::Deployment::PlanLocalityKind::PlanNoConstraint
    PlanNoConstraint
  };// PlanLocalityKind


  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::PlanLocality
  class PlanLocality
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    PlanLocality () = default;
    /// Destructor
    ~PlanLocality () = default;
    /// Copy constructor
    PlanLocality (const PlanLocality&) = default;
    /// Move constructor
    PlanLocality (PlanLocality&&) = default;
    /// Constructor which accepts value for all members
    explicit inline PlanLocality (
      ::Deployment::PlanLocalityKind constraint,
      ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef);
    /// Copy assignment operator
    PlanLocality& operator= (const PlanLocality&) = default;
    /// Move assignment operator
    PlanLocality& operator= (PlanLocality&&) = default;

    /// @copydoc test.idl::Deployment::PlanLocality::constraint
    //@{
    inline void constraint (::Deployment::PlanLocalityKind _x11_constraint) { this->constraint_ = _x11_constraint; }
    inline ::Deployment::PlanLocalityKind constraint () const { return this->constraint_; }
    inline ::Deployment::PlanLocalityKind& constraint () { return this->constraint_; }
    //@}

    /// @copydoc test.idl::Deployment::PlanLocality::constrainedInstanceRef
    //@{
    inline void constrainedInstanceRef (const ::TAOX11_NAMESPACE::CORBA::ULongSeq& _x11_constrainedInstanceRef) { this->constrainedInstanceRef_ = _x11_constrainedInstanceRef; }
    inline void constrainedInstanceRef (::TAOX11_NAMESPACE::CORBA::ULongSeq&& _x11_constrainedInstanceRef) { this->constrainedInstanceRef_ = std::move (_x11_constrainedInstanceRef); }
    inline const ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef () const { return this->constrainedInstanceRef_; }
    inline ::TAOX11_NAMESPACE::CORBA::ULongSeq& constrainedInstanceRef () { return this->constrainedInstanceRef_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (PlanLocality& s);

  private:
    ::Deployment::PlanLocalityKind constraint_ {};
    ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef_;
  };// PlanLocality

  inline void swap (::Deployment::PlanLocality& m1, ::Deployment::PlanLocality& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::PlanLocalities
  using PlanLocalities = std::vector< PlanLocality>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::DeploymentPlan
  class DeploymentPlan
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    DeploymentPlan () = default;
    /// Destructor
    ~DeploymentPlan () = default;
    /// Copy constructor
    DeploymentPlan (const DeploymentPlan&) = default;
    /// Move constructor
    DeploymentPlan (DeploymentPlan&&) = default;
    /// Constructor which accepts value for all members
    explicit inline DeploymentPlan (
      std::string label,
      std::string UUID,
      ::Deployment::ComponentInterfaceDescription realizes,
      ::Deployment::MonolithicDeploymentDescriptions implementation,
      ::Deployment::InstanceDeploymentDescriptions instance,
      ::Deployment::PlanConnectionDescriptions connection,
      ::Deployment::PlanPropertyMappings externalProperty,
      ::Deployment::ImplementationDependencies dependsOn,
      ::Deployment::ArtifactDeploymentDescriptions artifact,
      ::Deployment::Properties infoProperty,
      ::Deployment::PlanLocalities localityConstraint);
    /// Copy assignment operator
    DeploymentPlan& operator= (const DeploymentPlan&) = default;
    /// Move assignment operator
    DeploymentPlan& operator= (DeploymentPlan&&) = default;

    /// @copydoc test.idl::Deployment::DeploymentPlan::label
    //@{
    inline void label (const std::string& _x11_label) { this->label_ = _x11_label; }
    inline void label (std::string&& _x11_label) { this->label_ = std::move (_x11_label); }
    inline const std::string& label () const { return this->label_; }
    inline std::string& label () { return this->label_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::UUID
    //@{
    inline void UUID (const std::string& _x11_UUID) { this->UUID_ = _x11_UUID; }
    inline void UUID (std::string&& _x11_UUID) { this->UUID_ = std::move (_x11_UUID); }
    inline const std::string& UUID () const { return this->UUID_; }
    inline std::string& UUID () { return this->UUID_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::realizes
    //@{
    inline void realizes (const ::Deployment::ComponentInterfaceDescription& _x11_realizes) { this->realizes_ = _x11_realizes; }
    inline void realizes (::Deployment::ComponentInterfaceDescription&& _x11_realizes) { this->realizes_ = std::move (_x11_realizes); }
    inline const ::Deployment::ComponentInterfaceDescription& realizes () const { return this->realizes_; }
    inline ::Deployment::ComponentInterfaceDescription& realizes () { return this->realizes_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::implementation
    //@{
    inline void implementation (const ::Deployment::MonolithicDeploymentDescriptions& _x11_implementation) { this->implementation_ = _x11_implementation; }
    inline void implementation (::Deployment::MonolithicDeploymentDescriptions&& _x11_implementation) { this->implementation_ = std::move (_x11_implementation); }
    inline const ::Deployment::MonolithicDeploymentDescriptions& implementation () const { return this->implementation_; }
    inline ::Deployment::MonolithicDeploymentDescriptions& implementation () { return this->implementation_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::instance
    //@{
    inline void instance (const ::Deployment::InstanceDeploymentDescriptions& _x11_instance) { this->instance_ = _x11_instance; }
    inline void instance (::Deployment::InstanceDeploymentDescriptions&& _x11_instance) { this->instance_ = std::move (_x11_instance); }
    inline const ::Deployment::InstanceDeploymentDescriptions& instance () const { return this->instance_; }
    inline ::Deployment::InstanceDeploymentDescriptions& instance () { return this->instance_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::connection
    //@{
    inline void connection (const ::Deployment::PlanConnectionDescriptions& _x11_connection) { this->connection_ = _x11_connection; }
    inline void connection (::Deployment::PlanConnectionDescriptions&& _x11_connection) { this->connection_ = std::move (_x11_connection); }
    inline const ::Deployment::PlanConnectionDescriptions& connection () const { return this->connection_; }
    inline ::Deployment::PlanConnectionDescriptions& connection () { return this->connection_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::externalProperty
    //@{
    inline void externalProperty (const ::Deployment::PlanPropertyMappings& _x11_externalProperty) { this->externalProperty_ = _x11_externalProperty; }
    inline void externalProperty (::Deployment::PlanPropertyMappings&& _x11_externalProperty) { this->externalProperty_ = std::move (_x11_externalProperty); }
    inline const ::Deployment::PlanPropertyMappings& externalProperty () const { return this->externalProperty_; }
    inline ::Deployment::PlanPropertyMappings& externalProperty () { return this->externalProperty_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::dependsOn
    //@{
    inline void dependsOn (const ::Deployment::ImplementationDependencies& _x11_dependsOn) { this->dependsOn_ = _x11_dependsOn; }
    inline void dependsOn (::Deployment::ImplementationDependencies&& _x11_dependsOn) { this->dependsOn_ = std::move (_x11_dependsOn); }
    inline const ::Deployment::ImplementationDependencies& dependsOn () const { return this->dependsOn_; }
    inline ::Deployment::ImplementationDependencies& dependsOn () { return this->dependsOn_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::artifact
    //@{
    inline void artifact (const ::Deployment::ArtifactDeploymentDescriptions& _x11_artifact) { this->artifact_ = _x11_artifact; }
    inline void artifact (::Deployment::ArtifactDeploymentDescriptions&& _x11_artifact) { this->artifact_ = std::move (_x11_artifact); }
    inline const ::Deployment::ArtifactDeploymentDescriptions& artifact () const { return this->artifact_; }
    inline ::Deployment::ArtifactDeploymentDescriptions& artifact () { return this->artifact_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::infoProperty
    //@{
    inline void infoProperty (const ::Deployment::Properties& _x11_infoProperty) { this->infoProperty_ = _x11_infoProperty; }
    inline void infoProperty (::Deployment::Properties&& _x11_infoProperty) { this->infoProperty_ = std::move (_x11_infoProperty); }
    inline const ::Deployment::Properties& infoProperty () const { return this->infoProperty_; }
    inline ::Deployment::Properties& infoProperty () { return this->infoProperty_; }
    //@}

    /// @copydoc test.idl::Deployment::DeploymentPlan::localityConstraint
    //@{
    inline void localityConstraint (const ::Deployment::PlanLocalities& _x11_localityConstraint) { this->localityConstraint_ = _x11_localityConstraint; }
    inline void localityConstraint (::Deployment::PlanLocalities&& _x11_localityConstraint) { this->localityConstraint_ = std::move (_x11_localityConstraint); }
    inline const ::Deployment::PlanLocalities& localityConstraint () const { return this->localityConstraint_; }
    inline ::Deployment::PlanLocalities& localityConstraint () { return this->localityConstraint_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (DeploymentPlan& s);

  private:
    std::string label_;
    std::string UUID_;
    ::Deployment::ComponentInterfaceDescription realizes_;
    ::Deployment::MonolithicDeploymentDescriptions implementation_;
    ::Deployment::InstanceDeploymentDescriptions instance_;
    ::Deployment::PlanConnectionDescriptions connection_;
    ::Deployment::PlanPropertyMappings externalProperty_;
    ::Deployment::ImplementationDependencies dependsOn_;
    ::Deployment::ArtifactDeploymentDescriptions artifact_;
    ::Deployment::Properties infoProperty_;
    ::Deployment::PlanLocalities localityConstraint_;
  };// DeploymentPlan

  inline void swap (::Deployment::DeploymentPlan& m1, ::Deployment::DeploymentPlan& m2) { m1.swap (m2); }

} // namespace Deployment


// generated from StubHeaderWriter#enter_module
/// @copydoc test.idl::Deployment
namespace Deployment
{

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ComponentPackageReference
  class ComponentPackageReference
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ComponentPackageReference () = default;
    /// Destructor
    ~ComponentPackageReference () = default;
    /// Copy constructor
    ComponentPackageReference (const ComponentPackageReference&) = default;
    /// Move constructor
    ComponentPackageReference (ComponentPackageReference&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ComponentPackageReference (
      std::string requiredUUID,
      std::string requiredName,
      ::Deployment::ComponentInterfaceDescription requiredType);
    /// Copy assignment operator
    ComponentPackageReference& operator= (const ComponentPackageReference&) = default;
    /// Move assignment operator
    ComponentPackageReference& operator= (ComponentPackageReference&&) = default;

    /// @copydoc test.idl::Deployment::ComponentPackageReference::requiredUUID
    //@{
    inline void requiredUUID (const std::string& _x11_requiredUUID) { this->requiredUUID_ = _x11_requiredUUID; }
    inline void requiredUUID (std::string&& _x11_requiredUUID) { this->requiredUUID_ = std::move (_x11_requiredUUID); }
    inline const std::string& requiredUUID () const { return this->requiredUUID_; }
    inline std::string& requiredUUID () { return this->requiredUUID_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPackageReference::requiredName
    //@{
    inline void requiredName (const std::string& _x11_requiredName) { this->requiredName_ = _x11_requiredName; }
    inline void requiredName (std::string&& _x11_requiredName) { this->requiredName_ = std::move (_x11_requiredName); }
    inline const std::string& requiredName () const { return this->requiredName_; }
    inline std::string& requiredName () { return this->requiredName_; }
    //@}

    /// @copydoc test.idl::Deployment::ComponentPackageReference::requiredType
    //@{
    inline void requiredType (const ::Deployment::ComponentInterfaceDescription& _x11_requiredType) { this->requiredType_ = _x11_requiredType; }
    inline void requiredType (::Deployment::ComponentInterfaceDescription&& _x11_requiredType) { this->requiredType_ = std::move (_x11_requiredType); }
    inline const ::Deployment::ComponentInterfaceDescription& requiredType () const { return this->requiredType_; }
    inline ::Deployment::ComponentInterfaceDescription& requiredType () { return this->requiredType_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ComponentPackageReference& s);

  private:
    std::string requiredUUID_;
    std::string requiredName_;
    ::Deployment::ComponentInterfaceDescription requiredType_;
  };// ComponentPackageReference

  inline void swap (::Deployment::ComponentPackageReference& m1, ::Deployment::ComponentPackageReference& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ComponentPackageReferences
  using ComponentPackageReferences = std::vector< ComponentPackageReference>;

  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ResourceUsageKinds
  using ResourceUsageKinds = std::vector< ::Deployment::ResourceUsageKind>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::ImplementationRequirement
  class ImplementationRequirement
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    ImplementationRequirement () = default;
    /// Destructor
    ~ImplementationRequirement () = default;
    /// Copy constructor
    ImplementationRequirement (const ImplementationRequirement&) = default;
    /// Move constructor
    ImplementationRequirement (ImplementationRequirement&&) = default;
    /// Constructor which accepts value for all members
    explicit inline ImplementationRequirement (
      ::Deployment::ResourceUsageKinds resourceUsage,
      std::string resourcePort,
      std::string componentPort,
      std::string name,
      std::string resourceType,
      ::Deployment::Properties property);
    /// Copy assignment operator
    ImplementationRequirement& operator= (const ImplementationRequirement&) = default;
    /// Move assignment operator
    ImplementationRequirement& operator= (ImplementationRequirement&&) = default;

    /// @copydoc test.idl::Deployment::ImplementationRequirement::resourceUsage
    //@{
    inline void resourceUsage (const ::Deployment::ResourceUsageKinds& _x11_resourceUsage) { this->resourceUsage_ = _x11_resourceUsage; }
    inline void resourceUsage (::Deployment::ResourceUsageKinds&& _x11_resourceUsage) { this->resourceUsage_ = std::move (_x11_resourceUsage); }
    inline const ::Deployment::ResourceUsageKinds& resourceUsage () const { return this->resourceUsage_; }
    inline ::Deployment::ResourceUsageKinds& resourceUsage () { return this->resourceUsage_; }
    //@}

    /// @copydoc test.idl::Deployment::ImplementationRequirement::resourcePort
    //@{
    inline void resourcePort (const std::string& _x11_resourcePort) { this->resourcePort_ = _x11_resourcePort; }
    inline void resourcePort (std::string&& _x11_resourcePort) { this->resourcePort_ = std::move (_x11_resourcePort); }
    inline const std::string& resourcePort () const { return this->resourcePort_; }
    inline std::string& resourcePort () { return this->resourcePort_; }
    //@}

    /// @copydoc test.idl::Deployment::ImplementationRequirement::componentPort
    //@{
    inline void componentPort (const std::string& _x11_componentPort) { this->componentPort_ = _x11_componentPort; }
    inline void componentPort (std::string&& _x11_componentPort) { this->componentPort_ = std::move (_x11_componentPort); }
    inline const std::string& componentPort () const { return this->componentPort_; }
    inline std::string& componentPort () { return this->componentPort_; }
    //@}

    /// @copydoc test.idl::Deployment::ImplementationRequirement::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::ImplementationRequirement::resourceType
    //@{
    inline void resourceType (const std::string& _x11_resourceType) { this->resourceType_ = _x11_resourceType; }
    inline void resourceType (std::string&& _x11_resourceType) { this->resourceType_ = std::move (_x11_resourceType); }
    inline const std::string& resourceType () const { return this->resourceType_; }
    inline std::string& resourceType () { return this->resourceType_; }
    //@}

    /// @copydoc test.idl::Deployment::ImplementationRequirement::property
    //@{
    inline void property (const ::Deployment::Properties& _x11_property) { this->property_ = _x11_property; }
    inline void property (::Deployment::Properties&& _x11_property) { this->property_ = std::move (_x11_property); }
    inline const ::Deployment::Properties& property () const { return this->property_; }
    inline ::Deployment::Properties& property () { return this->property_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (ImplementationRequirement& s);

  private:
    ::Deployment::ResourceUsageKinds resourceUsage_;
    std::string resourcePort_;
    std::string componentPort_;
    std::string name_;
    std::string resourceType_;
    ::Deployment::Properties property_;
  };// ImplementationRequirement

  inline void swap (::Deployment::ImplementationRequirement& m1, ::Deployment::ImplementationRequirement& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::ImplementationRequirements
  using ImplementationRequirements = std::vector< ImplementationRequirement>;

  // generated from c++11/templates/cli/hdr/struct_pre

  /// @copydoc test.idl::Deployment::Capability
  class Capability
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post
    /// Default constructor
    Capability () = default;
    /// Destructor
    ~Capability () = default;
    /// Copy constructor
    Capability (const Capability&) = default;
    /// Move constructor
    Capability (Capability&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Capability (
      std::string name,
      ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType,
      ::Deployment::SatisfierProperties property);
    /// Copy assignment operator
    Capability& operator= (const Capability&) = default;
    /// Move assignment operator
    Capability& operator= (Capability&&) = default;

    /// @copydoc test.idl::Deployment::Capability::name
    //@{
    inline void name (const std::string& _x11_name) { this->name_ = _x11_name; }
    inline void name (std::string&& _x11_name) { this->name_ = std::move (_x11_name); }
    inline const std::string& name () const { return this->name_; }
    inline std::string& name () { return this->name_; }
    //@}

    /// @copydoc test.idl::Deployment::Capability::resourceType
    //@{
    inline void resourceType (const ::TAOX11_NAMESPACE::CORBA::StringSeq& _x11_resourceType) { this->resourceType_ = _x11_resourceType; }
    inline void resourceType (::TAOX11_NAMESPACE::CORBA::StringSeq&& _x11_resourceType) { this->resourceType_ = std::move (_x11_resourceType); }
    inline const ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType () const { return this->resourceType_; }
    inline ::TAOX11_NAMESPACE::CORBA::StringSeq& resourceType () { return this->resourceType_; }
    //@}

    /// @copydoc test.idl::Deployment::Capability::property
    //@{
    inline void property (const ::Deployment::SatisfierProperties& _x11_property) { this->property_ = _x11_property; }
    inline void property (::Deployment::SatisfierProperties&& _x11_property) { this->property_ = std::move (_x11_property); }
    inline const ::Deployment::SatisfierProperties& property () const { return this->property_; }
    inline ::Deployment::SatisfierProperties& property () { return this->property_; }
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (Capability& s);

  private:
    std::string name_;
    ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType_;
    ::Deployment::SatisfierProperties property_;
  };// Capability

  inline void swap (::Deployment::Capability& m1, ::Deployment::Capability& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Deployment::Capabilities
  using Capabilities = std::vector< Capability>;
} // namespace Deployment


// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__PROPERTY_TRAITS_)
#define _STRUCT_DEPLOYMENT__PROPERTY_TRAITS_
    template<>
    struct traits < ::Deployment::Property>
      : IDL::common_traits< ::Deployment::Property>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::Property, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::Property>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__PROPERTY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::Property>
    // MD5            : D7395FCE530B622658DD71B872EFFEFC
#if !defined(_ALIAS_D7395FCE530B622658DD71B872EFFEFC_TRAITS_DECL_)
#define _ALIAS_D7395FCE530B622658DD71B872EFFEFC_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::Properties>
      : IDL::common_traits< ::Deployment::Properties>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::Property>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Properties>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::Properties>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::Properties, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::Properties>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__REQUIREMENT_TRAITS_)
#define _STRUCT_DEPLOYMENT__REQUIREMENT_TRAITS_
    template<>
    struct traits < ::Deployment::Requirement>
      : IDL::common_traits< ::Deployment::Requirement>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::Requirement, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::Requirement>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__REQUIREMENT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::Requirement>
    // MD5            : 3265D777E1B663C0C3E8129C9FA7A92F
#if !defined(_ALIAS_3265D777E1B663C0C3E8129C9FA7A92F_TRAITS_DECL_)
#define _ALIAS_3265D777E1B663C0C3E8129C9FA7A92F_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::Requirements>
      : IDL::common_traits< ::Deployment::Requirements>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::Requirement>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Requirements>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::Requirements>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::Requirements, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::Requirements>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits
    template<>
    struct traits < ::Deployment::SatisfierPropertyKind>
      : IDL::common_byval_traits< ::Deployment::SatisfierPropertyKind>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::SatisfierPropertyKind, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Deployment::SatisfierPropertyKind val_)
      {
        switch (val_)
        {
          case ::Deployment::SatisfierPropertyKind::Quantity: os_ << "Deployment::SatisfierPropertyKind::Quantity"; break;
          case ::Deployment::SatisfierPropertyKind::Capacity: os_ << "Deployment::SatisfierPropertyKind::Capacity"; break;
          case ::Deployment::SatisfierPropertyKind::Minimum: os_ << "Deployment::SatisfierPropertyKind::Minimum"; break;
          case ::Deployment::SatisfierPropertyKind::Maximum: os_ << "Deployment::SatisfierPropertyKind::Maximum"; break;
          case ::Deployment::SatisfierPropertyKind::Attribute: os_ << "Deployment::SatisfierPropertyKind::Attribute"; break;
          case ::Deployment::SatisfierPropertyKind::Selection: os_ << "Deployment::SatisfierPropertyKind::Selection"; break;
        }
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::SatisfierPropertyKind>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::SatisfierPropertyKind>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::SatisfierPropertyKind, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::SatisfierPropertyKind>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__SATISFIERPROPERTY_TRAITS_)
#define _STRUCT_DEPLOYMENT__SATISFIERPROPERTY_TRAITS_
    template<>
    struct traits < ::Deployment::SatisfierProperty>
      : IDL::common_traits< ::Deployment::SatisfierProperty>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::SatisfierProperty, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::SatisfierProperty>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__SATISFIERPROPERTY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::SatisfierProperty>
    // MD5            : EB80218682E63B0775FD6299B3051E6D
#if !defined(_ALIAS_EB80218682E63B0775FD6299B3051E6D_TRAITS_DECL_)
#define _ALIAS_EB80218682E63B0775FD6299B3051E6D_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::SatisfierProperties>
      : IDL::common_traits< ::Deployment::SatisfierProperties>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::SatisfierProperty>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::SatisfierProperties>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::SatisfierProperties>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::SatisfierProperties, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::SatisfierProperties>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits
    template<>
    struct traits < ::Deployment::CCMComponentPortKind>
      : IDL::common_byval_traits< ::Deployment::CCMComponentPortKind>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::CCMComponentPortKind, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Deployment::CCMComponentPortKind val_)
      {
        switch (val_)
        {
          case ::Deployment::CCMComponentPortKind::Facet: os_ << "Deployment::CCMComponentPortKind::Facet"; break;
          case ::Deployment::CCMComponentPortKind::SimplexReceptacle: os_ << "Deployment::CCMComponentPortKind::SimplexReceptacle"; break;
          case ::Deployment::CCMComponentPortKind::MultiplexReceptacle: os_ << "Deployment::CCMComponentPortKind::MultiplexReceptacle"; break;
          case ::Deployment::CCMComponentPortKind::EventEmitter: os_ << "Deployment::CCMComponentPortKind::EventEmitter"; break;
          case ::Deployment::CCMComponentPortKind::EventPublisher: os_ << "Deployment::CCMComponentPortKind::EventPublisher"; break;
          case ::Deployment::CCMComponentPortKind::EventConsumer: os_ << "Deployment::CCMComponentPortKind::EventConsumer"; break;
          case ::Deployment::CCMComponentPortKind::ExtendedPort: os_ << "Deployment::CCMComponentPortKind::ExtendedPort"; break;
          case ::Deployment::CCMComponentPortKind::MirrorPort: os_ << "Deployment::CCMComponentPortKind::MirrorPort"; break;
        }
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::CCMComponentPortKind>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::CCMComponentPortKind>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::CCMComponentPortKind, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::CCMComponentPortKind>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__COMPONENTPORTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__COMPONENTPORTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPortDescription>
      : IDL::common_traits< ::Deployment::ComponentPortDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPortDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentPortDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__COMPONENTPORTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ComponentPortDescription>
    // MD5            : 12954963972B5124A7A21E0C4327729B
#if !defined(_ALIAS_12954963972B5124A7A21E0C4327729B_TRAITS_DECL_)
#define _ALIAS_12954963972B5124A7A21E0C4327729B_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentPortDescriptions>
      : IDL::common_traits< ::Deployment::ComponentPortDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ComponentPortDescription>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPortDescriptions>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ComponentPortDescriptions>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ComponentPortDescriptions, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ComponentPortDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__COMPONENTPROPERTYDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__COMPONENTPROPERTYDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPropertyDescription>
      : IDL::common_traits< ::Deployment::ComponentPropertyDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPropertyDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentPropertyDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__COMPONENTPROPERTYDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ComponentPropertyDescription>
    // MD5            : 920E8F149D82D841A00A08FE0557725B
#if !defined(_ALIAS_920E8F149D82D841A00A08FE0557725B_TRAITS_DECL_)
#define _ALIAS_920E8F149D82D841A00A08FE0557725B_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentPropertyDescriptions>
      : IDL::common_traits< ::Deployment::ComponentPropertyDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ComponentPropertyDescription>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPropertyDescriptions>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ComponentPropertyDescriptions>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ComponentPropertyDescriptions, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ComponentPropertyDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__COMPONENTINTERFACEDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__COMPONENTINTERFACEDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentInterfaceDescription>
      : IDL::common_traits< ::Deployment::ComponentInterfaceDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentInterfaceDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentInterfaceDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__COMPONENTINTERFACEDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::MonolithicDeploymentDescription>
      : IDL::common_traits< ::Deployment::MonolithicDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::MonolithicDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::MonolithicDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__MONOLITHICDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::MonolithicDeploymentDescription>
    // MD5            : 8CA1C515FCEF8C84C8A8AC3BF21E75A1
#if !defined(_ALIAS_8CA1C515FCEF8C84C8A8AC3BF21E75A1_TRAITS_DECL_)
#define _ALIAS_8CA1C515FCEF8C84C8A8AC3BF21E75A1_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::MonolithicDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::MonolithicDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::MonolithicDeploymentDescription>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::MonolithicDeploymentDescriptions, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits
    template<>
    struct traits < ::Deployment::ResourceUsageKind>
      : IDL::common_byval_traits< ::Deployment::ResourceUsageKind>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ResourceUsageKind, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Deployment::ResourceUsageKind val_)
      {
        switch (val_)
        {
          case ::Deployment::ResourceUsageKind::None: os_ << "Deployment::ResourceUsageKind::None"; break;
          case ::Deployment::ResourceUsageKind::InstanceUsesResource: os_ << "Deployment::ResourceUsageKind::InstanceUsesResource"; break;
          case ::Deployment::ResourceUsageKind::ResourceUsesInstance: os_ << "Deployment::ResourceUsageKind::ResourceUsesInstance"; break;
          case ::Deployment::ResourceUsageKind::PortUsesResource: os_ << "Deployment::ResourceUsageKind::PortUsesResource"; break;
          case ::Deployment::ResourceUsageKind::ResourceUsesPort: os_ << "Deployment::ResourceUsageKind::ResourceUsesPort"; break;
        }
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ResourceUsageKind>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ResourceUsageKind>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ResourceUsageKind, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ResourceUsageKind>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::InstanceResourceDeploymentDescription>
      : IDL::common_traits< ::Deployment::InstanceResourceDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::InstanceResourceDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__INSTANCERESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::InstanceResourceDeploymentDescription>
    // MD5            : 7DA1C006DFD4ED780225B6DDB077F883
#if !defined(_ALIAS_7DA1C006DFD4ED780225B6DDB077F883_TRAITS_DECL_)
#define _ALIAS_7DA1C006DFD4ED780225B6DDB077F883_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::InstanceResourceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::InstanceResourceDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::InstanceResourceDeploymentDescriptions, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::InstanceDeploymentDescription>
      : IDL::common_traits< ::Deployment::InstanceDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::InstanceDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::InstanceDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__INSTANCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::InstanceDeploymentDescription>
    // MD5            : 8B4B636BAEF9B16F13A7BA16B787ADEA
#if !defined(_ALIAS_8B4B636BAEF9B16F13A7BA16B787ADEA_TRAITS_DECL_)
#define _ALIAS_8B4B636BAEF9B16F13A7BA16B787ADEA_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::InstanceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::InstanceDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::InstanceDeploymentDescription>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::InstanceDeploymentDescriptions, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__COMPONENTEXTERNALPORTENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT__COMPONENTEXTERNALPORTENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentExternalPortEndpoint>
      : IDL::common_traits< ::Deployment::ComponentExternalPortEndpoint>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentExternalPortEndpoint, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__COMPONENTEXTERNALPORTENDPOINT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ComponentExternalPortEndpoint>
    // MD5            : 0079E24B070B963BAFE84A5B71BC7698
#if !defined(_ALIAS_0079E24B070B963BAFE84A5B71BC7698_TRAITS_DECL_)
#define _ALIAS_0079E24B070B963BAFE84A5B71BC7698_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentExternalPortEndpoints>
      : IDL::common_traits< ::Deployment::ComponentExternalPortEndpoints>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ComponentExternalPortEndpoint>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ComponentExternalPortEndpoints, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__PLANSUBCOMPONENTPORTENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT__PLANSUBCOMPONENTPORTENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::PlanSubcomponentPortEndpoint>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPortEndpoint>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanSubcomponentPortEndpoint, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__PLANSUBCOMPONENTPORTENDPOINT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::PlanSubcomponentPortEndpoint>
    // MD5            : 1CC072AD6279ECB8F540C3C10DB1F767
#if !defined(_ALIAS_1CC072AD6279ECB8F540C3C10DB1F767_TRAITS_DECL_)
#define _ALIAS_1CC072AD6279ECB8F540C3C10DB1F767_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanSubcomponentPortEndpoints>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPortEndpoints>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanSubcomponentPortEndpoints, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__EXTERNALREFERENCEENDPOINT_TRAITS_)
#define _STRUCT_DEPLOYMENT__EXTERNALREFERENCEENDPOINT_TRAITS_
    template<>
    struct traits < ::Deployment::ExternalReferenceEndpoint>
      : IDL::common_traits< ::Deployment::ExternalReferenceEndpoint>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ExternalReferenceEndpoint, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ExternalReferenceEndpoint>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__EXTERNALREFERENCEENDPOINT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ExternalReferenceEndpoint>
    // MD5            : 2E044427492F5861B730283A565D1ED5
#if !defined(_ALIAS_2E044427492F5861B730283A565D1ED5_TRAITS_DECL_)
#define _ALIAS_2E044427492F5861B730283A565D1ED5_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ExternalReferenceEndpoints>
      : IDL::common_traits< ::Deployment::ExternalReferenceEndpoints>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ExternalReferenceEndpoint>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ExternalReferenceEndpoints>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ExternalReferenceEndpoints>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ExternalReferenceEndpoints, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ExternalReferenceEndpoints>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ConnectionResourceDeploymentDescription>
      : IDL::common_traits< ::Deployment::ConnectionResourceDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ConnectionResourceDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__CONNECTIONRESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ConnectionResourceDeploymentDescription>
    // MD5            : 4CE006491F749EF87F69C9F0666BD518
#if !defined(_ALIAS_4CE006491F749EF87F69C9F0666BD518_TRAITS_DECL_)
#define _ALIAS_4CE006491F749EF87F69C9F0666BD518_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ConnectionResourceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::ConnectionResourceDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ConnectionResourceDeploymentDescriptions, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__PLANCONNECTIONDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__PLANCONNECTIONDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::PlanConnectionDescription>
      : IDL::common_traits< ::Deployment::PlanConnectionDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanConnectionDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanConnectionDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__PLANCONNECTIONDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::PlanConnectionDescription>
    // MD5            : 0864BEE17C4222FE18C6B2C68197901B
#if !defined(_ALIAS_0864BEE17C4222FE18C6B2C68197901B_TRAITS_DECL_)
#define _ALIAS_0864BEE17C4222FE18C6B2C68197901B_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanConnectionDescriptions>
      : IDL::common_traits< ::Deployment::PlanConnectionDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::PlanConnectionDescription>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanConnectionDescriptions>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanConnectionDescriptions>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanConnectionDescriptions, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanConnectionDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_)
#define _STRUCT_DEPLOYMENT__PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_
    template<>
    struct traits < ::Deployment::PlanSubcomponentPropertyReference>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPropertyReference>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanSubcomponentPropertyReference, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__PLANSUBCOMPONENTPROPERTYREFERENCE_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::PlanSubcomponentPropertyReference>
    // MD5            : E50992F1F837050D6477978B56863FBD
#if !defined(_ALIAS_E50992F1F837050D6477978B56863FBD_TRAITS_DECL_)
#define _ALIAS_E50992F1F837050D6477978B56863FBD_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanSubcomponentPropertyReferences>
      : IDL::common_traits< ::Deployment::PlanSubcomponentPropertyReferences>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanSubcomponentPropertyReferences, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__PLANPROPERTYMAPPING_TRAITS_)
#define _STRUCT_DEPLOYMENT__PLANPROPERTYMAPPING_TRAITS_
    template<>
    struct traits < ::Deployment::PlanPropertyMapping>
      : IDL::common_traits< ::Deployment::PlanPropertyMapping>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanPropertyMapping, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanPropertyMapping>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__PLANPROPERTYMAPPING_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::PlanPropertyMapping>
    // MD5            : 0422E458499BDB48508CAB373414C33F
#if !defined(_ALIAS_0422E458499BDB48508CAB373414C33F_TRAITS_DECL_)
#define _ALIAS_0422E458499BDB48508CAB373414C33F_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanPropertyMappings>
      : IDL::common_traits< ::Deployment::PlanPropertyMappings>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::PlanPropertyMapping>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanPropertyMappings>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanPropertyMappings>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanPropertyMappings, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanPropertyMappings>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__IMPLEMENTATIONDEPENDENCY_TRAITS_)
#define _STRUCT_DEPLOYMENT__IMPLEMENTATIONDEPENDENCY_TRAITS_
    template<>
    struct traits < ::Deployment::ImplementationDependency>
      : IDL::common_traits< ::Deployment::ImplementationDependency>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ImplementationDependency, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ImplementationDependency>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__IMPLEMENTATIONDEPENDENCY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ImplementationDependency>
    // MD5            : 2C17710E0A7BA82C42ACC676758DBF1C
#if !defined(_ALIAS_2C17710E0A7BA82C42ACC676758DBF1C_TRAITS_DECL_)
#define _ALIAS_2C17710E0A7BA82C42ACC676758DBF1C_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ImplementationDependencies>
      : IDL::common_traits< ::Deployment::ImplementationDependencies>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ImplementationDependency>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ImplementationDependencies>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ImplementationDependencies>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ImplementationDependencies, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ImplementationDependencies>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ResourceDeploymentDescription>
      : IDL::common_traits< ::Deployment::ResourceDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ResourceDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ResourceDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__RESOURCEDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ResourceDeploymentDescription>
    // MD5            : 77F1484D7BC4A6841660C8A62AFD38E7
#if !defined(_ALIAS_77F1484D7BC4A6841660C8A62AFD38E7_TRAITS_DECL_)
#define _ALIAS_77F1484D7BC4A6841660C8A62AFD38E7_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ResourceDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::ResourceDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ResourceDeploymentDescription>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ResourceDeploymentDescriptions, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_)
#define _STRUCT_DEPLOYMENT__ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_
    template<>
    struct traits < ::Deployment::ArtifactDeploymentDescription>
      : IDL::common_traits< ::Deployment::ArtifactDeploymentDescription>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ArtifactDeploymentDescription, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ArtifactDeploymentDescription>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__ARTIFACTDEPLOYMENTDESCRIPTION_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ArtifactDeploymentDescription>
    // MD5            : 4B78A2395FEFF04B7A71CAF425D7AAB0
#if !defined(_ALIAS_4B78A2395FEFF04B7A71CAF425D7AAB0_TRAITS_DECL_)
#define _ALIAS_4B78A2395FEFF04B7A71CAF425D7AAB0_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ArtifactDeploymentDescriptions>
      : IDL::common_traits< ::Deployment::ArtifactDeploymentDescriptions>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ArtifactDeploymentDescription>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ArtifactDeploymentDescriptions, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/enum_idl_traits
    template<>
    struct traits < ::Deployment::PlanLocalityKind>
      : IDL::common_byval_traits< ::Deployment::PlanLocalityKind>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanLocalityKind, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Deployment::PlanLocalityKind val_)
      {
        switch (val_)
        {
          case ::Deployment::PlanLocalityKind::PlanSameProcess: os_ << "Deployment::PlanLocalityKind::PlanSameProcess"; break;
          case ::Deployment::PlanLocalityKind::PlanDifferentProcess: os_ << "Deployment::PlanLocalityKind::PlanDifferentProcess"; break;
          case ::Deployment::PlanLocalityKind::PlanNoConstraint: os_ << "Deployment::PlanLocalityKind::PlanNoConstraint"; break;
        }
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanLocalityKind>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanLocalityKind>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanLocalityKind, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanLocalityKind>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__PLANLOCALITY_TRAITS_)
#define _STRUCT_DEPLOYMENT__PLANLOCALITY_TRAITS_
    template<>
    struct traits < ::Deployment::PlanLocality>
      : IDL::common_traits< ::Deployment::PlanLocality>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::PlanLocality, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::PlanLocality>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__PLANLOCALITY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::PlanLocality>
    // MD5            : 7639FB88384E3E335A056DB5284179B1
#if !defined(_ALIAS_7639FB88384E3E335A056DB5284179B1_TRAITS_DECL_)
#define _ALIAS_7639FB88384E3E335A056DB5284179B1_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::PlanLocalities>
      : IDL::common_traits< ::Deployment::PlanLocalities>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::PlanLocality>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanLocalities>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanLocalities>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanLocalities, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanLocalities>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__DEPLOYMENTPLAN_TRAITS_)
#define _STRUCT_DEPLOYMENT__DEPLOYMENTPLAN_TRAITS_
    template<>
    struct traits < ::Deployment::DeploymentPlan>
      : IDL::common_traits< ::Deployment::DeploymentPlan>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::DeploymentPlan, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::DeploymentPlan>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__DEPLOYMENTPLAN_TRAITS_

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__COMPONENTPACKAGEREFERENCE_TRAITS_)
#define _STRUCT_DEPLOYMENT__COMPONENTPACKAGEREFERENCE_TRAITS_
    template<>
    struct traits < ::Deployment::ComponentPackageReference>
      : IDL::common_traits< ::Deployment::ComponentPackageReference>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPackageReference, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ComponentPackageReference>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__COMPONENTPACKAGEREFERENCE_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ComponentPackageReference>
    // MD5            : D5775520607EF1551FF61D9245FFC376
#if !defined(_ALIAS_D5775520607EF1551FF61D9245FFC376_TRAITS_DECL_)
#define _ALIAS_D5775520607EF1551FF61D9245FFC376_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ComponentPackageReferences>
      : IDL::common_traits< ::Deployment::ComponentPackageReferences>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ComponentPackageReference>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPackageReferences>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ComponentPackageReferences>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ComponentPackageReferences, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ComponentPackageReferences>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ResourceUsageKind>
    // MD5            : 90F1BEC8CBCE4D84EC85294F6CFABECA
#if !defined(_ALIAS_90F1BEC8CBCE4D84EC85294F6CFABECA_TRAITS_DECL_)
#define _ALIAS_90F1BEC8CBCE4D84EC85294F6CFABECA_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ResourceUsageKinds>
      : IDL::common_traits< ::Deployment::ResourceUsageKinds>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ResourceUsageKind>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ResourceUsageKinds>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ResourceUsageKinds>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ResourceUsageKinds, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ResourceUsageKinds>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__IMPLEMENTATIONREQUIREMENT_TRAITS_)
#define _STRUCT_DEPLOYMENT__IMPLEMENTATIONREQUIREMENT_TRAITS_
    template<>
    struct traits < ::Deployment::ImplementationRequirement>
      : IDL::common_traits< ::Deployment::ImplementationRequirement>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::ImplementationRequirement, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::ImplementationRequirement>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__IMPLEMENTATIONREQUIREMENT_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::ImplementationRequirement>
    // MD5            : D1965C67B438F31951F64983B8082D9F
#if !defined(_ALIAS_D1965C67B438F31951F64983B8082D9F_TRAITS_DECL_)
#define _ALIAS_D1965C67B438F31951F64983B8082D9F_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::ImplementationRequirements>
      : IDL::common_traits< ::Deployment::ImplementationRequirements>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::ImplementationRequirement>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ImplementationRequirements>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ImplementationRequirements>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ImplementationRequirements, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ImplementationRequirements>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_DEPLOYMENT__CAPABILITY_TRAITS_)
#define _STRUCT_DEPLOYMENT__CAPABILITY_TRAITS_
    template<>
    struct traits < ::Deployment::Capability>
      : IDL::common_traits< ::Deployment::Capability>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Deployment::Capability, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Deployment::Capability>::__Writer<Fmt>);
#endif // _STRUCT_DEPLOYMENT__CAPABILITY_TRAITS_

    // generated from c++11/templates/cli/hdr/sequence_idl_traits
    // Unaliased type : std::vector< ::Deployment::Capability>
    // MD5            : 9AC75DD12DFFBAB4E6024AF2CB28F81D
#if !defined(_ALIAS_9AC75DD12DFFBAB4E6024AF2CB28F81D_TRAITS_DECL_)
#define _ALIAS_9AC75DD12DFFBAB4E6024AF2CB28F81D_TRAITS_DECL_

    template<>
    struct traits < ::Deployment::Capabilities>
      : IDL::common_traits< ::Deployment::Capabilities>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this sequence is declared as bounded
      using is_bounded = std::false_type;
      /// IDL::traits<> for the element of the sequence
      using element_traits = IDL::traits< ::Deployment::Capability>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Capabilities>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::Capabilities>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::Capabilities, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::Capabilities>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::Property, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::Property& val_)
      {
        os_ << "Deployment::Property"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",value=" << IDL::traits< TAOX11_NAMESPACE::CORBA::Any>::write(val_.value ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Property>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::Property>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::Property, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::Property>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::Requirement, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::Requirement& val_)
      {
        os_ << "Deployment::Requirement"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",resourceType=" << IDL::traits< std::string>::write(val_.resourceType ())
            << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Requirement>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::Requirement>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::Requirement, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::Requirement>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::SatisfierProperty, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::SatisfierProperty& val_)
      {
        os_ << "Deployment::SatisfierProperty"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",kind=" << IDL::traits< ::Deployment::SatisfierPropertyKind>::write(val_.kind ())
            << ",dynamic=" << IDL::traits< bool>::write(val_.dynamic ())
            << ",value=" << IDL::traits< TAOX11_NAMESPACE::CORBA::Any>::write(val_.value ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::SatisfierProperty>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::SatisfierProperty>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::SatisfierProperty, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::SatisfierProperty>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPortDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentPortDescription& val_)
      {
        os_ << "Deployment::ComponentPortDescription"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",specificType=" << IDL::traits< std::string>::write(val_.specificType ())
            << ",supportedType=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.supportedType ())
            << ",provider=" << IDL::traits< bool>::write(val_.provider ())
            << ",exclusiveProvider=" << IDL::traits< bool>::write(val_.exclusiveProvider ())
            << ",exclusiveUser=" << IDL::traits< bool>::write(val_.exclusiveUser ())
            << ",optional=" << IDL::traits< bool>::write(val_.optional ())
            << ",kind=" << IDL::traits< ::Deployment::CCMComponentPortKind>::write(val_.kind ())
            << ",templateParam=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.templateParam ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPortDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ComponentPortDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ComponentPortDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ComponentPortDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPropertyDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentPropertyDescription& val_)
      {
        os_ << "Deployment::ComponentPropertyDescription"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",type=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::write(val_.type ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPropertyDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ComponentPropertyDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ComponentPropertyDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ComponentPropertyDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentInterfaceDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentInterfaceDescription& val_)
      {
        os_ << "Deployment::ComponentInterfaceDescription"
            << '{'
            << "label=" << IDL::traits< std::string>::write(val_.label ())
            << ",UUID=" << IDL::traits< std::string>::write(val_.UUID ())
            << ",specificType=" << IDL::traits< std::string>::write(val_.specificType ())
            << ",supportedType=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.supportedType ())
            << ",idlFile=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.idlFile ())
            << ",configProperty=" << IDL::traits< ::Deployment::Properties>::write(val_.configProperty ())
            << ",port=" << IDL::traits< ::Deployment::ComponentPortDescriptions>::write(val_.port ())
            << ",property=" << IDL::traits< ::Deployment::ComponentPropertyDescriptions>::write(val_.property ())
            << ",infoProperty=" << IDL::traits< ::Deployment::Properties>::write(val_.infoProperty ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentInterfaceDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ComponentInterfaceDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ComponentInterfaceDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ComponentInterfaceDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::MonolithicDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::MonolithicDeploymentDescription& val_)
      {
        os_ << "Deployment::MonolithicDeploymentDescription"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
            << ",artifactRef=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::ULongSeq>::write(val_.artifactRef ())
            << ",execParameter=" << IDL::traits< ::Deployment::Properties>::write(val_.execParameter ())
            << ",deployRequirement=" << IDL::traits< ::Deployment::Requirements>::write(val_.deployRequirement ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::MonolithicDeploymentDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::MonolithicDeploymentDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::MonolithicDeploymentDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::MonolithicDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::InstanceResourceDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::InstanceResourceDeploymentDescription& val_)
      {
        os_ << "Deployment::InstanceResourceDeploymentDescription"
            << '{'
            << "resourceUsage=" << IDL::traits< ::Deployment::ResourceUsageKind>::write(val_.resourceUsage ())
            << ",requirementName=" << IDL::traits< std::string>::write(val_.requirementName ())
            << ",resourceName=" << IDL::traits< std::string>::write(val_.resourceName ())
            << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::InstanceResourceDeploymentDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::InstanceDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::InstanceDeploymentDescription& val_)
      {
        os_ << "Deployment::InstanceDeploymentDescription"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",node=" << IDL::traits< std::string>::write(val_.node ())
            << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
            << ",implementationRef=" << IDL::traits< uint32_t>::write(val_.implementationRef ())
            << ",configProperty=" << IDL::traits< ::Deployment::Properties>::write(val_.configProperty ())
            << ",deployedResource=" << IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::write(val_.deployedResource ())
            << ",deployedSharedResource=" << IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::write(val_.deployedSharedResource ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::InstanceDeploymentDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::InstanceDeploymentDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::InstanceDeploymentDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::InstanceDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentExternalPortEndpoint, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentExternalPortEndpoint& val_)
      {
        os_ << "Deployment::ComponentExternalPortEndpoint"
            << '{'
            << "portName=" << IDL::traits< std::string>::write(val_.portName ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ComponentExternalPortEndpoint, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanSubcomponentPortEndpoint, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanSubcomponentPortEndpoint& val_)
      {
        os_ << "Deployment::PlanSubcomponentPortEndpoint"
            << '{'
            << "portName=" << IDL::traits< std::string>::write(val_.portName ())
            << ",provider=" << IDL::traits< bool>::write(val_.provider ())
            << ",kind=" << IDL::traits< ::Deployment::CCMComponentPortKind>::write(val_.kind ())
            << ",instanceRef=" << IDL::traits< uint32_t>::write(val_.instanceRef ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanSubcomponentPortEndpoint, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ExternalReferenceEndpoint, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ExternalReferenceEndpoint& val_)
      {
        os_ << "Deployment::ExternalReferenceEndpoint"
            << '{'
            << "location=" << IDL::traits< std::string>::write(val_.location ())
            << ",provider=" << IDL::traits< bool>::write(val_.provider ())
            << ",portName=" << IDL::traits< std::string>::write(val_.portName ())
            << ",supportedType=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.supportedType ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ExternalReferenceEndpoint>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ExternalReferenceEndpoint>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ExternalReferenceEndpoint, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ExternalReferenceEndpoint>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ConnectionResourceDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ConnectionResourceDeploymentDescription& val_)
      {
        os_ << "Deployment::ConnectionResourceDeploymentDescription"
            << '{'
            << "targetName=" << IDL::traits< std::string>::write(val_.targetName ())
            << ",requirementName=" << IDL::traits< std::string>::write(val_.requirementName ())
            << ",resourceName=" << IDL::traits< std::string>::write(val_.resourceName ())
            << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ConnectionResourceDeploymentDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanConnectionDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanConnectionDescription& val_)
      {
        os_ << "Deployment::PlanConnectionDescription"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
            << ",deployRequirement=" << IDL::traits< ::Deployment::Requirements>::write(val_.deployRequirement ())
            << ",externalEndpoint=" << IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::write(val_.externalEndpoint ())
            << ",internalEndpoint=" << IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::write(val_.internalEndpoint ())
            << ",externalReference=" << IDL::traits< ::Deployment::ExternalReferenceEndpoints>::write(val_.externalReference ())
            << ",deployedResource=" << IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::write(val_.deployedResource ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanConnectionDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanConnectionDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanConnectionDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanConnectionDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanSubcomponentPropertyReference, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanSubcomponentPropertyReference& val_)
      {
        os_ << "Deployment::PlanSubcomponentPropertyReference"
            << '{'
            << "propertyName=" << IDL::traits< std::string>::write(val_.propertyName ())
            << ",instanceRef=" << IDL::traits< uint32_t>::write(val_.instanceRef ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanSubcomponentPropertyReference, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanPropertyMapping, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanPropertyMapping& val_)
      {
        os_ << "Deployment::PlanPropertyMapping"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
            << ",externalName=" << IDL::traits< std::string>::write(val_.externalName ())
            << ",delegatesTo=" << IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::write(val_.delegatesTo ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanPropertyMapping>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanPropertyMapping>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanPropertyMapping, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanPropertyMapping>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ImplementationDependency, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ImplementationDependency& val_)
      {
        os_ << "Deployment::ImplementationDependency"
            << '{'
            << "requiredType=" << IDL::traits< std::string>::write(val_.requiredType ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ImplementationDependency>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ImplementationDependency>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ImplementationDependency, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ImplementationDependency>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ResourceDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ResourceDeploymentDescription& val_)
      {
        os_ << "Deployment::ResourceDeploymentDescription"
            << '{'
            << "requirementName=" << IDL::traits< std::string>::write(val_.requirementName ())
            << ",resourceName=" << IDL::traits< std::string>::write(val_.resourceName ())
            << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ResourceDeploymentDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ResourceDeploymentDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ResourceDeploymentDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ResourceDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ArtifactDeploymentDescription, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ArtifactDeploymentDescription& val_)
      {
        os_ << "Deployment::ArtifactDeploymentDescription"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",location=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.location ())
            << ",node=" << IDL::traits< std::string>::write(val_.node ())
            << ",source=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.source ())
            << ",execParameter=" << IDL::traits< ::Deployment::Properties>::write(val_.execParameter ())
            << ",deployRequirement=" << IDL::traits< ::Deployment::Requirements>::write(val_.deployRequirement ())
            << ",deployedResource=" << IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::write(val_.deployedResource ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ArtifactDeploymentDescription>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ArtifactDeploymentDescription>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ArtifactDeploymentDescription, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ArtifactDeploymentDescription>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::PlanLocality, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::PlanLocality& val_)
      {
        os_ << "Deployment::PlanLocality"
            << '{'
            << "constraint=" << IDL::traits< ::Deployment::PlanLocalityKind>::write(val_.constraint ())
            << ",constrainedInstanceRef=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::ULongSeq>::write(val_.constrainedInstanceRef ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::PlanLocality>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::PlanLocality>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::PlanLocality, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::PlanLocality>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::DeploymentPlan, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::DeploymentPlan& val_)
      {
        os_ << "Deployment::DeploymentPlan"
            << '{'
            << "label=" << IDL::traits< std::string>::write(val_.label ())
            << ",UUID=" << IDL::traits< std::string>::write(val_.UUID ())
            << ",realizes=" << IDL::traits< ::Deployment::ComponentInterfaceDescription>::write(val_.realizes ())
            << ",implementation=" << IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::write(val_.implementation ())
            << ",instance=" << IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::write(val_.instance ())
            << ",connection=" << IDL::traits< ::Deployment::PlanConnectionDescriptions>::write(val_.connection ())
            << ",externalProperty=" << IDL::traits< ::Deployment::PlanPropertyMappings>::write(val_.externalProperty ())
            << ",dependsOn=" << IDL::traits< ::Deployment::ImplementationDependencies>::write(val_.dependsOn ())
            << ",artifact=" << IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::write(val_.artifact ())
            << ",infoProperty=" << IDL::traits< ::Deployment::Properties>::write(val_.infoProperty ())
            << ",localityConstraint=" << IDL::traits< ::Deployment::PlanLocalities>::write(val_.localityConstraint ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::DeploymentPlan>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::DeploymentPlan>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::DeploymentPlan, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::DeploymentPlan>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ComponentPackageReference, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ComponentPackageReference& val_)
      {
        os_ << "Deployment::ComponentPackageReference"
            << '{'
            << "requiredUUID=" << IDL::traits< std::string>::write(val_.requiredUUID ())
            << ",requiredName=" << IDL::traits< std::string>::write(val_.requiredName ())
            << ",requiredType=" << IDL::traits< ::Deployment::ComponentInterfaceDescription>::write(val_.requiredType ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ComponentPackageReference>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ComponentPackageReference>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ComponentPackageReference, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ComponentPackageReference>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::ImplementationRequirement, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::ImplementationRequirement& val_)
      {
        os_ << "Deployment::ImplementationRequirement"
            << '{'
            << "resourceUsage=" << IDL::traits< ::Deployment::ResourceUsageKinds>::write(val_.resourceUsage ())
            << ",resourcePort=" << IDL::traits< std::string>::write(val_.resourcePort ())
            << ",componentPort=" << IDL::traits< std::string>::write(val_.componentPort ())
            << ",name=" << IDL::traits< std::string>::write(val_.name ())
            << ",resourceType=" << IDL::traits< std::string>::write(val_.resourceType ())
            << ",property=" << IDL::traits< ::Deployment::Properties>::write(val_.property ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::ImplementationRequirement>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::ImplementationRequirement>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::ImplementationRequirement, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::ImplementationRequirement>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Deployment::Capability, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Deployment::Capability& val_)
      {
        os_ << "Deployment::Capability"
            << '{'
            << "name=" << IDL::traits< std::string>::write(val_.name ())
            << ",resourceType=" << IDL::traits< ::TAOX11_NAMESPACE::CORBA::StringSeq>::write(val_.resourceType ())
            << ",property=" << IDL::traits< ::Deployment::SatisfierProperties>::write(val_.property ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Deployment::Capability>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Deployment::Capability>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Deployment::Capability, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Deployment::Capability>::write_on (
          os, w.val_,
          formatter_t ());
    }
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::Property::Property (
  std::string name,
  TAOX11_NAMESPACE::CORBA::Any value)
  : name_ (std::move (name))
  , value_ (std::move (value))
{
}

inline void ::Deployment::Property::swap (::Deployment::Property& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->value_, s.value_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::Requirement::Requirement (
  std::string name,
  std::string resourceType,
  ::Deployment::Properties property)
  : name_ (std::move (name))
  , resourceType_ (std::move (resourceType))
  , property_ (std::move (property))
{
}

inline void ::Deployment::Requirement::swap (::Deployment::Requirement& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::SatisfierProperty::SatisfierProperty (
  std::string name,
  ::Deployment::SatisfierPropertyKind kind,
  bool dynamic,
  TAOX11_NAMESPACE::CORBA::Any value)
  : name_ (std::move (name))
  , kind_ (std::move (kind))
  , dynamic_ (std::move (dynamic))
  , value_ (std::move (value))
{
}

inline void ::Deployment::SatisfierProperty::swap (::Deployment::SatisfierProperty& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->dynamic_, s.dynamic_);
  std::swap (this->value_, s.value_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ComponentPortDescription::ComponentPortDescription (
  std::string name,
  std::string specificType,
  ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
  bool provider,
  bool exclusiveProvider,
  bool exclusiveUser,
  bool optional,
  CCMComponentPortKind kind,
  ::TAOX11_NAMESPACE::CORBA::StringSeq templateParam)
  : name_ (std::move (name))
  , specificType_ (std::move (specificType))
  , supportedType_ (std::move (supportedType))
  , provider_ (std::move (provider))
  , exclusiveProvider_ (std::move (exclusiveProvider))
  , exclusiveUser_ (std::move (exclusiveUser))
  , optional_ (std::move (optional))
  , kind_ (std::move (kind))
  , templateParam_ (std::move (templateParam))
{
}

inline void ::Deployment::ComponentPortDescription::swap (::Deployment::ComponentPortDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->specificType_, s.specificType_);
  std::swap (this->supportedType_, s.supportedType_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->exclusiveProvider_, s.exclusiveProvider_);
  std::swap (this->exclusiveUser_, s.exclusiveUser_);
  std::swap (this->optional_, s.optional_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->templateParam_, s.templateParam_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ComponentPropertyDescription::ComponentPropertyDescription (
  std::string name,
  IDL::traits< ::TAOX11_NAMESPACE::CORBA::TypeCode>::ref_type type)
  : name_ (std::move (name))
  , type_ (std::move (type))
{
}

inline void ::Deployment::ComponentPropertyDescription::swap (::Deployment::ComponentPropertyDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->type_, s.type_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ComponentInterfaceDescription::ComponentInterfaceDescription (
  std::string label,
  std::string UUID,
  std::string specificType,
  ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType,
  ::TAOX11_NAMESPACE::CORBA::StringSeq idlFile,
  ::Deployment::Properties configProperty,
  ::Deployment::ComponentPortDescriptions port,
  ::Deployment::ComponentPropertyDescriptions property,
  ::Deployment::Properties infoProperty)
  : label_ (std::move (label))
  , UUID_ (std::move (UUID))
  , specificType_ (std::move (specificType))
  , supportedType_ (std::move (supportedType))
  , idlFile_ (std::move (idlFile))
  , configProperty_ (std::move (configProperty))
  , port_ (std::move (port))
  , property_ (std::move (property))
  , infoProperty_ (std::move (infoProperty))
{
}

inline void ::Deployment::ComponentInterfaceDescription::swap (::Deployment::ComponentInterfaceDescription& s)
{
  std::swap (this->label_, s.label_);
  std::swap (this->UUID_, s.UUID_);
  std::swap (this->specificType_, s.specificType_);
  std::swap (this->supportedType_, s.supportedType_);
  std::swap (this->idlFile_, s.idlFile_);
  std::swap (this->configProperty_, s.configProperty_);
  std::swap (this->port_, s.port_);
  std::swap (this->property_, s.property_);
  std::swap (this->infoProperty_, s.infoProperty_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::MonolithicDeploymentDescription::MonolithicDeploymentDescription (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  ::TAOX11_NAMESPACE::CORBA::ULongSeq artifactRef,
  ::Deployment::Properties execParameter,
  ::Deployment::Requirements deployRequirement)
  : name_ (std::move (name))
  , source_ (std::move (source))
  , artifactRef_ (std::move (artifactRef))
  , execParameter_ (std::move (execParameter))
  , deployRequirement_ (std::move (deployRequirement))
{
}

inline void ::Deployment::MonolithicDeploymentDescription::swap (::Deployment::MonolithicDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->artifactRef_, s.artifactRef_);
  std::swap (this->execParameter_, s.execParameter_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription (
  ::Deployment::ResourceUsageKind resourceUsage,
  std::string requirementName,
  std::string resourceName,
  ::Deployment::Properties property)
  : resourceUsage_ (std::move (resourceUsage))
  , requirementName_ (std::move (requirementName))
  , resourceName_ (std::move (resourceName))
  , property_ (std::move (property))
{
}

inline void ::Deployment::InstanceResourceDeploymentDescription::swap (::Deployment::InstanceResourceDeploymentDescription& s)
{
  std::swap (this->resourceUsage_, s.resourceUsage_);
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::InstanceDeploymentDescription::InstanceDeploymentDescription (
  std::string name,
  std::string node,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  uint32_t implementationRef,
  ::Deployment::Properties configProperty,
  ::Deployment::InstanceResourceDeploymentDescriptions deployedResource,
  ::Deployment::InstanceResourceDeploymentDescriptions deployedSharedResource)
  : name_ (std::move (name))
  , node_ (std::move (node))
  , source_ (std::move (source))
  , implementationRef_ (std::move (implementationRef))
  , configProperty_ (std::move (configProperty))
  , deployedResource_ (std::move (deployedResource))
  , deployedSharedResource_ (std::move (deployedSharedResource))
{
}

inline void ::Deployment::InstanceDeploymentDescription::swap (::Deployment::InstanceDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->node_, s.node_);
  std::swap (this->source_, s.source_);
  std::swap (this->implementationRef_, s.implementationRef_);
  std::swap (this->configProperty_, s.configProperty_);
  std::swap (this->deployedResource_, s.deployedResource_);
  std::swap (this->deployedSharedResource_, s.deployedSharedResource_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ComponentExternalPortEndpoint::ComponentExternalPortEndpoint (
  std::string portName)
  : portName_ (std::move (portName))
{
}

inline void ::Deployment::ComponentExternalPortEndpoint::swap (::Deployment::ComponentExternalPortEndpoint& s)
{
  std::swap (this->portName_, s.portName_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint (
  std::string portName,
  bool provider,
  ::Deployment::CCMComponentPortKind kind,
  uint32_t instanceRef)
  : portName_ (std::move (portName))
  , provider_ (std::move (provider))
  , kind_ (std::move (kind))
  , instanceRef_ (std::move (instanceRef))
{
}

inline void ::Deployment::PlanSubcomponentPortEndpoint::swap (::Deployment::PlanSubcomponentPortEndpoint& s)
{
  std::swap (this->portName_, s.portName_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->kind_, s.kind_);
  std::swap (this->instanceRef_, s.instanceRef_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ExternalReferenceEndpoint::ExternalReferenceEndpoint (
  std::string location,
  bool provider,
  std::string portName,
  ::TAOX11_NAMESPACE::CORBA::StringSeq supportedType)
  : location_ (std::move (location))
  , provider_ (std::move (provider))
  , portName_ (std::move (portName))
  , supportedType_ (std::move (supportedType))
{
}

inline void ::Deployment::ExternalReferenceEndpoint::swap (::Deployment::ExternalReferenceEndpoint& s)
{
  std::swap (this->location_, s.location_);
  std::swap (this->provider_, s.provider_);
  std::swap (this->portName_, s.portName_);
  std::swap (this->supportedType_, s.supportedType_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription (
  std::string targetName,
  std::string requirementName,
  std::string resourceName,
  ::Deployment::Properties property)
  : targetName_ (std::move (targetName))
  , requirementName_ (std::move (requirementName))
  , resourceName_ (std::move (resourceName))
  , property_ (std::move (property))
{
}

inline void ::Deployment::ConnectionResourceDeploymentDescription::swap (::Deployment::ConnectionResourceDeploymentDescription& s)
{
  std::swap (this->targetName_, s.targetName_);
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::PlanConnectionDescription::PlanConnectionDescription (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  ::Deployment::Requirements deployRequirement,
  ::Deployment::ComponentExternalPortEndpoints externalEndpoint,
  ::Deployment::PlanSubcomponentPortEndpoints internalEndpoint,
  ::Deployment::ExternalReferenceEndpoints externalReference,
  ::Deployment::ConnectionResourceDeploymentDescriptions deployedResource)
  : name_ (std::move (name))
  , source_ (std::move (source))
  , deployRequirement_ (std::move (deployRequirement))
  , externalEndpoint_ (std::move (externalEndpoint))
  , internalEndpoint_ (std::move (internalEndpoint))
  , externalReference_ (std::move (externalReference))
  , deployedResource_ (std::move (deployedResource))
{
}

inline void ::Deployment::PlanConnectionDescription::swap (::Deployment::PlanConnectionDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
  std::swap (this->externalEndpoint_, s.externalEndpoint_);
  std::swap (this->internalEndpoint_, s.internalEndpoint_);
  std::swap (this->externalReference_, s.externalReference_);
  std::swap (this->deployedResource_, s.deployedResource_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::PlanSubcomponentPropertyReference::PlanSubcomponentPropertyReference (
  std::string propertyName,
  uint32_t instanceRef)
  : propertyName_ (std::move (propertyName))
  , instanceRef_ (std::move (instanceRef))
{
}

inline void ::Deployment::PlanSubcomponentPropertyReference::swap (::Deployment::PlanSubcomponentPropertyReference& s)
{
  std::swap (this->propertyName_, s.propertyName_);
  std::swap (this->instanceRef_, s.instanceRef_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::PlanPropertyMapping::PlanPropertyMapping (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  std::string externalName,
  ::Deployment::PlanSubcomponentPropertyReferences delegatesTo)
  : name_ (std::move (name))
  , source_ (std::move (source))
  , externalName_ (std::move (externalName))
  , delegatesTo_ (std::move (delegatesTo))
{
}

inline void ::Deployment::PlanPropertyMapping::swap (::Deployment::PlanPropertyMapping& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->source_, s.source_);
  std::swap (this->externalName_, s.externalName_);
  std::swap (this->delegatesTo_, s.delegatesTo_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ImplementationDependency::ImplementationDependency (
  std::string requiredType)
  : requiredType_ (std::move (requiredType))
{
}

inline void ::Deployment::ImplementationDependency::swap (::Deployment::ImplementationDependency& s)
{
  std::swap (this->requiredType_, s.requiredType_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ResourceDeploymentDescription::ResourceDeploymentDescription (
  std::string requirementName,
  std::string resourceName,
  ::Deployment::Properties property)
  : requirementName_ (std::move (requirementName))
  , resourceName_ (std::move (resourceName))
  , property_ (std::move (property))
{
}

inline void ::Deployment::ResourceDeploymentDescription::swap (::Deployment::ResourceDeploymentDescription& s)
{
  std::swap (this->requirementName_, s.requirementName_);
  std::swap (this->resourceName_, s.resourceName_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ArtifactDeploymentDescription::ArtifactDeploymentDescription (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq location,
  std::string node,
  ::TAOX11_NAMESPACE::CORBA::StringSeq source,
  ::Deployment::Properties execParameter,
  ::Deployment::Requirements deployRequirement,
  ::Deployment::ResourceDeploymentDescriptions deployedResource)
  : name_ (std::move (name))
  , location_ (std::move (location))
  , node_ (std::move (node))
  , source_ (std::move (source))
  , execParameter_ (std::move (execParameter))
  , deployRequirement_ (std::move (deployRequirement))
  , deployedResource_ (std::move (deployedResource))
{
}

inline void ::Deployment::ArtifactDeploymentDescription::swap (::Deployment::ArtifactDeploymentDescription& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->location_, s.location_);
  std::swap (this->node_, s.node_);
  std::swap (this->source_, s.source_);
  std::swap (this->execParameter_, s.execParameter_);
  std::swap (this->deployRequirement_, s.deployRequirement_);
  std::swap (this->deployedResource_, s.deployedResource_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::PlanLocality::PlanLocality (
  ::Deployment::PlanLocalityKind constraint,
  ::TAOX11_NAMESPACE::CORBA::ULongSeq constrainedInstanceRef)
  : constraint_ (std::move (constraint))
  , constrainedInstanceRef_ (std::move (constrainedInstanceRef))
{
}

inline void ::Deployment::PlanLocality::swap (::Deployment::PlanLocality& s)
{
  std::swap (this->constraint_, s.constraint_);
  std::swap (this->constrainedInstanceRef_, s.constrainedInstanceRef_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::DeploymentPlan::DeploymentPlan (
  std::string label,
  std::string UUID,
  ::Deployment::ComponentInterfaceDescription realizes,
  ::Deployment::MonolithicDeploymentDescriptions implementation,
  ::Deployment::InstanceDeploymentDescriptions instance,
  ::Deployment::PlanConnectionDescriptions connection,
  ::Deployment::PlanPropertyMappings externalProperty,
  ::Deployment::ImplementationDependencies dependsOn,
  ::Deployment::ArtifactDeploymentDescriptions artifact,
  ::Deployment::Properties infoProperty,
  ::Deployment::PlanLocalities localityConstraint)
  : label_ (std::move (label))
  , UUID_ (std::move (UUID))
  , realizes_ (std::move (realizes))
  , implementation_ (std::move (implementation))
  , instance_ (std::move (instance))
  , connection_ (std::move (connection))
  , externalProperty_ (std::move (externalProperty))
  , dependsOn_ (std::move (dependsOn))
  , artifact_ (std::move (artifact))
  , infoProperty_ (std::move (infoProperty))
  , localityConstraint_ (std::move (localityConstraint))
{
}

inline void ::Deployment::DeploymentPlan::swap (::Deployment::DeploymentPlan& s)
{
  std::swap (this->label_, s.label_);
  std::swap (this->UUID_, s.UUID_);
  std::swap (this->realizes_, s.realizes_);
  std::swap (this->implementation_, s.implementation_);
  std::swap (this->instance_, s.instance_);
  std::swap (this->connection_, s.connection_);
  std::swap (this->externalProperty_, s.externalProperty_);
  std::swap (this->dependsOn_, s.dependsOn_);
  std::swap (this->artifact_, s.artifact_);
  std::swap (this->infoProperty_, s.infoProperty_);
  std::swap (this->localityConstraint_, s.localityConstraint_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ComponentPackageReference::ComponentPackageReference (
  std::string requiredUUID,
  std::string requiredName,
  ::Deployment::ComponentInterfaceDescription requiredType)
  : requiredUUID_ (std::move (requiredUUID))
  , requiredName_ (std::move (requiredName))
  , requiredType_ (std::move (requiredType))
{
}

inline void ::Deployment::ComponentPackageReference::swap (::Deployment::ComponentPackageReference& s)
{
  std::swap (this->requiredUUID_, s.requiredUUID_);
  std::swap (this->requiredName_, s.requiredName_);
  std::swap (this->requiredType_, s.requiredType_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::ImplementationRequirement::ImplementationRequirement (
  ::Deployment::ResourceUsageKinds resourceUsage,
  std::string resourcePort,
  std::string componentPort,
  std::string name,
  std::string resourceType,
  ::Deployment::Properties property)
  : resourceUsage_ (std::move (resourceUsage))
  , resourcePort_ (std::move (resourcePort))
  , componentPort_ (std::move (componentPort))
  , name_ (std::move (name))
  , resourceType_ (std::move (resourceType))
  , property_ (std::move (property))
{
}

inline void ::Deployment::ImplementationRequirement::swap (::Deployment::ImplementationRequirement& s)
{
  std::swap (this->resourceUsage_, s.resourceUsage_);
  std::swap (this->resourcePort_, s.resourcePort_);
  std::swap (this->componentPort_, s.componentPort_);
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Deployment::Capability::Capability (
  std::string name,
  ::TAOX11_NAMESPACE::CORBA::StringSeq resourceType,
  ::Deployment::SatisfierProperties property)
  : name_ (std::move (name))
  , resourceType_ (std::move (resourceType))
  , property_ (std::move (property))
{
}

inline void ::Deployment::Capability::swap (::Deployment::Capability& s)
{
  std::swap (this->name_, s.name_);
  std::swap (this->resourceType_, s.resourceType_);
  std::swap (this->property_, s.property_);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::Property& _v)
{
  return IDL::traits< ::Deployment::Property>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::Property>
// MD5            : D7395FCE530B622658DD71B872EFFEFC
#if !defined (_ALIAS_OSTREAM_D7395FCE530B622658DD71B872EFFEFC_DECL_)
#define _ALIAS_OSTREAM_D7395FCE530B622658DD71B872EFFEFC_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::Properties& _v)
{
  return IDL::traits< ::Deployment::Properties>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_D7395FCE530B622658DD71B872EFFEFC_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::Requirement& _v)
{
  return IDL::traits< ::Deployment::Requirement>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::Requirement>
// MD5            : 3265D777E1B663C0C3E8129C9FA7A92F
#if !defined (_ALIAS_OSTREAM_3265D777E1B663C0C3E8129C9FA7A92F_DECL_)
#define _ALIAS_OSTREAM_3265D777E1B663C0C3E8129C9FA7A92F_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::Requirements& _v)
{
  return IDL::traits< ::Deployment::Requirements>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_3265D777E1B663C0C3E8129C9FA7A92F_DECL_

// generated from c++11/templates/cli/hdr/enum_os
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::SatisfierPropertyKind _v)
{
  return IDL::traits< ::Deployment::SatisfierPropertyKind>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::SatisfierProperty& _v)
{
  return IDL::traits< ::Deployment::SatisfierProperty>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::SatisfierProperty>
// MD5            : EB80218682E63B0775FD6299B3051E6D
#if !defined (_ALIAS_OSTREAM_EB80218682E63B0775FD6299B3051E6D_DECL_)
#define _ALIAS_OSTREAM_EB80218682E63B0775FD6299B3051E6D_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::SatisfierProperties& _v)
{
  return IDL::traits< ::Deployment::SatisfierProperties>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_EB80218682E63B0775FD6299B3051E6D_DECL_

// generated from c++11/templates/cli/hdr/enum_os
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::CCMComponentPortKind _v)
{
  return IDL::traits< ::Deployment::CCMComponentPortKind>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPortDescription& _v)
{
  return IDL::traits< ::Deployment::ComponentPortDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ComponentPortDescription>
// MD5            : 12954963972B5124A7A21E0C4327729B
#if !defined (_ALIAS_OSTREAM_12954963972B5124A7A21E0C4327729B_DECL_)
#define _ALIAS_OSTREAM_12954963972B5124A7A21E0C4327729B_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPortDescriptions& _v)
{
  return IDL::traits< ::Deployment::ComponentPortDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_12954963972B5124A7A21E0C4327729B_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPropertyDescription& _v)
{
  return IDL::traits< ::Deployment::ComponentPropertyDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ComponentPropertyDescription>
// MD5            : 920E8F149D82D841A00A08FE0557725B
#if !defined (_ALIAS_OSTREAM_920E8F149D82D841A00A08FE0557725B_DECL_)
#define _ALIAS_OSTREAM_920E8F149D82D841A00A08FE0557725B_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPropertyDescriptions& _v)
{
  return IDL::traits< ::Deployment::ComponentPropertyDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_920E8F149D82D841A00A08FE0557725B_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentInterfaceDescription& _v)
{
  return IDL::traits< ::Deployment::ComponentInterfaceDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::MonolithicDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::MonolithicDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::MonolithicDeploymentDescription>
// MD5            : 8CA1C515FCEF8C84C8A8AC3BF21E75A1
#if !defined (_ALIAS_OSTREAM_8CA1C515FCEF8C84C8A8AC3BF21E75A1_DECL_)
#define _ALIAS_OSTREAM_8CA1C515FCEF8C84C8A8AC3BF21E75A1_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::MonolithicDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::MonolithicDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_8CA1C515FCEF8C84C8A8AC3BF21E75A1_DECL_

// generated from c++11/templates/cli/hdr/enum_os
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::ResourceUsageKind _v)
{
  return IDL::traits< ::Deployment::ResourceUsageKind>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceResourceDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::InstanceResourceDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::InstanceResourceDeploymentDescription>
// MD5            : 7DA1C006DFD4ED780225B6DDB077F883
#if !defined (_ALIAS_OSTREAM_7DA1C006DFD4ED780225B6DDB077F883_DECL_)
#define _ALIAS_OSTREAM_7DA1C006DFD4ED780225B6DDB077F883_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceResourceDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::InstanceResourceDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_7DA1C006DFD4ED780225B6DDB077F883_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::InstanceDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::InstanceDeploymentDescription>
// MD5            : 8B4B636BAEF9B16F13A7BA16B787ADEA
#if !defined (_ALIAS_OSTREAM_8B4B636BAEF9B16F13A7BA16B787ADEA_DECL_)
#define _ALIAS_OSTREAM_8B4B636BAEF9B16F13A7BA16B787ADEA_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::InstanceDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::InstanceDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_8B4B636BAEF9B16F13A7BA16B787ADEA_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentExternalPortEndpoint& _v)
{
  return IDL::traits< ::Deployment::ComponentExternalPortEndpoint>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ComponentExternalPortEndpoint>
// MD5            : 0079E24B070B963BAFE84A5B71BC7698
#if !defined (_ALIAS_OSTREAM_0079E24B070B963BAFE84A5B71BC7698_DECL_)
#define _ALIAS_OSTREAM_0079E24B070B963BAFE84A5B71BC7698_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentExternalPortEndpoints& _v)
{
  return IDL::traits< ::Deployment::ComponentExternalPortEndpoints>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_0079E24B070B963BAFE84A5B71BC7698_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPortEndpoint& _v)
{
  return IDL::traits< ::Deployment::PlanSubcomponentPortEndpoint>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::PlanSubcomponentPortEndpoint>
// MD5            : 1CC072AD6279ECB8F540C3C10DB1F767
#if !defined (_ALIAS_OSTREAM_1CC072AD6279ECB8F540C3C10DB1F767_DECL_)
#define _ALIAS_OSTREAM_1CC072AD6279ECB8F540C3C10DB1F767_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPortEndpoints& _v)
{
  return IDL::traits< ::Deployment::PlanSubcomponentPortEndpoints>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_1CC072AD6279ECB8F540C3C10DB1F767_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ExternalReferenceEndpoint& _v)
{
  return IDL::traits< ::Deployment::ExternalReferenceEndpoint>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ExternalReferenceEndpoint>
// MD5            : 2E044427492F5861B730283A565D1ED5
#if !defined (_ALIAS_OSTREAM_2E044427492F5861B730283A565D1ED5_DECL_)
#define _ALIAS_OSTREAM_2E044427492F5861B730283A565D1ED5_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ExternalReferenceEndpoints& _v)
{
  return IDL::traits< ::Deployment::ExternalReferenceEndpoints>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_2E044427492F5861B730283A565D1ED5_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ConnectionResourceDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::ConnectionResourceDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ConnectionResourceDeploymentDescription>
// MD5            : 4CE006491F749EF87F69C9F0666BD518
#if !defined (_ALIAS_OSTREAM_4CE006491F749EF87F69C9F0666BD518_DECL_)
#define _ALIAS_OSTREAM_4CE006491F749EF87F69C9F0666BD518_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ConnectionResourceDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::ConnectionResourceDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_4CE006491F749EF87F69C9F0666BD518_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanConnectionDescription& _v)
{
  return IDL::traits< ::Deployment::PlanConnectionDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::PlanConnectionDescription>
// MD5            : 0864BEE17C4222FE18C6B2C68197901B
#if !defined (_ALIAS_OSTREAM_0864BEE17C4222FE18C6B2C68197901B_DECL_)
#define _ALIAS_OSTREAM_0864BEE17C4222FE18C6B2C68197901B_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanConnectionDescriptions& _v)
{
  return IDL::traits< ::Deployment::PlanConnectionDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_0864BEE17C4222FE18C6B2C68197901B_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPropertyReference& _v)
{
  return IDL::traits< ::Deployment::PlanSubcomponentPropertyReference>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::PlanSubcomponentPropertyReference>
// MD5            : E50992F1F837050D6477978B56863FBD
#if !defined (_ALIAS_OSTREAM_E50992F1F837050D6477978B56863FBD_DECL_)
#define _ALIAS_OSTREAM_E50992F1F837050D6477978B56863FBD_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanSubcomponentPropertyReferences& _v)
{
  return IDL::traits< ::Deployment::PlanSubcomponentPropertyReferences>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_E50992F1F837050D6477978B56863FBD_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanPropertyMapping& _v)
{
  return IDL::traits< ::Deployment::PlanPropertyMapping>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::PlanPropertyMapping>
// MD5            : 0422E458499BDB48508CAB373414C33F
#if !defined (_ALIAS_OSTREAM_0422E458499BDB48508CAB373414C33F_DECL_)
#define _ALIAS_OSTREAM_0422E458499BDB48508CAB373414C33F_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanPropertyMappings& _v)
{
  return IDL::traits< ::Deployment::PlanPropertyMappings>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_0422E458499BDB48508CAB373414C33F_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationDependency& _v)
{
  return IDL::traits< ::Deployment::ImplementationDependency>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ImplementationDependency>
// MD5            : 2C17710E0A7BA82C42ACC676758DBF1C
#if !defined (_ALIAS_OSTREAM_2C17710E0A7BA82C42ACC676758DBF1C_DECL_)
#define _ALIAS_OSTREAM_2C17710E0A7BA82C42ACC676758DBF1C_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationDependencies& _v)
{
  return IDL::traits< ::Deployment::ImplementationDependencies>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_2C17710E0A7BA82C42ACC676758DBF1C_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ResourceDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::ResourceDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ResourceDeploymentDescription>
// MD5            : 77F1484D7BC4A6841660C8A62AFD38E7
#if !defined (_ALIAS_OSTREAM_77F1484D7BC4A6841660C8A62AFD38E7_DECL_)
#define _ALIAS_OSTREAM_77F1484D7BC4A6841660C8A62AFD38E7_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ResourceDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::ResourceDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_77F1484D7BC4A6841660C8A62AFD38E7_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ArtifactDeploymentDescription& _v)
{
  return IDL::traits< ::Deployment::ArtifactDeploymentDescription>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ArtifactDeploymentDescription>
// MD5            : 4B78A2395FEFF04B7A71CAF425D7AAB0
#if !defined (_ALIAS_OSTREAM_4B78A2395FEFF04B7A71CAF425D7AAB0_DECL_)
#define _ALIAS_OSTREAM_4B78A2395FEFF04B7A71CAF425D7AAB0_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ArtifactDeploymentDescriptions& _v)
{
  return IDL::traits< ::Deployment::ArtifactDeploymentDescriptions>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_4B78A2395FEFF04B7A71CAF425D7AAB0_DECL_

// generated from c++11/templates/cli/hdr/enum_os
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Deployment::PlanLocalityKind _v)
{
  return IDL::traits< ::Deployment::PlanLocalityKind>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::PlanLocality& _v)
{
  return IDL::traits< ::Deployment::PlanLocality>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::PlanLocality>
// MD5            : 7639FB88384E3E335A056DB5284179B1
#if !defined (_ALIAS_OSTREAM_7639FB88384E3E335A056DB5284179B1_DECL_)
#define _ALIAS_OSTREAM_7639FB88384E3E335A056DB5284179B1_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::PlanLocalities& _v)
{
  return IDL::traits< ::Deployment::PlanLocalities>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_7639FB88384E3E335A056DB5284179B1_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::DeploymentPlan& _v)
{
  return IDL::traits< ::Deployment::DeploymentPlan>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPackageReference& _v)
{
  return IDL::traits< ::Deployment::ComponentPackageReference>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ComponentPackageReference>
// MD5            : D5775520607EF1551FF61D9245FFC376
#if !defined (_ALIAS_OSTREAM_D5775520607EF1551FF61D9245FFC376_DECL_)
#define _ALIAS_OSTREAM_D5775520607EF1551FF61D9245FFC376_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ComponentPackageReferences& _v)
{
  return IDL::traits< ::Deployment::ComponentPackageReferences>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_D5775520607EF1551FF61D9245FFC376_DECL_

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ResourceUsageKind>
// MD5            : 90F1BEC8CBCE4D84EC85294F6CFABECA
#if !defined (_ALIAS_OSTREAM_90F1BEC8CBCE4D84EC85294F6CFABECA_DECL_)
#define _ALIAS_OSTREAM_90F1BEC8CBCE4D84EC85294F6CFABECA_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ResourceUsageKinds& _v)
{
  return IDL::traits< ::Deployment::ResourceUsageKinds>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_90F1BEC8CBCE4D84EC85294F6CFABECA_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationRequirement& _v)
{
  return IDL::traits< ::Deployment::ImplementationRequirement>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::ImplementationRequirement>
// MD5            : D1965C67B438F31951F64983B8082D9F
#if !defined (_ALIAS_OSTREAM_D1965C67B438F31951F64983B8082D9F_DECL_)
#define _ALIAS_OSTREAM_D1965C67B438F31951F64983B8082D9F_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::ImplementationRequirements& _v)
{
  return IDL::traits< ::Deployment::ImplementationRequirements>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_D1965C67B438F31951F64983B8082D9F_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Deployment::Capability& _v)
{
  return IDL::traits< ::Deployment::Capability>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/sequence_os
// Unaliased type : std::vector< ::Deployment::Capability>
// MD5            : 9AC75DD12DFFBAB4E6024AF2CB28F81D
#if !defined (_ALIAS_OSTREAM_9AC75DD12DFFBAB4E6024AF2CB28F81D_DECL_)
#define _ALIAS_OSTREAM_9AC75DD12DFFBAB4E6024AF2CB28F81D_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Deployment::Capabilities& _v)
{
  return IDL::traits< ::Deployment::Capabilities>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_9AC75DD12DFFBAB4E6024AF2CB28F81D_DECL_

// generated from c++11/templates/cli/hdr/post
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testCP.h"
#endif

#include /**/ "ace/post.h"

#endif /* __RIDL_TESTC_H_DFFBAEHG_INCLUDED__ */

// -*- END -*-
