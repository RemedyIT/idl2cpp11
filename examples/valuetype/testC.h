/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_TESTC_H_FJIDCAEA_INCLUDED__
#define __RIDL_TESTC_H_FJIDCAEA_INCLUDED__

#pragma once

#include /**/ "ace/pre.h"
#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/object.h"
#include "tao/x11/corba_ostream.h"
#include "tao/x11/anytypecode/typecode.h"
#include "tao/x11/valuetype/value_base.h"
#include "tao/x11/valuetype/value_factory_base.h"
#include "tao/x11/valuetype/value_box_t.h"

#include /**/ "tao/x11/versionx11.h"

#if TAOX11_MAJOR_VERSION != 1 || TAOX11_MINOR_VERSION != 8 || TAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (1.8.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from c++11/templates/cli/hdr/valuetype_fwd
#if !defined (_VALUETYPE_EXAMPLE_FWD_)
#define _VALUETYPE_EXAMPLE_FWD_

class Example;
namespace obv
{
  class Example;
} // namespace obv

#endif // !_VALUETYPE_EXAMPLE_FWD_

// generated from c++11/templates/cli/hdr/valuetype_traits
#if !defined (_VALUETYPE_EXAMPLE_TRAITS_DECL_)
#define _VALUETYPE_EXAMPLE_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template <>
    struct valuetype_traits< ::Example>
    {
      using base_type = ::Example;
      /// Strong reference type
      using ref_type = valuetype_reference< ::Example>;
      /// Weak reference type
      using weak_ref_type = weak_valuetype_reference< ::Example>;
      using obv_type = ::obv::Example;
      using factory_type = CORBA::ValueFactoryBase;
      using factory_ref_type = IDL::traits<CORBA::ValueFactoryBase>::ref_type;
      using weak_factory_ref_type = IDL::traits<CORBA::ValueFactoryBase>::weak_ref_type;
      template <typename _Tp1, typename = typename
          std::enable_if<std::is_convertible< ::Example*, _Tp1*>::value>::type>
      static ref_type narrow (valuetype_reference<_Tp1> base)
      {
        return ref_type::_narrow (std::move(base));
      }
    };
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::Example>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::Example>>,
        public CORBA::valuetype_traits < ::Example>
    {
      using is_abstract = std::false_type;
      using is_truncatable = std::false_type;

      template <typename OStrm_, typename Formatter = formatter< ::Example, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_VALUETYPE_EXAMPLE_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuetype_pre
class Example
  : public virtual TAOX11_CORBA::ValueBase
{
public:
  /// @name Member types
  //@{
  using _traits_type = TAOX11_IDL::traits<Example>;
  /// Strong reference type
  using _ref_type = TAOX11_IDL::traits<Example>::ref_type;
  using _obv_type = TAOX11_IDL::traits<Example>::obv_type;
  //@}

  static bool _obv_unmarshal (TAO_InputCDR &strm, _ref_type &vbox);


protected:
  using _shared_ptr_type = std::shared_ptr<Example>;

  static const std::string __example_repository_id;

  Example () = default;
  virtual ~Example () = default;
  Example (const Example&) = default;
  Example (Example&&) = default;
  Example& operator= (const Example&) = delete;
  Example& operator= (Example&&) = delete;

  const std::string& _obv_repository_id () const override;
  void _obv_get_truncatable_repo_ids (std::vector<std::string const*>&) const override;

  bool _obv_match_formal_type (ptrdiff_t ) const override;

  bool _obv_marshal_v (TAO_OutputCDR &) const override;
  bool _obv_unmarshal_v (TAO_InputCDR &) override;
public:

  // generated from c++11/templates/cli/hdr/valuetype_post
public:
  static inline const std::string& _repository_id ()
  {
    return __example_repository_id;
  }

  // Operations

  // generated from c++11/templates/cli/hdr/operation
  /// @copydoc test.idl::Example::op1
  virtual int16_t
  op1 () = 0;

  // generated from c++11/templates/cli/hdr/operation
  /// @copydoc test.idl::Example::op2
  virtual int32_t
  op2 (
      IDL::traits< Example>::ref_type x) = 0;

  /// @name Public state members
  //@{
  virtual void val2 (int32_t _x11_val2) = 0;
  virtual int32_t val2 () const = 0;
  virtual int32_t& val2 () = 0;
  //@}

protected:
  /// @name Private state members
  //@{
  virtual void val1 (int16_t _x11_val1) = 0;
  virtual int16_t val1 () const = 0;
  virtual int16_t& val1 () = 0;
  virtual void val3 (const std::string& _x11_val3) = 0;
  virtual void val3 (std::string&& _x11_val3) = 0;
  virtual const std::string& val3 () const = 0;
  virtual std::string& val3 () = 0;
  virtual void val5 (IDL::traits< Example>::ref_type _x11_val5) = 0;
  virtual IDL::traits< Example>::ref_type val5 () const = 0;
  virtual IDL::traits< Example>::ref_type& val5 () = 0;
  //@}

protected:
  virtual bool
  _obv_marshal_Example_v (TAO_OutputCDR &, TAO_ChunkInfo &) const = 0;

  virtual bool
  _obv_unmarshal_Example_v (TAO_InputCDR &, TAO_ChunkInfo &) = 0;
}; // class Example

// generated from c++11/templates/cli/hdr/valuetype_obv
namespace obv
{
  class Example
    : public virtual ::Example
  {
  protected:
#if defined (_MSC_VER) && (_MSC_VER < 1920)
    // msvc14.(0|1) have a problem with defaulted constructors, issue #4005
    Example () {}
#else
    Example () = default;
#endif /* _MSC_VER < 1920 */
    virtual ~Example () = default;
    Example (const Example&) = default;
    Example (Example&&) = default;
    explicit Example (
      int16_t val1,
      int32_t val2,
      std::string val3,
      IDL::traits< ::Example>::ref_type val5)
      : val1_ (std::move (val1))
      , val2_ (std::move (val2))
      , val3_ (std::move (val3))
      , val5_ (std::move (val5))
    {}

  private:
    Example& operator= (const Example&) = delete;
    Example& operator= (Example&&) = delete;

  public:
    /// @name Public state members
    //@{
    void val2 (int32_t _x11_val2) override;
    int32_t val2 () const override;
    int32_t& val2 () override;

    //@}
  protected:
    /// Private state members
    void val1 (int16_t _x11_val1) override;
    int16_t val1 () const override;
    int16_t& val1 () override;

    void val3 (const std::string& _x11_val3) override;
    void val3 (std::string&& _x11_val3) override;
    const std::string& val3 () const override;
    std::string& val3 () override;

    void val5 (IDL::traits< ::Example>::ref_type _x11_val5) override;
    IDL::traits< ::Example>::ref_type val5 () const override;
    IDL::traits< ::Example>::ref_type& val5 () override;

    /// Marshaling support
    bool _obv_marshal_Example_v (TAO_OutputCDR &, TAO_ChunkInfo &) const override;

    /// Demarshaling support
    bool _obv_unmarshal_Example_v (TAO_InputCDR &, TAO_ChunkInfo &) override;

    bool _obv_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const;
    bool _obv_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &);

  private:
    int16_t val1_ {};
    int32_t val2_ {};
    std::string val3_;
    IDL::traits< ::Example>::ref_type val5_;
  }; // class Example
} // namespace obv

// generated from c++11/templates/cli/hdr/typedef
/// @copydoc test.idl::Bytes
using Bytes = std::array< uint8_t, 64>;

// generated from c++11/templates/cli/hdr/struct_pre

/// @copydoc test.idl::S
class S
{
public:

  // generated from c++11/templates/cli/hdr/struct_post
  /// Default constructor
  S () = default;
  /// Destructor
  ~S () = default;
  /// Copy constructor
  S (const S&) = default;
  /// Move constructor
  S (S&&) = default;
  /// Constructor which accepts value for all members
  explicit inline S (
    int32_t value);
  /// Copy assignment operator
  S& operator= (const S&) = default;
  /// Move assignment operator
  S& operator= (S&&) = default;

  /// @copydoc test.idl::S::value
  //@{
  inline void value (int32_t _x11_value) { this->value_ = _x11_value; }
  inline int32_t value () const { return this->value_; }
  inline int32_t& value () { return this->value_; }
  //@}

  /// Exchange the value of two structs in an efficient matter
  inline void swap (S& s);

private:
  int32_t value_ {};
};// S

inline void swap (::S& m1, ::S& m2) { m1.swap (m2); }


// generated from StubHeaderWriter#enter_interface

// generated from c++11/templates/cli/hdr/interface_fwd
#if !defined (_INTF_A_FWD_)
#define _INTF_A_FWD_
class A;
class A_proxy;
using A_proxy_ptr = A_proxy*;
#endif // !_INTF_A_FWD_

// generated from c++11/templates/cli/hdr/interface_object_traits
#if !defined (_INTF_A_TRAITS_DECL_)
#define _INTF_A_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits< ::A>::shared_ptr_type
    object_traits< ::A>::lock_shared (
        ::A* p);
    template<>
    object_traits< ::A>::ref_type
    object_traits< ::A>::narrow (
       object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::A> :
      public IDL::common_byval_traits <CORBA::object_reference < ::A>>,
      public CORBA::object_traits < ::A>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      using is_local = std::false_type;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      using is_abstract = std::false_type;

      template <typename OStrm_, typename Formatter = formatter< ::A, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_A_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/interface_pre
/// @copydoc test.idl::A
class A
  : public virtual TAOX11_NAMESPACE::CORBA::Object
{
public:
  template <typename T> friend struct TAOX11_CORBA::object_traits;

  /// @name Member types
  //@{
  using _traits_type = TAOX11_IDL::traits<A>;
  /// Strong reference type
  using _ref_type = TAOX11_IDL::traits<A>::ref_type;
  //@}

  // generated from c++11/templates/cli/hdr/operation
  /// @copydoc test.idl::A::op
  virtual void
  op ();

  // generated from c++11/templates/cli/hdr/interface_post
protected:
  using _shared_ptr_type = std::shared_ptr<A>;

  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  explicit A (A_proxy_ptr p, bool inherited = false);
  /// Default constructor
  A () = default;
  /// Destructor
  virtual ~A () = default;

private:
  /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
  //@{
  A(const A&) = delete;
  A(A&&) = delete;
  A& operator=(const A&) = delete;
  A& operator=(A&&) = delete;
  //@}
  A_proxy_ptr a_proxy_ {};
}; // class A

// generated from c++11/templates/cli/hdr/valuetype_fwd
#if !defined (_VALUETYPE_VAL_FWD_)
#define _VALUETYPE_VAL_FWD_

class Val;
namespace obv
{
  class Val;
} // namespace obv
class Val_init;

#endif // !_VALUETYPE_VAL_FWD_

// generated from c++11/templates/cli/hdr/valuetype_traits
#if !defined (_VALUETYPE_VAL_TRAITS_DECL_)
#define _VALUETYPE_VAL_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
     object_traits< ::Val_init>::shared_ptr_type
    object_traits< ::Val_init>::lock_shared (
        ::Val_init*);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::Val_init> :
      public IDL::common_byval_traits <CORBA::object_reference < ::Val_init>>,
      public CORBA::object_traits < ::Val_init>
    {
      using is_abstract = std::false_type ;
      using is_local = std::true_type;
    };
  } // namespace IDL

  namespace CORBA
  {
    template <>
    struct valuetype_traits< ::Val>
    {
      using base_type = ::Val;
      /// Strong reference type
      using ref_type = valuetype_reference< ::Val>;
      /// Weak reference type
      using weak_ref_type = weak_valuetype_reference< ::Val>;
      using obv_type = ::obv::Val;
      using factory_type = ::Val_init;
      using factory_ref_type = TAOX11_IDL::traits< ::Val_init>::ref_type;
      using weak_factory_ref_type = TAOX11_IDL::traits< ::Val_init>::weak_ref_type;
      template <typename _Tp1, typename = typename
          std::enable_if<std::is_convertible< ::Val*, _Tp1*>::value>::type>
      static ref_type narrow (valuetype_reference<_Tp1> base)
      {
        return ref_type::_narrow (std::move(base));
      }
    };
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::Val>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::Val>>,
        public CORBA::valuetype_traits < ::Val>
    {
      using is_abstract = std::false_type;
      using is_truncatable = std::false_type;

      template <typename OStrm_, typename Formatter = formatter< ::Val, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_VALUETYPE_VAL_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuetype_pre
class Val
  : public virtual TAOX11_CORBA::ValueBase
{
public:
  /// @name Member types
  //@{
  using _traits_type = TAOX11_IDL::traits<Val>;
  /// Strong reference type
  using _ref_type = TAOX11_IDL::traits<Val>::ref_type;
  using _factory_type = TAOX11_IDL::traits<Val>::factory_type;
  using _obv_type = TAOX11_IDL::traits<Val>::obv_type;
  //@}

  static bool _obv_unmarshal (TAO_InputCDR &strm, _ref_type &vbox);


protected:
  friend class Val_init;

  using _shared_ptr_type = std::shared_ptr<Val>;

  static const std::string __val_repository_id;

  Val () = default;
  virtual ~Val () = default;
  Val (const Val&) = default;
  Val (Val&&) = default;
  Val& operator= (const Val&) = delete;
  Val& operator= (Val&&) = delete;

  const std::string& _obv_repository_id () const override;
  void _obv_get_truncatable_repo_ids (std::vector<std::string const*>&) const override;

  bool _obv_match_formal_type (ptrdiff_t ) const override;

  bool _obv_marshal_v (TAO_OutputCDR &) const override;
  bool _obv_unmarshal_v (TAO_InputCDR &) override;
public:

  // generated from c++11/templates/cli/hdr/valuetype_post
public:
  static inline const std::string& _repository_id ()
  {
    return __val_repository_id;
  }

  /// @name Public state members
  //@{
  virtual void t (IDL::traits< Val>::ref_type _x11_t) = 0;
  virtual IDL::traits< Val>::ref_type t () const = 0;
  virtual IDL::traits< Val>::ref_type& t () = 0;
  virtual void w (const ::Bytes& _x11_w) = 0;
  virtual void w (::Bytes&& _x11_w) = 0;
  virtual const ::Bytes& w () const = 0;
  virtual ::Bytes& w () = 0;
  virtual void x (const std::string& _x11_x) = 0;
  virtual void x (std::string&& _x11_x) = 0;
  virtual const std::string& x () const = 0;
  virtual std::string& x () = 0;
  //@}

protected:
  /// @name Private state members
  //@{
  virtual void v (int32_t _x11_v) = 0;
  virtual int32_t v () const = 0;
  virtual int32_t& v () = 0;
  virtual void y (const ::S& _x11_y) = 0;
  virtual void y (::S&& _x11_y) = 0;
  virtual const ::S& y () const = 0;
  virtual ::S& y () = 0;
  virtual void z (IDL::traits< ::A>::ref_type _x11_z) = 0;
  virtual IDL::traits< ::A>::ref_type z () const = 0;
  virtual IDL::traits< ::A>::ref_type& z () = 0;
  //@}

protected:
  virtual bool
  _obv_marshal_Val_v (TAO_OutputCDR &, TAO_ChunkInfo &) const = 0;

  virtual bool
  _obv_unmarshal_Val_v (TAO_InputCDR &, TAO_ChunkInfo &) = 0;
}; // class Val

// generated from c++11/templates/cli/hdr/valuetype_obv
namespace obv
{
  class Val
    : public virtual ::Val
  {
  protected:
#if defined (_MSC_VER) && (_MSC_VER < 1920)
    // msvc14.(0|1) have a problem with defaulted constructors, issue #4005
    Val () {}
#else
    Val () = default;
#endif /* _MSC_VER < 1920 */
    virtual ~Val () = default;
    Val (const Val&) = default;
    Val (Val&&) = default;
    explicit Val (
      IDL::traits< ::Val>::ref_type t,
      int32_t v,
      ::Bytes w,
      std::string x,
      ::S y,
      IDL::traits< ::A>::ref_type z)
      : t_ (std::move (t))
      , v_ (std::move (v))
      , w_ (std::move (w))
      , x_ (std::move (x))
      , y_ (std::move (y))
      , z_ (std::move (z))
    {}

  private:
    Val& operator= (const Val&) = delete;
    Val& operator= (Val&&) = delete;

  public:
    template <typename _Tp1, typename, typename ...Args>
    friend TAOX11_CORBA::valuetype_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

    TAOX11_IDL::traits<TAOX11_CORBA::ValueBase>::ref_type _copy_value () const override;

    /// @name Public state members
    //@{
    void t (IDL::traits< ::Val>::ref_type _x11_t) override;
    IDL::traits< ::Val>::ref_type t () const override;
    IDL::traits< ::Val>::ref_type& t () override;

    void w (const ::Bytes& _x11_w) override;
    void w (::Bytes&& _x11_w) override;
    const ::Bytes& w () const override;
    ::Bytes& w () override;

    void x (const std::string& _x11_x) override;
    void x (std::string&& _x11_x) override;
    const std::string& x () const override;
    std::string& x () override;

    //@}
  protected:
    /// Private state members
    void v (int32_t _x11_v) override;
    int32_t v () const override;
    int32_t& v () override;

    void y (const ::S& _x11_y) override;
    void y (::S&& _x11_y) override;
    const ::S& y () const override;
    ::S& y () override;

    void z (IDL::traits< ::A>::ref_type _x11_z) override;
    IDL::traits< ::A>::ref_type z () const override;
    IDL::traits< ::A>::ref_type& z () override;

    /// Marshaling support
    bool _obv_marshal_Val_v (TAO_OutputCDR &, TAO_ChunkInfo &) const override;

    /// Demarshaling support
    bool _obv_unmarshal_Val_v (TAO_InputCDR &, TAO_ChunkInfo &) override;

    bool _obv_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const;
    bool _obv_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &);

  private:
    IDL::traits< ::Val>::ref_type t_;
    int32_t v_ {};
    ::Bytes w_;
    std::string x_;
    ::S y_;
    IDL::traits< ::A>::ref_type z_;
  }; // class Val
} // namespace obv

// generated from c++11/templates/cli/hdr/valuetype_init
class Val_init
  : public TAOX11_CORBA::ValueFactoryBase
{
public:
  using _traits_type = TAOX11_IDL::traits< Val_init>;
  using _ref_type = TAOX11_IDL::traits< Val_init>::ref_type;

  template <typename T> friend struct TAOX11_CORBA::object_traits;
  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  TAOX11_IDL::traits<TAOX11_CORBA::ValueBase>::ref_type
  create_for_unmarshal () override;

  const std::string& _obv_repository_id () const override;

protected:
  Val_init () = default;
  virtual ~Val_init () = default;
  Val_init (const Val_init&) = default;
  Val_init (Val_init&&) = default;
}; // class Val_init

// generated from c++11/templates/cli/hdr/valuebox_fwd
class StringValue;

// generated from c++11/templates/cli/hdr/valuebox_traits
#if !defined (_VBOX_STRINGVALUE_TRAITS_DECL_)
#define _VBOX_STRINGVALUE_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    struct valuetype_traits< ::StringValue>
    {
      /// Strong reference type
      using ref_type = valuetype_reference< ::StringValue>;
      /// Weak reference type
      using weak_ref_type = weak_valuetype_reference< ::StringValue>;

      static ref_type narrow (valuetype_reference<ValueBase>);
    };
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::StringValue>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::StringValue>>,
        public CORBA::valuetype_traits < ::StringValue>
    {
      /// IDL::traits for the boxed type of the valuebox
      using boxed_traits = IDL::traits< std::string>;

      template <typename OStrm_, typename Formatter = formatter< ::StringValue, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_VBOX_STRINGVALUE_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuebox_def
class StringValue final
  : public TAOX11_CORBA::Valuebox_T< std::string>
{
public:
  /// @name Member types
  //@{
  using _traits_type = TAOX11_CORBA::valuetype_traits< StringValue>;
  using _ref_type = TAOX11_CORBA::valuetype_reference< StringValue>;
  //@}

  void _value (const std::string& v) { this->value_ = v; }
  void _value (std::string&& v) { this->value_ = std::move (v); }
  const std::string& _value () const { return this->value_; }
  std::string& _value () { return this->value_; }

  TAOX11_IDL::traits<TAOX11_CORBA::ValueBase>::ref_type _copy_value () const override;

  static bool _obv_unmarshal (TAO_InputCDR &strm, _ref_type &vbox);

protected:
  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::valuetype_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  static const std::string __stringvalue_repository_id;

  StringValue () = default;
  StringValue (const StringValue&) = default;
  StringValue (StringValue&&) = default;
  explicit StringValue (std::string v)
    : TAOX11_CORBA::Valuebox_T< std::string> (std::move(v))
  {}
  virtual ~StringValue () = default;
  StringValue& operator= (const StringValue&) = delete;
  StringValue& operator= (StringValue&&) = delete;

  const std::string& _obv_repository_id () const override;

  bool _obv_marshal_v (TAO_OutputCDR &) const override;
};

// generated from c++11/templates/cli/hdr/valuebox_traits_def
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    inline valuetype_traits< ::StringValue>::ref_type
    valuetype_traits< ::StringValue>::narrow (
          valuetype_reference<ValueBase> vbref)
    {
      return ref_type::_narrow (vbref);
    }
  } // namespace CORBA
} // namespace TAOX11_NAMESPACE

// generated from StubHeaderWriter#enter_interface

// generated from c++11/templates/cli/hdr/interface_fwd
#if !defined (_INTF_X_FWD_)
#define _INTF_X_FWD_
class X;
class X_proxy;
using X_proxy_ptr = X_proxy*;
#endif // !_INTF_X_FWD_

// generated from c++11/templates/cli/hdr/interface_object_traits
#if !defined (_INTF_X_TRAITS_DECL_)
#define _INTF_X_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits< ::X>::shared_ptr_type
    object_traits< ::X>::lock_shared (
        ::X* p);
    template<>
    object_traits< ::X>::ref_type
    object_traits< ::X>::narrow (
       object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::X> :
      public IDL::common_byval_traits <CORBA::object_reference < ::X>>,
      public CORBA::object_traits < ::X>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      using is_local = std::false_type;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      using is_abstract = std::false_type;

      template <typename OStrm_, typename Formatter = formatter< ::X, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_X_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/interface_pre
/// @copydoc test.idl::X
class X
  : public virtual TAOX11_NAMESPACE::CORBA::Object
{
public:
  template <typename T> friend struct TAOX11_CORBA::object_traits;

  /// @name Member types
  //@{
  using _traits_type = TAOX11_IDL::traits<X>;
  /// Strong reference type
  using _ref_type = TAOX11_IDL::traits<X>::ref_type;
  //@}

  // generated from c++11/templates/cli/hdr/operation
  /// @copydoc test.idl::X::op
  virtual void
  op (
      std::string& s);

  // generated from c++11/templates/cli/hdr/interface_post
protected:
  using _shared_ptr_type = std::shared_ptr<X>;

  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  explicit X (X_proxy_ptr p, bool inherited = false);
  /// Default constructor
  X () = default;
  /// Destructor
  virtual ~X () = default;

private:
  /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
  //@{
  X(const X&) = delete;
  X(X&&) = delete;
  X& operator=(const X&) = delete;
  X& operator=(X&&) = delete;
  //@}
  X_proxy_ptr x_proxy_ {};
}; // class X

// generated from c++11/templates/cli/hdr/enum

/// @copydoc test.idl::Color
enum class Color : uint32_t
{
  /// @copydoc test.idl::Color::red
  red,
  /// @copydoc test.idl::Color::green
  green,
  /// @copydoc test.idl::Color::blue
  blue
};// Color


// generated from c++11/templates/cli/hdr/valuebox_fwd
class ColorValue;

// generated from c++11/templates/cli/hdr/valuebox_traits
#if !defined (_VBOX_COLORVALUE_TRAITS_DECL_)
#define _VBOX_COLORVALUE_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    struct valuetype_traits< ::ColorValue>
    {
      /// Strong reference type
      using ref_type = valuetype_reference< ::ColorValue>;
      /// Weak reference type
      using weak_ref_type = weak_valuetype_reference< ::ColorValue>;

      static ref_type narrow (valuetype_reference<ValueBase>);
    };
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::ColorValue>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::ColorValue>>,
        public CORBA::valuetype_traits < ::ColorValue>
    {
      /// IDL::traits for the boxed type of the valuebox
      using boxed_traits = IDL::traits< ::Color>;

      template <typename OStrm_, typename Formatter = formatter< ::ColorValue, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_VBOX_COLORVALUE_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuebox_def
class ColorValue final
  : public TAOX11_CORBA::Valuebox_T< ::Color>
{
public:
  /// @name Member types
  //@{
  using _traits_type = TAOX11_CORBA::valuetype_traits< ColorValue>;
  using _ref_type = TAOX11_CORBA::valuetype_reference< ColorValue>;
  //@}

  void _value (::Color v) { this->value_ = v; }
  ::Color _value () const { return this->value_; }
  ::Color& _value () { return this->value_; }

  TAOX11_IDL::traits<TAOX11_CORBA::ValueBase>::ref_type _copy_value () const override;

  static bool _obv_unmarshal (TAO_InputCDR &strm, _ref_type &vbox);

protected:
  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::valuetype_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  static const std::string __colorvalue_repository_id;

  ColorValue () = default;
  ColorValue (const ColorValue&) = default;
  ColorValue (ColorValue&&) = default;
  explicit ColorValue (::Color v)
    : TAOX11_CORBA::Valuebox_T< ::Color> (std::move(v))
  {}
  virtual ~ColorValue () = default;
  ColorValue& operator= (const ColorValue&) = delete;
  ColorValue& operator= (ColorValue&&) = delete;

  const std::string& _obv_repository_id () const override;

  bool _obv_marshal_v (TAO_OutputCDR &) const override;
};

// generated from c++11/templates/cli/hdr/valuebox_traits_def
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    inline valuetype_traits< ::ColorValue>::ref_type
    valuetype_traits< ::ColorValue>::narrow (
          valuetype_reference<ValueBase> vbref)
    {
      return ref_type::_narrow (vbref);
    }
  } // namespace CORBA
} // namespace TAOX11_NAMESPACE

// generated from c++11/templates/cli/hdr/struct_pre

/// @copydoc test.idl::ColorValue2
class ColorValue2
{
public:

  // generated from c++11/templates/cli/hdr/struct_post
  /// Default constructor
  ColorValue2 () = default;
  /// Destructor
  ~ColorValue2 () = default;
  /// Copy constructor
  ColorValue2 (const ColorValue2&) = default;
  /// Move constructor
  ColorValue2 (ColorValue2&&) = default;
  /// Constructor which accepts value for all members
  explicit inline ColorValue2 (
    ::Color col);
  /// Copy assignment operator
  ColorValue2& operator= (const ColorValue2&) = default;
  /// Move assignment operator
  ColorValue2& operator= (ColorValue2&&) = default;

  /// @copydoc test.idl::ColorValue2::col
  //@{
  inline void col (::Color _x11_col) { this->col_ = _x11_col; }
  inline ::Color col () const { return this->col_; }
  inline ::Color& col () { return this->col_; }
  //@}

  /// Exchange the value of two structs in an efficient matter
  inline void swap (ColorValue2& s);

private:
  ::Color col_ {};
};// ColorValue2

inline void swap (::ColorValue2& m1, ::ColorValue2& m2) { m1.swap (m2); }


// generated from StubHeaderWriter#enter_interface

// generated from c++11/templates/cli/hdr/interface_fwd
#if !defined (_INTF_A1_FWD_)
#define _INTF_A1_FWD_
class A1;
class A1_proxy;
using A1_proxy_ptr = A1_proxy*;
#endif // !_INTF_A1_FWD_

// generated from c++11/templates/cli/hdr/interface_object_traits
#if !defined (_INTF_A1_TRAITS_DECL_)
#define _INTF_A1_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits< ::A1>::shared_ptr_type
    object_traits< ::A1>::lock_shared (
        ::A1* p);
    template<>
    object_traits< ::A1>::ref_type
    object_traits< ::A1>::narrow (
       object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::A1> :
      public IDL::common_byval_traits <CORBA::object_reference < ::A1>>,
      public CORBA::object_traits < ::A1>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      using is_local = std::false_type;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      using is_abstract = std::false_type;

      template <typename OStrm_, typename Formatter = formatter< ::A1, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_A1_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/interface_pre
/// @copydoc test.idl::A1
class A1
  : public virtual TAOX11_NAMESPACE::CORBA::Object
{
public:
  template <typename T> friend struct TAOX11_CORBA::object_traits;

  /// @name Member types
  //@{
  using _traits_type = TAOX11_IDL::traits<A1>;
  /// Strong reference type
  using _ref_type = TAOX11_IDL::traits<A1>::ref_type;
  //@}

  // generated from c++11/templates/cli/hdr/operation
  /// @copydoc test.idl::A1::op
  virtual void
  op ();

  // generated from c++11/templates/cli/hdr/interface_post
protected:
  using _shared_ptr_type = std::shared_ptr<A1>;

  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  explicit A1 (A1_proxy_ptr p, bool inherited = false);
  /// Default constructor
  A1 () = default;
  /// Destructor
  virtual ~A1 () = default;

private:
  /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
  //@{
  A1(const A1&) = delete;
  A1(A1&&) = delete;
  A1& operator=(const A1&) = delete;
  A1& operator=(A1&&) = delete;
  //@}
  A1_proxy_ptr a1_proxy_ {};
}; // class A1

// generated from c++11/templates/cli/hdr/valuetype_fwd
#if !defined (_VALUETYPE_B_FWD_)
#define _VALUETYPE_B_FWD_

class B;
namespace obv
{
  class B;
} // namespace obv

#endif // !_VALUETYPE_B_FWD_

// generated from c++11/templates/cli/hdr/valuetype_traits
#if !defined (_VALUETYPE_B_TRAITS_DECL_)
#define _VALUETYPE_B_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template <>
    struct valuetype_traits< ::B>
    {
      using base_type = ::B;
      /// Strong reference type
      using ref_type = valuetype_reference< ::B>;
      /// Weak reference type
      using weak_ref_type = weak_valuetype_reference< ::B>;
      using obv_type = ::obv::B;
      using factory_type = CORBA::ValueFactoryBase;
      using factory_ref_type = IDL::traits<CORBA::ValueFactoryBase>::ref_type;
      using weak_factory_ref_type = IDL::traits<CORBA::ValueFactoryBase>::weak_ref_type;
      template <typename _Tp1, typename = typename
          std::enable_if<std::is_convertible< ::B*, _Tp1*>::value>::type>
      static ref_type narrow (valuetype_reference<_Tp1> base)
      {
        return ref_type::_narrow (std::move(base));
      }
    };
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::B>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::B>>,
        public CORBA::valuetype_traits < ::B>
    {
      using is_abstract = std::false_type;
      using is_truncatable = std::false_type;

      template <typename OStrm_, typename Formatter = formatter< ::B, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_VALUETYPE_B_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuetype_pre
class B
  : public virtual TAOX11_CORBA::ValueBase
{
public:
  /// @name Member types
  //@{
  using _traits_type = TAOX11_IDL::traits<B>;
  /// Strong reference type
  using _ref_type = TAOX11_IDL::traits<B>::ref_type;
  using _obv_type = TAOX11_IDL::traits<B>::obv_type;
  //@}

  static bool _obv_unmarshal (TAO_InputCDR &strm, _ref_type &vbox);


protected:
  using _shared_ptr_type = std::shared_ptr<B>;

  static const std::string __b_repository_id;

  B () = default;
  virtual ~B () = default;
  B (const B&) = default;
  B (B&&) = default;
  B& operator= (const B&) = delete;
  B& operator= (B&&) = delete;

  const std::string& _obv_repository_id () const override;
  void _obv_get_truncatable_repo_ids (std::vector<std::string const*>&) const override;

  bool _obv_match_formal_type (ptrdiff_t ) const override;

  bool _obv_marshal_v (TAO_OutputCDR &) const override;
  bool _obv_unmarshal_v (TAO_InputCDR &) override;
public:

  // generated from c++11/templates/cli/hdr/valuetype_post
public:
  static inline const std::string& _repository_id ()
  {
    return __b_repository_id;
  }

  // Operations

  // generated from c++11/templates/cli/hdr/operation
  /// @copydoc test.idl::A1::op
  virtual void
  op () = 0;

  /// @name Public state members
  //@{
  virtual void data (int16_t _x11_data) = 0;
  virtual int16_t data () const = 0;
  virtual int16_t& data () = 0;
  //@}

protected:
  virtual bool
  _obv_marshal_B_v (TAO_OutputCDR &, TAO_ChunkInfo &) const = 0;

  virtual bool
  _obv_unmarshal_B_v (TAO_InputCDR &, TAO_ChunkInfo &) = 0;
}; // class B

// generated from c++11/templates/cli/hdr/valuetype_obv
namespace obv
{
  class B
    : public virtual ::B
  {
  protected:
#if defined (_MSC_VER) && (_MSC_VER < 1920)
    // msvc14.(0|1) have a problem with defaulted constructors, issue #4005
    B () {}
#else
    B () = default;
#endif /* _MSC_VER < 1920 */
    virtual ~B () = default;
    B (const B&) = default;
    B (B&&) = default;
    explicit B (
      int16_t data)
      : data_ (std::move (data))
    {}

  private:
    B& operator= (const B&) = delete;
    B& operator= (B&&) = delete;

  public:
    /// @name Public state members
    //@{
    void data (int16_t _x11_data) override;
    int16_t data () const override;
    int16_t& data () override;

    //@}
  protected:
    /// Marshaling support
    bool _obv_marshal_B_v (TAO_OutputCDR &, TAO_ChunkInfo &) const override;

    /// Demarshaling support
    bool _obv_unmarshal_B_v (TAO_InputCDR &, TAO_ChunkInfo &) override;

    bool _obv_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const;
    bool _obv_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &);

  private:
    int16_t data_ {};
  }; // class B
} // namespace obv

// generated from c++11/templates/cli/hdr/valuetype_fwd
#if !defined (_VALUETYPE_V_FWD_)
#define _VALUETYPE_V_FWD_

class V;
namespace obv
{
  class V;
} // namespace obv
class V_init;

#endif // !_VALUETYPE_V_FWD_

// generated from c++11/templates/cli/hdr/valuetype_traits
#if !defined (_VALUETYPE_V_TRAITS_DECL_)
#define _VALUETYPE_V_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
     object_traits< ::V_init>::shared_ptr_type
    object_traits< ::V_init>::lock_shared (
        ::V_init*);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::V_init> :
      public IDL::common_byval_traits <CORBA::object_reference < ::V_init>>,
      public CORBA::object_traits < ::V_init>
    {
      using is_abstract = std::false_type ;
      using is_local = std::true_type;
    };
  } // namespace IDL

  namespace CORBA
  {
    template <>
    struct valuetype_traits< ::V>
    {
      using base_type = ::V;
      /// Strong reference type
      using ref_type = valuetype_reference< ::V>;
      /// Weak reference type
      using weak_ref_type = weak_valuetype_reference< ::V>;
      using obv_type = ::obv::V;
      using factory_type = ::V_init;
      using factory_ref_type = TAOX11_IDL::traits< ::V_init>::ref_type;
      using weak_factory_ref_type = TAOX11_IDL::traits< ::V_init>::weak_ref_type;
      template <typename _Tp1, typename = typename
          std::enable_if<std::is_convertible< ::V*, _Tp1*>::value>::type>
      static ref_type narrow (valuetype_reference<_Tp1> base)
      {
        return ref_type::_narrow (std::move(base));
      }
    };
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::V>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::V>>,
        public CORBA::valuetype_traits < ::V>
    {
      using is_abstract = std::false_type;
      using is_truncatable = std::false_type;

      template <typename OStrm_, typename Formatter = formatter< ::V, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_VALUETYPE_V_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuetype_pre
class V
  : public virtual TAOX11_CORBA::ValueBase
{
public:
  /// @name Member types
  //@{
  using _traits_type = TAOX11_IDL::traits<V>;
  /// Strong reference type
  using _ref_type = TAOX11_IDL::traits<V>::ref_type;
  using _factory_type = TAOX11_IDL::traits<V>::factory_type;
  using _obv_type = TAOX11_IDL::traits<V>::obv_type;
  //@}

  static bool _obv_unmarshal (TAO_InputCDR &strm, _ref_type &vbox);


protected:
  friend class V_init;

  using _shared_ptr_type = std::shared_ptr<V>;

  static const std::string __v_repository_id;

  V () = default;
  virtual ~V () = default;
  V (const V&) = default;
  V (V&&) = default;
  V& operator= (const V&) = delete;
  V& operator= (V&&) = delete;

  const std::string& _obv_repository_id () const override;
  void _obv_get_truncatable_repo_ids (std::vector<std::string const*>&) const override;

  bool _obv_match_formal_type (ptrdiff_t ) const override;

  bool _obv_marshal_v (TAO_OutputCDR &) const override;
  bool _obv_unmarshal_v (TAO_InputCDR &) override;
public:

  // generated from c++11/templates/cli/hdr/valuetype_post
public:
  static inline const std::string& _repository_id ()
  {
    return __v_repository_id;
  }


protected:
  virtual bool
  _obv_marshal_V_v (TAO_OutputCDR &, TAO_ChunkInfo &) const = 0;

  virtual bool
  _obv_unmarshal_V_v (TAO_InputCDR &, TAO_ChunkInfo &) = 0;
}; // class V

// generated from c++11/templates/cli/hdr/valuetype_obv
namespace obv
{
  class V
    : public virtual ::V
  {
  protected:
#if defined (_MSC_VER) && (_MSC_VER < 1920)
    // msvc14.(0|1) have a problem with defaulted constructors, issue #4005
    V () {}
#else
    V () = default;
#endif /* _MSC_VER < 1920 */
    virtual ~V () = default;
    V (const V&) = default;
    V (V&&) = default;

  private:
    V& operator= (const V&) = delete;
    V& operator= (V&&) = delete;

  public:
  protected:
    /// Marshaling support
    bool _obv_marshal_V_v (TAO_OutputCDR &, TAO_ChunkInfo &) const override;

    /// Demarshaling support
    bool _obv_unmarshal_V_v (TAO_InputCDR &, TAO_ChunkInfo &) override;

    bool _obv_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const;
    bool _obv_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &);

  private:
  }; // class V
} // namespace obv

// generated from c++11/templates/cli/hdr/valuetype_init
class V_init
  : public TAOX11_CORBA::ValueFactoryBase
{
public:
  using _traits_type = TAOX11_IDL::traits< V_init>;
  using _ref_type = TAOX11_IDL::traits< V_init>::ref_type;

  template <typename T> friend struct TAOX11_CORBA::object_traits;
  virtual IDL::traits< ::V>::ref_type
  create_bool (bool b) = 0;
  virtual IDL::traits< ::V>::ref_type
  create_char (char c) = 0;
  virtual IDL::traits< ::V>::ref_type
  create_octet (uint8_t o) = 0;
  virtual IDL::traits< ::V>::ref_type
  create_other (int16_t s,
                const std::string& p) = 0;

  const std::string& _obv_repository_id () const override;

protected:
  V_init () = default;
  virtual ~V_init () = default;
  V_init (const V_init&) = default;
  V_init (V_init&&) = default;
}; // class V_init

// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/valuetype_idl_traits
#if !defined (_VALUETYPE_EXAMPLE_IDL_TRAITS_DECL_)
#define _VALUETYPE_EXAMPLE_IDL_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::Example, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Example>::__Writer<Fmt>);
#endif // !_VALUETYPE_EXAMPLE_IDL_TRAITS_DECL_

    // generated from c++11/templates/cli/hdr/array_idl_traits
    // Unaliased type : std::array< uint8_t, 64>
    // MD5            : E53446397587C4EBA409F3A2EFDC9394
#if !defined(_ALIAS_E53446397587C4EBA409F3A2EFDC9394_TRAITS_DECL_)
#define _ALIAS_E53446397587C4EBA409F3A2EFDC9394_TRAITS_DECL_

    template<>
    struct traits < ::Bytes>
      : IDL::common_traits< ::Bytes>
    {
      /// IDL::traits<> for the element of the array
      using element_traits = IDL::traits< uint8_t>;
      /// std::integral_constant type of value_type uint32_t
      /// indicating the number of dimensions of the array
      using dimensions = std::integral_constant<uint32_t, 1>;

      template <typename OStrm_,
                typename Formatter = formatter< ::Bytes, OStrm_>
               >
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Bytes>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Bytes>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Bytes, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Bytes>::write_on (
          os, w.val_,
          formatter_t ());
    }

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_S_TRAITS_)
#define _STRUCT_S_TRAITS_
    template<>
    struct traits < ::S>
      : IDL::common_traits< ::S>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::S, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::S>::__Writer<Fmt>);
#endif // _STRUCT_S_TRAITS_

    // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_A_TRAITS_DECL_)
#define _INTF_FMT_A_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::A, OStrm_>
    {
      OStrm_& operator ()(
          OStrm_& ,
          IDL::traits< ::A>::ref_type);
    };

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::A>::__Writer<Fmt>);
#endif // !_INTF_FMT_A_TRAITS_DECL_

    // generated from c++11/templates/cli/hdr/valuetype_idl_traits
#if !defined (_VALUETYPE_VAL_IDL_TRAITS_DECL_)
#define _VALUETYPE_VAL_IDL_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::Val, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Val>::__Writer<Fmt>);
#endif // !_VALUETYPE_VAL_IDL_TRAITS_DECL_

    // generated from c++11/templates/cli/hdr/valuebox_idl_traits
    template <typename OStrm_>
    struct formatter< ::StringValue, OStrm_>
    {
      using boxed_traits = typename IDL::traits< ::StringValue>::boxed_traits;

      inline OStrm_& operator ()(
          OStrm_& os_,
          IDL::traits< ::StringValue>::ref_type val_)
      {
        os_ << "StringValue {" << boxed_traits::write (val_->_value()) << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::StringValue>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::StringValue>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::StringValue, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::StringValue>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_X_TRAITS_DECL_)
#define _INTF_FMT_X_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::X, OStrm_>
    {
      OStrm_& operator ()(
          OStrm_& ,
          IDL::traits< ::X>::ref_type);
    };

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::X>::__Writer<Fmt>);
#endif // !_INTF_FMT_X_TRAITS_DECL_

    // generated from c++11/templates/cli/hdr/enum_idl_traits
    template<>
    struct traits < ::Color>
      : IDL::common_byval_traits< ::Color>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Color, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Color val_)
      {
        switch (val_)
        {
          case ::Color::red: os_ << "Color::red"; break;
          case ::Color::green: os_ << "Color::green"; break;
          case ::Color::blue: os_ << "Color::blue"; break;
        }
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Color>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Color>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Color, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Color>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/valuebox_idl_traits
    template <typename OStrm_>
    struct formatter< ::ColorValue, OStrm_>
    {
      using boxed_traits = typename IDL::traits< ::ColorValue>::boxed_traits;

      inline OStrm_& operator ()(
          OStrm_& os_,
          IDL::traits< ::ColorValue>::ref_type val_)
      {
        os_ << "ColorValue {" << boxed_traits::write (val_->_value()) << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::ColorValue>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::ColorValue>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::ColorValue, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::ColorValue>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_COLORVALUE2_TRAITS_)
#define _STRUCT_COLORVALUE2_TRAITS_
    template<>
    struct traits < ::ColorValue2>
      : IDL::common_traits< ::ColorValue2>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::ColorValue2, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::ColorValue2>::__Writer<Fmt>);
#endif // _STRUCT_COLORVALUE2_TRAITS_

    // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_A1_TRAITS_DECL_)
#define _INTF_FMT_A1_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::A1, OStrm_>
    {
      OStrm_& operator ()(
          OStrm_& ,
          IDL::traits< ::A1>::ref_type);
    };

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::A1>::__Writer<Fmt>);
#endif // !_INTF_FMT_A1_TRAITS_DECL_

    // generated from c++11/templates/cli/hdr/valuetype_idl_traits
#if !defined (_VALUETYPE_B_IDL_TRAITS_DECL_)
#define _VALUETYPE_B_IDL_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::B, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::B>::__Writer<Fmt>);
#endif // !_VALUETYPE_B_IDL_TRAITS_DECL_

    // generated from c++11/templates/cli/hdr/valuetype_idl_traits
#if !defined (_VALUETYPE_V_IDL_TRAITS_DECL_)
#define _VALUETYPE_V_IDL_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::V, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::V>::__Writer<Fmt>);
#endif // !_VALUETYPE_V_IDL_TRAITS_DECL_
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/valuetype_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Example, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          IDL::traits< ::Example>::ref_type val_)
      {
        os_ << "Example"
            << '{'
            << "val2=" << IDL::traits< int32_t>::write(val_->val2 ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Example>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Example>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Example, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Example>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::S, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::S& val_)
      {
        os_ << "S"
            << '{'
            << "value=" << IDL::traits< int32_t>::write(val_.value ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::S>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::S>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::S, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::S>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/interface_idl_traits_def
    template <typename OStrm_>
    inline OStrm_&
    formatter< ::A, OStrm_>::operator ()(
          OStrm_& os_,
          IDL::traits< ::A>::ref_type val_)
    {
      os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (
               std::move (val_),
               "A");
      return os_;
    }

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::A>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::A>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::A, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::A>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/valuetype_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::Val, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          IDL::traits< ::Val>::ref_type val_)
      {
        os_ << "Val"
            << '{'
            << "t=" << IDL::traits< ::Val>::write(val_->t ())
            << ",w=" << IDL::traits< ::Bytes>::write(val_->w ())
            << ",x=" << IDL::traits< std::string>::write(val_->x ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Val>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::Val>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::Val, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::Val>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/interface_idl_traits_def
    template <typename OStrm_>
    inline OStrm_&
    formatter< ::X, OStrm_>::operator ()(
          OStrm_& os_,
          IDL::traits< ::X>::ref_type val_)
    {
      os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (
               std::move (val_),
               "X");
      return os_;
    }

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::X>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::X>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::X, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::X>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::ColorValue2, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::ColorValue2& val_)
      {
        os_ << "ColorValue2"
            << '{'
            << "col=" << IDL::traits< ::Color>::write(val_.col ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::ColorValue2>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::ColorValue2>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::ColorValue2, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::ColorValue2>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/interface_idl_traits_def
    template <typename OStrm_>
    inline OStrm_&
    formatter< ::A1, OStrm_>::operator ()(
          OStrm_& os_,
          IDL::traits< ::A1>::ref_type val_)
    {
      os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (
               std::move (val_),
               "A1");
      return os_;
    }

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::A1>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::A1>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::A1, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::A1>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/valuetype_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::B, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          IDL::traits< ::B>::ref_type val_)
      {
        os_ << "B"
            << '{'
            << "data=" << IDL::traits< int16_t>::write(val_->data ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::B>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::B>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::B, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::B>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/valuetype_idl_traits_def
    template <typename OStrm_>
    struct formatter< ::V, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          IDL::traits< ::V>::ref_type)
      {
        os_ << "V"
            ;
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::V>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits< ::V>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter< ::V, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits< ::V>::write_on (
          os, w.val_,
          formatter_t ());
    }
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from c++11/templates/cli/inl/struct_inl
inline ::S::S (
  int32_t value)
  : value_ (std::move (value))
{
}

inline void ::S::swap (::S& s)
{
  std::swap (this->value_, s.value_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::ColorValue2::ColorValue2 (
  ::Color col)
  : col_ (std::move (col))
{
}

inline void ::ColorValue2::swap (::ColorValue2& s)
{
  std::swap (this->col_, s.col_);
}

// generated from c++11/templates/cli/hdr/valuetype_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    IDL::traits< ::Example>::ref_type _v)
{
  return IDL::traits< ::Example>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/array_os
// Unaliased type : std::array< uint8_t, 64>
// MD5            : E53446397587C4EBA409F3A2EFDC9394
#if !defined (_ALIAS_OSTREAM_E53446397587C4EBA409F3A2EFDC9394_DECL_)
#define _ALIAS_OSTREAM_E53446397587C4EBA409F3A2EFDC9394_DECL_

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Bytes& _v)
{
  return IDL::traits< ::Bytes>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_E53446397587C4EBA409F3A2EFDC9394_DECL_

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::S& _v)
{
  return IDL::traits< ::S>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/interface_os
inline std::ostream& operator<< (
    std::ostream& strm,
    IDL::traits< ::A>::ref_type _v)
{
  return IDL::traits< ::A>::write_on (strm, std::move(_v));
}

// generated from c++11/templates/cli/hdr/valuetype_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    IDL::traits< ::Val>::ref_type _v)
{
  return IDL::traits< ::Val>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/valuebox_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    IDL::traits< ::StringValue>::ref_type _v)
{
  return IDL::traits< ::StringValue>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/interface_os
inline std::ostream& operator<< (
    std::ostream& strm,
    IDL::traits< ::X>::ref_type _v)
{
  return IDL::traits< ::X>::write_on (strm, std::move(_v));
}

// generated from c++11/templates/cli/hdr/enum_os
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Color _v)
{
  return IDL::traits< ::Color>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/valuebox_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    IDL::traits< ::ColorValue>::ref_type _v)
{
  return IDL::traits< ::ColorValue>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::ColorValue2& _v)
{
  return IDL::traits< ::ColorValue2>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/interface_os
inline std::ostream& operator<< (
    std::ostream& strm,
    IDL::traits< ::A1>::ref_type _v)
{
  return IDL::traits< ::A1>::write_on (strm, std::move(_v));
}

// generated from c++11/templates/cli/hdr/valuetype_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    IDL::traits< ::B>::ref_type _v)
{
  return IDL::traits< ::B>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/valuetype_os
inline std::ostream&
operator<< (
    std::ostream& strm,
    IDL::traits< ::V>::ref_type _v)
{
  return IDL::traits< ::V>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/post
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testCP.h"
#endif

#include /**/ "ace/post.h"

#endif /* __RIDL_TESTC_H_FJIDCAEA_INCLUDED__ */

// -*- END -*-
