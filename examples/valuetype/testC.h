// -*- C++ -*-
/*
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT
 *        Nijkerk, GLD
 *        The Netherlands
 *        http://www.remedy.nl \ http://www.theaceorb.nl
 */

#ifndef __RIDL_TESTC_H_0_45410861461006546_INCLUDED__
#define __RIDL_TESTC_H_0_45410861461006546_INCLUDED__


#include /**/ "ace/pre.h"

#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/valuetype/value_base.h"
#include "tao/x11/valuetype/value_factory_base.h"
#include "tao/x11/object.h"
#include "tao/x11/valuetype/value_box_t.h"
#include "tao/x11/corba_ostream.h"

using namespace TAOX11_NAMESPACE;

// generated from c++11/templates/cli/hdr/valuetype_fwd.erb
#if !defined (_VALUETYPE_EXAMPLE_FWD_)
#define _VALUETYPE_EXAMPLE_FWD_

class Example;
namespace obv
{
  class Example;
};

#endif // !_VALUETYPE_EXAMPLE_FWD_

// generated from c++11/templates/cli/hdr/valuetype_traits.erb
#if !defined (_VALUETYPE_EXAMPLE_TRAITS_DECL_)
#define _VALUETYPE_EXAMPLE_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template <>
    struct valuetype_traits< ::Example>
    {
      typedef ::Example
          base_type;
      typedef valuetype_reference< ::Example>
          ref_type;
      typedef weak_valuetype_reference< ::Example>
          weak_ref_type;
      typedef ::obv::Example
          obv_type;
      template <typename _Tp1, typename = typename
          std::enable_if<std::is_convertible< ::Example*, _Tp1*>::value>::type>
      static ref_type narrow (valuetype_reference<_Tp1> base)
      {
        return ref_type::_narrow (base);
      }
    };
  };

  namespace IDL
  {
    template<>
    struct traits < ::Example>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::Example>>,
        public CORBA::valuetype_traits < ::Example>
    {
      static constexpr bool abstract = false;
      static constexpr bool truncatable = false;
    };
  };
};
#endif // !_VALUETYPE_EXAMPLE_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuetype_pre.erb
class Example
  : public virtual TAOX11_CORBA::ValueBase
{
public:
  /// @name Member types
  //@{
  typedef TAOX11_IDL::traits< Example>               _traits_type;
  typedef TAOX11_IDL::traits< Example>::ref_type     _ref_type;
  typedef TAOX11_IDL::traits< Example>::obv_type     _obv_type;
  //@}

  static bool _obv_unmarshal (
      TAO_InputCDR &strm,
      _ref_type &vbox);


protected:
  typedef std::shared_ptr<Example> _shared_ptr_type;

  static const std::string __example_repository_id;

  Example () = default;
  ~Example () = default;
  Example (const Example&) = default;
  Example (Example&&) = default;
  void operator =(const Example&) = delete;
  void operator =(Example&&) = delete;

  virtual const std::string& _obv_repository_id () const override;
  virtual void _obv_get_truncatable_repo_ids (std::vector<std::string const*>&) const override;

  virtual bool _obv_match_formal_type (ptrdiff_t ) const override;

  virtual bool _obv_marshal_v (TAO_OutputCDR &) const override;
  virtual bool _obv_unmarshal_v (TAO_InputCDR &) override;
public:

  // generated from c++11/templates/cli/hdr/valuetype_post.erb
public:
  static inline const std::string& _repository_id ()
  {
    return __example_repository_id;
  }

  void swap (Example& s);

  // Operations

  // generated from c++11/templates/cli/hdr/operation.erb
  /// @copybrief Example::op1
  virtual int16_t op1 () = 0;

  // generated from c++11/templates/cli/hdr/operation.erb
  /// @copybrief Example::op2
  virtual int32_t op2 (TAOX11_IDL::traits< Example>::ref_type x) = 0;

  /// @name Public state members
  //@{
  virtual void val2 (int32_t _val2) = 0;
  virtual int32_t val2 () const = 0;
  virtual int32_t& val2 () = 0;
  //@}

protected:
  /// @name Private state members
  //@{
  virtual void val1 (int16_t _val1) = 0;
  virtual int16_t val1 () const = 0;
  virtual int16_t& val1 () = 0;
  virtual void val3 (const std::string& _val3) = 0;
  virtual void val3 (std::string&& _val3) = 0;
  virtual const std::string& val3 () const = 0;
  virtual std::string& val3 () = 0;
  virtual void val5 (TAOX11_IDL::traits< Example>::ref_type _val5) = 0;
  virtual TAOX11_IDL::traits< Example>::ref_type val5 () const = 0;
  virtual TAOX11_IDL::traits< Example>::ref_type& val5 () = 0;
  //@}

protected:
  virtual bool
  _obv_marshal_Example_v (TAO_OutputCDR &, TAO_ChunkInfo &) const = 0;

  virtual bool
  _obv_unmarshal_Example_v (TAO_InputCDR &, TAO_ChunkInfo &) = 0;
}; // Example

// generated from c++11/templates/cli/hdr/valuetype_obv.erb
namespace obv
{
  class Example
    : public virtual ::Example
  {
  protected:
    Example () = default;
    ~Example () = default;
    Example (const Example&) = default;
    Example (Example&&) = default;
    explicit Example (int16_t val1,
                      int32_t val2,
                      std::string val3,
                      TAOX11_IDL::traits< ::Example>::ref_type val5)
      : val1_ (std::move (val1))
      , val2_ (std::move (val2))
      , val3_ (std::move (val3))
      , val5_ (std::move (val5))
    {}
    void operator =(const Example&) = delete;
    void operator =(Example&&) = delete;

  public:
    /// @name Public state members
    //@{
    virtual void val2 (int32_t _val2) override;
    virtual int32_t val2 () const override;
    virtual int32_t& val2 () override;

    //@}
  protected:
    /// Private state members
    virtual void val1 (int16_t _val1) override;
    virtual int16_t val1 () const override;
    virtual int16_t& val1 () override;

    virtual void val3 (const std::string& _val3) override;
    virtual void val3 (std::string&& _val3) override;
    virtual const std::string& val3 () const override;
    virtual std::string& val3 () override;

    virtual void val5 (TAOX11_IDL::traits< ::Example>::ref_type _val5) override;
    virtual TAOX11_IDL::traits< ::Example>::ref_type val5 () const override;
    virtual TAOX11_IDL::traits< ::Example>::ref_type& val5 () override;

    /// Marshaling support
    virtual bool
    _obv_marshal_Example_v (TAO_OutputCDR &, TAO_ChunkInfo &) const override;

    /// Demarshaling support
    virtual bool
    _obv_unmarshal_Example_v (TAO_InputCDR &, TAO_ChunkInfo &) override;

    bool _obv_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const;
    bool _obv_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &);

  private:
    int16_t val1_;
    int32_t val2_;
    std::string val3_;
    TAOX11_IDL::traits< ::Example>::ref_type val5_;
  }; // Example

}; // obv

// generated from c++11/templates/cli/hdr/typedef.erb

typedef std::array< uint8_t, 64 > Bytes;

// generated from c++11/templates/cli/hdr/struct_pre.erb
class S final
{
public:

  // generated from c++11/templates/cli/hdr/struct_post.erb
  inline S ();
  ~S () = default;
  S (const S&) = default;
  S (S&&) = default;
  explicit inline S (int32_t value);
  inline S& operator= (const S& x);
  inline S& operator= (S&& x);

  inline void value (int32_t _value);
  inline int32_t value () const;
  inline int32_t& value ();

  inline void swap (S& s);

private:
  int32_t value_;
};// S

// generated from StubHeaderWriter#enter_interface

// generated from c++11/templates/cli/hdr/interface_fwd.erb
#if !defined (_INTF_A_FWD_)
#define _INTF_A_FWD_
class A;
class A_proxy;
typedef A_proxy* A_proxy_ptr;
#endif // !_INTF_A_FWD_

// generated from c++11/templates/cli/hdr/interface_object_traits.erb
#if !defined (_INTF_A_TRAITS_DECL_)
#define _INTF_A_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits< ::A>::shared_ptr_type
    object_traits< ::A>::lock_shared (
        ::A* p);
    template<>
    const Object_proxy*
    object_traits< ::A>::to_proxy (
        object_traits< ::A>::ref_type);
    template<>
    object_traits< ::A>::ref_type
    object_traits< ::A>::narrow (
       object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  };

  namespace IDL
  {
    template<>
    struct traits < ::A> :
      public IDL::common_byval_traits <CORBA::object_reference < ::A>>,
      public CORBA::object_traits < ::A>
    {
      static constexpr bool local = false;
      static constexpr bool abstract = false;
    };
  };
};
#endif // !_INTF_A_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/interface_pre.erb
class A
  : public virtual TAOX11_NAMESPACE::CORBA::Object
{
public:
  template <typename T> friend struct TAOX11_CORBA::object_traits;

  /// @name Member types
  //@{
  typedef TAOX11_IDL::traits< A>           _traits_type;
  typedef TAOX11_IDL::traits< A>::ref_type _ref_type;
  //@}

  // generated from c++11/templates/cli/hdr/operation.erb
  /// @copybrief A::op
  virtual void op ();

  // generated from c++11/templates/cli/hdr/interface_post.erb
protected:
  typedef std::shared_ptr<A>   _shared_ptr_type;

  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  explicit A (A_proxy_ptr p);
  explicit A (A_proxy_ptr p, bool);
  A ();
  ~A () = default;

private:
  A(const A&) = delete;
  A(A&&) = delete;
  A& operator=(const A&) = delete;
  A& operator=(A&&) = delete;
  A_proxy_ptr a_proxy_;
}; // A

// generated from c++11/templates/cli/hdr/valuetype_fwd.erb
#if !defined (_VALUETYPE_VAL_FWD_)
#define _VALUETYPE_VAL_FWD_

class Val;
namespace obv
{
  class Val;
};
class Val_init;

#endif // !_VALUETYPE_VAL_FWD_

// generated from c++11/templates/cli/hdr/valuetype_traits.erb
#if !defined (_VALUETYPE_VAL_TRAITS_DECL_)
#define _VALUETYPE_VAL_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
     object_traits< ::Val_init>::shared_ptr_type
    object_traits< ::Val_init>::lock_shared (
        ::Val_init*);
  };

  namespace IDL
  {
    template<>
    struct traits < ::Val_init> :
      public IDL::common_byval_traits <CORBA::object_reference < ::Val_init>>,
      public CORBA::object_traits < ::Val_init>
    {
      static constexpr bool abstract = false;
      static constexpr bool local = true;
    };
  };

  namespace CORBA
  {
    template <>
    struct valuetype_traits< ::Val>
    {
      typedef ::Val
          base_type;
      typedef valuetype_reference< ::Val>
          ref_type;
      typedef weak_valuetype_reference< ::Val>
          weak_ref_type;
      typedef ::obv::Val
          obv_type;
      typedef ::Val_init
          factory_type;
      typedef TAOX11_IDL::traits< ::Val_init>::ref_type
          factory_ref_type;
      typedef TAOX11_IDL::traits< ::Val_init>::weak_ref_type
          weak_factory_ref_type;
      template <typename _Tp1, typename = typename
          std::enable_if<std::is_convertible< ::Val*, _Tp1*>::value>::type>
      static ref_type narrow (valuetype_reference<_Tp1> base)
      {
        return ref_type::_narrow (base);
      }
    };
  };

  namespace IDL
  {
    template<>
    struct traits < ::Val>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::Val>>,
        public CORBA::valuetype_traits < ::Val>
    {
      static constexpr bool abstract = false;
      static constexpr bool truncatable = false;
    };
  };
};
#endif // !_VALUETYPE_VAL_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuetype_pre.erb
class Val
  : public virtual TAOX11_CORBA::ValueBase
{
public:
  /// @name Member types
  //@{
  typedef TAOX11_IDL::traits< Val>               _traits_type;
  typedef TAOX11_IDL::traits< Val>::ref_type     _ref_type;
  typedef TAOX11_IDL::traits< Val>::factory_type _factory_type;
  typedef TAOX11_IDL::traits< Val>::obv_type     _obv_type;
  //@}

  static bool _obv_unmarshal (
      TAO_InputCDR &strm,
      _ref_type &vbox);


protected:
  friend class Val_init;

  typedef std::shared_ptr<Val> _shared_ptr_type;

  static const std::string __val_repository_id;

  Val () = default;
  ~Val () = default;
  Val (const Val&) = default;
  Val (Val&&) = default;
  void operator =(const Val&) = delete;
  void operator =(Val&&) = delete;

  virtual const std::string& _obv_repository_id () const override;
  virtual void _obv_get_truncatable_repo_ids (std::vector<std::string const*>&) const override;

  virtual bool _obv_match_formal_type (ptrdiff_t ) const override;

  virtual bool _obv_marshal_v (TAO_OutputCDR &) const override;
  virtual bool _obv_unmarshal_v (TAO_InputCDR &) override;
public:

  // generated from c++11/templates/cli/hdr/valuetype_post.erb
public:
  static inline const std::string& _repository_id ()
  {
    return __val_repository_id;
  }

  void swap (Val& s);

  /// @name Public state members
  //@{
  virtual void t (TAOX11_IDL::traits< Val>::ref_type _t) = 0;
  virtual TAOX11_IDL::traits< Val>::ref_type t () const = 0;
  virtual TAOX11_IDL::traits< Val>::ref_type& t () = 0;
  virtual void w (const ::Bytes& _w) = 0;
  virtual void w (::Bytes&& _w) = 0;
  virtual const ::Bytes& w () const = 0;
  virtual ::Bytes& w () = 0;
  virtual void x (const std::string& _x) = 0;
  virtual void x (std::string&& _x) = 0;
  virtual const std::string& x () const = 0;
  virtual std::string& x () = 0;
  //@}

protected:
  /// @name Private state members
  //@{
  virtual void v (int32_t _v) = 0;
  virtual int32_t v () const = 0;
  virtual int32_t& v () = 0;
  virtual void y (const ::S& _y) = 0;
  virtual void y (::S&& _y) = 0;
  virtual const ::S& y () const = 0;
  virtual ::S& y () = 0;
  virtual void z (TAOX11_IDL::traits< ::A>::ref_type _z) = 0;
  virtual TAOX11_IDL::traits< ::A>::ref_type z () const = 0;
  virtual TAOX11_IDL::traits< ::A>::ref_type& z () = 0;
  //@}

protected:
  virtual bool
  _obv_marshal_Val_v (TAO_OutputCDR &, TAO_ChunkInfo &) const = 0;

  virtual bool
  _obv_unmarshal_Val_v (TAO_InputCDR &, TAO_ChunkInfo &) = 0;
}; // Val

// generated from c++11/templates/cli/hdr/valuetype_obv.erb
namespace obv
{
  class Val
    : public virtual ::Val
  {
  protected:
    Val () = default;
    ~Val () = default;
    Val (const Val&) = default;
    Val (Val&&) = default;
    explicit Val (TAOX11_IDL::traits< ::Val>::ref_type t,
                  int32_t v,
                  ::Bytes w,
                  std::string x,
                  ::S y,
                  TAOX11_IDL::traits< ::A>::ref_type z)
      : t_ (std::move (t))
      , v_ (std::move (v))
      , w_ (std::move (w))
      , x_ (std::move (x))
      , y_ (std::move (y))
      , z_ (std::move (z))
    {}
    void operator =(const Val&) = delete;
    void operator =(Val&&) = delete;

  public:
    template <typename _Tp1, typename, typename ...Args>
    friend TAOX11_CORBA::valuetype_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

    virtual TAOX11_IDL::traits<TAOX11_CORBA::ValueBase>::ref_type
    _copy_value () const override;

    /// @name Public state members
    //@{
    virtual void t (TAOX11_IDL::traits< ::Val>::ref_type _t) override;
    virtual TAOX11_IDL::traits< ::Val>::ref_type t () const override;
    virtual TAOX11_IDL::traits< ::Val>::ref_type& t () override;

    virtual void w (const ::Bytes& _w) override;
    virtual void w (::Bytes&& _w) override;
    virtual const ::Bytes& w () const override;
    virtual ::Bytes& w () override;

    virtual void x (const std::string& _x) override;
    virtual void x (std::string&& _x) override;
    virtual const std::string& x () const override;
    virtual std::string& x () override;

    //@}
  protected:
    /// Private state members
    virtual void v (int32_t _v) override;
    virtual int32_t v () const override;
    virtual int32_t& v () override;

    virtual void y (const ::S& _y) override;
    virtual void y (::S&& _y) override;
    virtual const ::S& y () const override;
    virtual ::S& y () override;

    virtual void z (TAOX11_IDL::traits< ::A>::ref_type _z) override;
    virtual TAOX11_IDL::traits< ::A>::ref_type z () const override;
    virtual TAOX11_IDL::traits< ::A>::ref_type& z () override;

    /// Marshaling support
    virtual bool
    _obv_marshal_Val_v (TAO_OutputCDR &, TAO_ChunkInfo &) const override;

    /// Demarshaling support
    virtual bool
    _obv_unmarshal_Val_v (TAO_InputCDR &, TAO_ChunkInfo &) override;

    bool _obv_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const;
    bool _obv_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &);

  private:
    TAOX11_IDL::traits< ::Val>::ref_type t_;
    int32_t v_;
    ::Bytes w_;
    std::string x_;
    ::S y_;
    TAOX11_IDL::traits< ::A>::ref_type z_;
  }; // Val

}; // obv

// generated from c++11/templates/cli/hdr/valuetype_init.erb
class Val_init
  : public TAOX11_CORBA::ValueFactoryBase
{
public:
  typedef TAOX11_IDL::traits< Val_init>           _traits_type;
  typedef TAOX11_IDL::traits< Val_init>::ref_type _ref_type;

  template <typename T> friend struct TAOX11_CORBA::object_traits;
  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  virtual TAOX11_IDL::traits<TAOX11_CORBA::ValueBase>::ref_type
  create_for_unmarshal () override;

  virtual const std::string& _obv_repository_id () const override;

protected:
  Val_init () = default;
  ~Val_init () = default;
  Val_init (const Val_init&) = default;
  Val_init (Val_init&&) = default;
}; // Val_init

// generated from c++11/templates/cli/hdr/valuebox_fwd.erb
class StringValue;

// generated from c++11/templates/cli/hdr/valuebox_traits.erb
#if !defined (_VBOX_STRINGVALUE_TRAITS_DECL_)
#define _VBOX_STRINGVALUE_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    struct valuetype_traits< ::StringValue>
    {
      typedef valuetype_reference< ::StringValue>
          ref_type;
      typedef weak_valuetype_reference< ::StringValue>
          weak_ref_type;

      static ref_type narrow (
          valuetype_reference<ValueBase>);
    };
  };

  namespace IDL
  {
    template<>
    struct traits < ::StringValue>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::StringValue>>,
        public CORBA::valuetype_traits < ::StringValue>
    {
      typedef IDL::traits< std::string>  boxed_traits;
    };
  };
};
#endif // !_VBOX_STRINGVALUE_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuebox_def.erb
class StringValue
  : public TAOX11_CORBA::Valuebox_T< std::string>
{
public:
  /// @name Member types
  //@{
  typedef TAOX11_CORBA::valuetype_traits< StringValue>     _traits_type;
  typedef TAOX11_CORBA::valuetype_reference< StringValue>  _ref_type;
  //@}

  void _value (const std::string& v)
  { this->value_ = v; }
  void _value (std::string&& v)
  { this->value_ = std::move (v); }
  const std::string& _value () const
  { return this->value_; }
  std::string& _value ()
  { return this->value_; }

  virtual TAOX11_IDL::traits<TAOX11_CORBA::ValueBase>::ref_type
  _copy_value () const override;

  static bool _obv_unmarshal (
      TAO_InputCDR &strm,
      _ref_type &vbox);

protected:
  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::valuetype_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  static const std::string __stringvalue_repository_id;

  StringValue () = default;
  StringValue (const StringValue&) = default;
  StringValue (StringValue&&) = default;
  StringValue (std::string v)
    : TAOX11_CORBA::Valuebox_T< std::string> (v)
  {}
  ~StringValue () = default;
  void operator =(const StringValue&) = delete;
  void operator =(StringValue&&) = delete;

  virtual const std::string& _obv_repository_id () const;

  virtual bool _obv_marshal_v (TAO_OutputCDR &) const;
};

// generated from c++11/templates/cli/hdr/valuebox_traits.erb
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    inline valuetype_traits< ::StringValue>::ref_type
    valuetype_traits< ::StringValue>::narrow (
          valuetype_reference<ValueBase> vbref)
    {
      return ref_type::_narrow (vbref);
    }
  };
};

// generated from StubHeaderWriter#enter_interface

// generated from c++11/templates/cli/hdr/interface_fwd.erb
#if !defined (_INTF_X_FWD_)
#define _INTF_X_FWD_
class X;
class X_proxy;
typedef X_proxy* X_proxy_ptr;
#endif // !_INTF_X_FWD_

// generated from c++11/templates/cli/hdr/interface_object_traits.erb
#if !defined (_INTF_X_TRAITS_DECL_)
#define _INTF_X_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits< ::X>::shared_ptr_type
    object_traits< ::X>::lock_shared (
        ::X* p);
    template<>
    const Object_proxy*
    object_traits< ::X>::to_proxy (
        object_traits< ::X>::ref_type);
    template<>
    object_traits< ::X>::ref_type
    object_traits< ::X>::narrow (
       object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  };

  namespace IDL
  {
    template<>
    struct traits < ::X> :
      public IDL::common_byval_traits <CORBA::object_reference < ::X>>,
      public CORBA::object_traits < ::X>
    {
      static constexpr bool local = false;
      static constexpr bool abstract = false;
    };
  };
};
#endif // !_INTF_X_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/interface_pre.erb
class X
  : public virtual TAOX11_NAMESPACE::CORBA::Object
{
public:
  template <typename T> friend struct TAOX11_CORBA::object_traits;

  /// @name Member types
  //@{
  typedef TAOX11_IDL::traits< X>           _traits_type;
  typedef TAOX11_IDL::traits< X>::ref_type _ref_type;
  //@}

  // generated from c++11/templates/cli/hdr/operation.erb
  /// @copybrief X::op
  virtual void op (std::string& s);

  // generated from c++11/templates/cli/hdr/interface_post.erb
protected:
  typedef std::shared_ptr<X>   _shared_ptr_type;

  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  explicit X (X_proxy_ptr p);
  explicit X (X_proxy_ptr p, bool);
  X ();
  ~X () = default;

private:
  X(const X&) = delete;
  X(X&&) = delete;
  X& operator=(const X&) = delete;
  X& operator=(X&&) = delete;
  X_proxy_ptr x_proxy_;
}; // X

// generated from c++11/templates/cli/hdr/enum.erb
enum class Color : uint32_t
{
  red,
  green,
  blue
};// Color

// generated from c++11/templates/cli/hdr/valuebox_fwd.erb
class ColorValue;

// generated from c++11/templates/cli/hdr/valuebox_traits.erb
#if !defined (_VBOX_COLORVALUE_TRAITS_DECL_)
#define _VBOX_COLORVALUE_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    struct valuetype_traits< ::ColorValue>
    {
      typedef valuetype_reference< ::ColorValue>
          ref_type;
      typedef weak_valuetype_reference< ::ColorValue>
          weak_ref_type;

      static ref_type narrow (
          valuetype_reference<ValueBase>);
    };
  };

  namespace IDL
  {
    template<>
    struct traits < ::ColorValue>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::ColorValue>>,
        public CORBA::valuetype_traits < ::ColorValue>
    {
      typedef IDL::traits< ::Color>  boxed_traits;
    };
  };
};
#endif // !_VBOX_COLORVALUE_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuebox_def.erb
class ColorValue
  : public TAOX11_CORBA::Valuebox_T< ::Color>
{
public:
  /// @name Member types
  //@{
  typedef TAOX11_CORBA::valuetype_traits< ColorValue>     _traits_type;
  typedef TAOX11_CORBA::valuetype_reference< ColorValue>  _ref_type;
  //@}

  void _value (::Color v)
  { this->value_ = v; }
  ::Color _value () const
  { return this->value_; }
  ::Color& _value ()
  { return this->value_; }

  virtual TAOX11_IDL::traits<TAOX11_CORBA::ValueBase>::ref_type
  _copy_value () const override;

  static bool _obv_unmarshal (
      TAO_InputCDR &strm,
      _ref_type &vbox);

protected:
  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::valuetype_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  static const std::string __colorvalue_repository_id;

  ColorValue () = default;
  ColorValue (const ColorValue&) = default;
  ColorValue (ColorValue&&) = default;
  ColorValue (::Color v)
    : TAOX11_CORBA::Valuebox_T< ::Color> (v)
  {}
  ~ColorValue () = default;
  void operator =(const ColorValue&) = delete;
  void operator =(ColorValue&&) = delete;

  virtual const std::string& _obv_repository_id () const;

  virtual bool _obv_marshal_v (TAO_OutputCDR &) const;
};

// generated from c++11/templates/cli/hdr/valuebox_traits.erb
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    inline valuetype_traits< ::ColorValue>::ref_type
    valuetype_traits< ::ColorValue>::narrow (
          valuetype_reference<ValueBase> vbref)
    {
      return ref_type::_narrow (vbref);
    }
  };
};

// generated from c++11/templates/cli/hdr/struct_pre.erb
class ColorValue2 final
{
public:

  // generated from c++11/templates/cli/hdr/struct_post.erb
  inline ColorValue2 ();
  ~ColorValue2 () = default;
  ColorValue2 (const ColorValue2&) = default;
  ColorValue2 (ColorValue2&&) = default;
  explicit inline ColorValue2 (::Color col);
  inline ColorValue2& operator= (const ColorValue2& x);
  inline ColorValue2& operator= (ColorValue2&& x);

  inline void col (::Color _col);
  inline ::Color col () const;
  inline ::Color& col ();

  inline void swap (ColorValue2& s);

private:
  ::Color col_;
};// ColorValue2

// generated from StubHeaderWriter#enter_interface

// generated from c++11/templates/cli/hdr/interface_fwd.erb
#if !defined (_INTF_A1_FWD_)
#define _INTF_A1_FWD_
class A1;
class A1_proxy;
typedef A1_proxy* A1_proxy_ptr;
#endif // !_INTF_A1_FWD_

// generated from c++11/templates/cli/hdr/interface_object_traits.erb
#if !defined (_INTF_A1_TRAITS_DECL_)
#define _INTF_A1_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits< ::A1>::shared_ptr_type
    object_traits< ::A1>::lock_shared (
        ::A1* p);
    template<>
    const Object_proxy*
    object_traits< ::A1>::to_proxy (
        object_traits< ::A1>::ref_type);
    template<>
    object_traits< ::A1>::ref_type
    object_traits< ::A1>::narrow (
       object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  };

  namespace IDL
  {
    template<>
    struct traits < ::A1> :
      public IDL::common_byval_traits <CORBA::object_reference < ::A1>>,
      public CORBA::object_traits < ::A1>
    {
      static constexpr bool local = false;
      static constexpr bool abstract = false;
    };
  };
};
#endif // !_INTF_A1_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/interface_pre.erb
class A1
  : public virtual TAOX11_NAMESPACE::CORBA::Object
{
public:
  template <typename T> friend struct TAOX11_CORBA::object_traits;

  /// @name Member types
  //@{
  typedef TAOX11_IDL::traits< A1>           _traits_type;
  typedef TAOX11_IDL::traits< A1>::ref_type _ref_type;
  //@}

  // generated from c++11/templates/cli/hdr/operation.erb
  /// @copybrief A1::op
  virtual void op ();

  // generated from c++11/templates/cli/hdr/interface_post.erb
protected:
  typedef std::shared_ptr<A1>   _shared_ptr_type;

  template <typename _Tp1, typename, typename ...Args>
  friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  explicit A1 (A1_proxy_ptr p);
  explicit A1 (A1_proxy_ptr p, bool);
  A1 ();
  ~A1 () = default;

private:
  A1(const A1&) = delete;
  A1(A1&&) = delete;
  A1& operator=(const A1&) = delete;
  A1& operator=(A1&&) = delete;
  A1_proxy_ptr a1_proxy_;
}; // A1

// generated from c++11/templates/cli/hdr/valuetype_fwd.erb
#if !defined (_VALUETYPE_B_FWD_)
#define _VALUETYPE_B_FWD_

class B;
namespace obv
{
  class B;
};

#endif // !_VALUETYPE_B_FWD_

// generated from c++11/templates/cli/hdr/valuetype_traits.erb
#if !defined (_VALUETYPE_B_TRAITS_DECL_)
#define _VALUETYPE_B_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template <>
    struct valuetype_traits< ::B>
    {
      typedef ::B
          base_type;
      typedef valuetype_reference< ::B>
          ref_type;
      typedef weak_valuetype_reference< ::B>
          weak_ref_type;
      typedef ::obv::B
          obv_type;
      template <typename _Tp1, typename = typename
          std::enable_if<std::is_convertible< ::B*, _Tp1*>::value>::type>
      static ref_type narrow (valuetype_reference<_Tp1> base)
      {
        return ref_type::_narrow (base);
      }
    };
  };

  namespace IDL
  {
    template<>
    struct traits < ::B>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::B>>,
        public CORBA::valuetype_traits < ::B>
    {
      static constexpr bool abstract = false;
      static constexpr bool truncatable = false;
    };
  };
};
#endif // !_VALUETYPE_B_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuetype_pre.erb
class B
  : public virtual TAOX11_CORBA::ValueBase
{
public:
  /// @name Member types
  //@{
  typedef TAOX11_IDL::traits< B>               _traits_type;
  typedef TAOX11_IDL::traits< B>::ref_type     _ref_type;
  typedef TAOX11_IDL::traits< B>::obv_type     _obv_type;
  //@}

  static bool _obv_unmarshal (
      TAO_InputCDR &strm,
      _ref_type &vbox);


protected:
  typedef std::shared_ptr<B> _shared_ptr_type;

  static const std::string __b_repository_id;

  B () = default;
  ~B () = default;
  B (const B&) = default;
  B (B&&) = default;
  void operator =(const B&) = delete;
  void operator =(B&&) = delete;

  virtual const std::string& _obv_repository_id () const override;
  virtual void _obv_get_truncatable_repo_ids (std::vector<std::string const*>&) const override;

  virtual bool _obv_match_formal_type (ptrdiff_t ) const override;

  virtual bool _obv_marshal_v (TAO_OutputCDR &) const override;
  virtual bool _obv_unmarshal_v (TAO_InputCDR &) override;
public:

  // generated from c++11/templates/cli/hdr/valuetype_post.erb
public:
  static inline const std::string& _repository_id ()
  {
    return __b_repository_id;
  }

  void swap (B& s);

  // Operations

  // generated from c++11/templates/cli/hdr/operation.erb
  /// @copybrief A1::op
  virtual void op () = 0;

  /// @name Public state members
  //@{
  virtual void data (int16_t _data) = 0;
  virtual int16_t data () const = 0;
  virtual int16_t& data () = 0;
  //@}

protected:
  virtual bool
  _obv_marshal_B_v (TAO_OutputCDR &, TAO_ChunkInfo &) const = 0;

  virtual bool
  _obv_unmarshal_B_v (TAO_InputCDR &, TAO_ChunkInfo &) = 0;
}; // B

// generated from c++11/templates/cli/hdr/valuetype_obv.erb
namespace obv
{
  class B
    : public virtual ::B
  {
  protected:
    B () = default;
    ~B () = default;
    B (const B&) = default;
    B (B&&) = default;
    explicit B (int16_t data)
      : data_ (std::move (data))
    {}
    void operator =(const B&) = delete;
    void operator =(B&&) = delete;

  public:
    /// @name Public state members
    //@{
    virtual void data (int16_t _data) override;
    virtual int16_t data () const override;
    virtual int16_t& data () override;

    //@}
  protected:
    /// Marshaling support
    virtual bool
    _obv_marshal_B_v (TAO_OutputCDR &, TAO_ChunkInfo &) const override;

    /// Demarshaling support
    virtual bool
    _obv_unmarshal_B_v (TAO_InputCDR &, TAO_ChunkInfo &) override;

    bool _obv_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const;
    bool _obv_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &);

  private:
    int16_t data_;
  }; // B

}; // obv

// generated from c++11/templates/cli/hdr/valuetype_fwd.erb
#if !defined (_VALUETYPE_V_FWD_)
#define _VALUETYPE_V_FWD_

class V;
namespace obv
{
  class V;
};
class V_init;

#endif // !_VALUETYPE_V_FWD_

// generated from c++11/templates/cli/hdr/valuetype_traits.erb
#if !defined (_VALUETYPE_V_TRAITS_DECL_)
#define _VALUETYPE_V_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
     object_traits< ::V_init>::shared_ptr_type
    object_traits< ::V_init>::lock_shared (
        ::V_init*);
  };

  namespace IDL
  {
    template<>
    struct traits < ::V_init> :
      public IDL::common_byval_traits <CORBA::object_reference < ::V_init>>,
      public CORBA::object_traits < ::V_init>
    {
      static constexpr bool abstract = false;
      static constexpr bool local = true;
    };
  };

  namespace CORBA
  {
    template <>
    struct valuetype_traits< ::V>
    {
      typedef ::V
          base_type;
      typedef valuetype_reference< ::V>
          ref_type;
      typedef weak_valuetype_reference< ::V>
          weak_ref_type;
      typedef ::obv::V
          obv_type;
      typedef ::V_init
          factory_type;
      typedef TAOX11_IDL::traits< ::V_init>::ref_type
          factory_ref_type;
      typedef TAOX11_IDL::traits< ::V_init>::weak_ref_type
          weak_factory_ref_type;
      template <typename _Tp1, typename = typename
          std::enable_if<std::is_convertible< ::V*, _Tp1*>::value>::type>
      static ref_type narrow (valuetype_reference<_Tp1> base)
      {
        return ref_type::_narrow (base);
      }
    };
  };

  namespace IDL
  {
    template<>
    struct traits < ::V>
      : public IDL::common_byval_traits<CORBA::valuetype_reference< ::V>>,
        public CORBA::valuetype_traits < ::V>
    {
      static constexpr bool abstract = false;
      static constexpr bool truncatable = false;
    };
  };
};
#endif // !_VALUETYPE_V_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/valuetype_pre.erb
class V
  : public virtual TAOX11_CORBA::ValueBase
{
public:
  /// @name Member types
  //@{
  typedef TAOX11_IDL::traits< V>               _traits_type;
  typedef TAOX11_IDL::traits< V>::ref_type     _ref_type;
  typedef TAOX11_IDL::traits< V>::factory_type _factory_type;
  typedef TAOX11_IDL::traits< V>::obv_type     _obv_type;
  //@}

  static bool _obv_unmarshal (
      TAO_InputCDR &strm,
      _ref_type &vbox);


protected:
  friend class V_init;

  typedef std::shared_ptr<V> _shared_ptr_type;

  static const std::string __v_repository_id;

  V () = default;
  ~V () = default;
  V (const V&) = default;
  V (V&&) = default;
  void operator =(const V&) = delete;
  void operator =(V&&) = delete;

  virtual const std::string& _obv_repository_id () const override;
  virtual void _obv_get_truncatable_repo_ids (std::vector<std::string const*>&) const override;

  virtual bool _obv_match_formal_type (ptrdiff_t ) const override;

  virtual bool _obv_marshal_v (TAO_OutputCDR &) const override;
  virtual bool _obv_unmarshal_v (TAO_InputCDR &) override;
public:

  // generated from c++11/templates/cli/hdr/valuetype_post.erb
public:
  static inline const std::string& _repository_id ()
  {
    return __v_repository_id;
  }



protected:
  virtual bool
  _obv_marshal_V_v (TAO_OutputCDR &, TAO_ChunkInfo &) const = 0;

  virtual bool
  _obv_unmarshal_V_v (TAO_InputCDR &, TAO_ChunkInfo &) = 0;
}; // V

// generated from c++11/templates/cli/hdr/valuetype_obv.erb
namespace obv
{
  class V
    : public virtual ::V
  {
  protected:
    V () = default;
    ~V () = default;
    V (const V&) = default;
    V (V&&) = default;
    void operator =(const V&) = delete;
    void operator =(V&&) = delete;

  public:
  protected:
    /// Marshaling support
    virtual bool
    _obv_marshal_V_v (TAO_OutputCDR &, TAO_ChunkInfo &) const override;

    /// Demarshaling support
    virtual bool
    _obv_unmarshal_V_v (TAO_InputCDR &, TAO_ChunkInfo &) override;

    bool _obv_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const;
    bool _obv_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &);

  private:
  }; // V

}; // obv

// generated from c++11/templates/cli/hdr/valuetype_init.erb
class V_init
  : public TAOX11_CORBA::ValueFactoryBase
{
public:
  typedef TAOX11_IDL::traits< V_init>           _traits_type;
  typedef TAOX11_IDL::traits< V_init>::ref_type _ref_type;

  template <typename T> friend struct TAOX11_CORBA::object_traits;
  virtual TAOX11_IDL::traits< ::V>::ref_type
  create_bool (bool b) = 0;
  virtual TAOX11_IDL::traits< ::V>::ref_type
  create_char (char c) = 0;
  virtual TAOX11_IDL::traits< ::V>::ref_type
  create_octet (uint8_t o) = 0;
  virtual TAOX11_IDL::traits< ::V>::ref_type
  create_other (int16_t s,
                const std::string& p) = 0;

  virtual const std::string& _obv_repository_id () const override;

protected:
  V_init () = default;
  ~V_init () = default;
  V_init (const V_init&) = default;
  V_init (V_init&&) = default;
}; // V_init

// generated from StubHeaderTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE {
  namespace IDL {

    // generated from c++11/templates/cli/hdr/array_idl_traits.erb
    // Unaliased type : std::array< uint8_t, 64 >
    // MD5            : 765CC766CD2500C237586E8ED6B5F8D0
#if !defined(_ALIAS_765CC766CD2500C237586E8ED6B5F8D0_TRAITS_DECL_)
#define _ALIAS_765CC766CD2500C237586E8ED6B5F8D0_TRAITS_DECL_

    template<>
    struct traits < ::Bytes>
      : IDL::common_traits< ::Bytes>
    {
      typedef IDL::traits< uint8_t>  element_traits;
      static constexpr uint32_t dimensions = 1;
    };

#endif

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_S_TRAITS_)
#define _STRUCT_S_TRAITS_
    template<>
    struct traits < ::S>
      : IDL::common_traits< ::S>
    {
    };
#endif // _STRUCT_S_TRAITS_

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Color>
      : IDL::common_traits< ::Color>
    {
    };

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_COLORVALUE2_TRAITS_)
#define _STRUCT_COLORVALUE2_TRAITS_
    template<>
    struct traits < ::ColorValue2>
      : IDL::common_traits< ::ColorValue2>
    {
    };
#endif // _STRUCT_COLORVALUE2_TRAITS_
  }; // IDL
}; // TAOX11_NAMESPACE

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++11/templates/cli/hdr/valuetype_std.erb
  template <>
  void swap (::Example& m1, ::Example& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::S& m1, ::S& m2);

  // generated from c++11/templates/cli/hdr/valuetype_std.erb
  template <>
  void swap (::Val& m1, ::Val& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::ColorValue2& m1, ::ColorValue2& m2);

  // generated from c++11/templates/cli/hdr/valuetype_std.erb
  template <>
  void swap (::B& m1, ::B& m2);
}; // std

// generated from c++11/templates/cli/inl/valuetype_inl.erb
inline void
Example::swap (
  ::Example& s)
{
  std::swap (this->val1 (), s.val1 ());
  std::swap (this->val2 (), s.val2 ());
  std::swap (this->val3 (), s.val3 ());
  std::swap (this->val5 (), s.val5 ());
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline S::S ()
           : value_ (0)
{
}
inline S::S (int32_t value)
           : value_ (std::move (value))
{
}

inline void S::value (int32_t _value) { this->value_ = _value; }
inline int32_t S::value () const { return this->value_; }
inline int32_t& S::value () { return this->value_; }

inline ::S& S::operator= (const ::S& x)
{
  if (this != &x) {
    this->value_ = x.value_;
  }
  return *this;
}
inline ::S& S::operator= (::S&& x)
{
  this->value_ = std::move (x.value_);
  return *this;
}

inline void S::swap (::S& s)
{
  std::swap (this->value_, s.value_);
}

// generated from c++11/templates/cli/inl/valuetype_inl.erb
inline void
Val::swap (
  ::Val& s)
{
  std::swap (this->t (), s.t ());
  std::swap (this->v (), s.v ());
  std::swap (this->w (), s.w ());
  std::swap (this->x (), s.x ());
  std::swap (this->y (), s.y ());
  std::swap (this->z (), s.z ());
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline ColorValue2::ColorValue2 ()
           : col_ (::Color::red)
{
}
inline ColorValue2::ColorValue2 (::Color col)
           : col_ (std::move (col))
{
}

inline void ColorValue2::col (::Color _col) { this->col_ = _col; }
inline ::Color ColorValue2::col () const { return this->col_; }
inline ::Color& ColorValue2::col () { return this->col_; }

inline ::ColorValue2& ColorValue2::operator= (const ::ColorValue2& x)
{
  if (this != &x) {
    this->col_ = x.col_;
  }
  return *this;
}
inline ::ColorValue2& ColorValue2::operator= (::ColorValue2&& x)
{
  this->col_ = std::move (x.col_);
  return *this;
}

inline void ColorValue2::swap (::ColorValue2& s)
{
  std::swap (this->col_, s.col_);
}

// generated from c++11/templates/cli/inl/valuetype_inl.erb
inline void
B::swap (
  ::B& s)
{
  std::swap (this->data (), s.data ());
}

// generated from c++11/templates/cli/inl/valuetype_inl.erb

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++11/templates/cli/hdr/valuetype_std.erb
  template <>
  inline void swap (::Example& m1, ::Example& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::S& m1, ::S& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/valuetype_std.erb
  template <>
  inline void swap (::Val& m1, ::Val& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::ColorValue2& m1, ::ColorValue2& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/valuetype_std.erb
  template <>
  inline void swap (::B& m1, ::B& m2)
  {
    m1.swap (m2);
  }
}; // std

// generated from c++11/templates/cli/hdr/valuetype_os.erb
std::ostream&
operator<< (
    std::ostream& ,
    TAOX11_IDL::traits< ::Example>::ref_type);

// generated from c++11/templates/cli/hdr/array_os.erb
// Unaliased type : std::array< uint8_t, 64 >
// MD5            : 765CC766CD2500C237586E8ED6B5F8D0
#if !defined (_ALIAS_OSTREAM_765CC766CD2500C237586E8ED6B5F8D0_DECL_)
#define _ALIAS_OSTREAM_765CC766CD2500C237586E8ED6B5F8D0_DECL_

#define _ALIAS_OSTREAM_Bytes_IMPL_
std::ostream&
taox11_print_Bytes (
    std::ostream& strm ,
    const ::Bytes& _v);

inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Bytes& _v)
{
  return taox11_print_Bytes (strm, _v);
}

#endif // _ALIAS_OSTREAM_765CC766CD2500C237586E8ED6B5F8D0_DECL_

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::S&);

// generated from c++11/templates/cli/hdr/interface_os.erb
std::ostream& operator<< (
    std::ostream& strm,
    TAOX11_IDL::traits< ::A>::ref_type);

// generated from c++11/templates/cli/hdr/valuetype_os.erb
std::ostream&
operator<< (
    std::ostream& ,
    TAOX11_IDL::traits< ::Val>::ref_type);

// generated from c++11/templates/cli/hdr/valuebox_os.erb
std::ostream&
operator<< (
    std::ostream& ,
    TAOX11_IDL::traits< ::StringValue>::ref_type);

// generated from c++11/templates/cli/hdr/interface_os.erb
std::ostream& operator<< (
    std::ostream& strm,
    TAOX11_IDL::traits< ::X>::ref_type);

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Color _enumerator)
{
  switch (_enumerator) {
    case Color::red: return strm << "Color::red"; break;
    case Color::green: return strm << "Color::green"; break;
    case Color::blue: return strm << "Color::blue"; break;
    default: return strm;
  }
}

// generated from c++11/templates/cli/hdr/valuebox_os.erb
std::ostream&
operator<< (
    std::ostream& ,
    TAOX11_IDL::traits< ::ColorValue>::ref_type);

// generated from c++11/templates/cli/hdr/struct_os.erb
std::ostream&
operator<< (
    std::ostream &,
    const ::ColorValue2&);

// generated from c++11/templates/cli/hdr/interface_os.erb
std::ostream& operator<< (
    std::ostream& strm,
    TAOX11_IDL::traits< ::A1>::ref_type);

// generated from c++11/templates/cli/hdr/valuetype_os.erb
std::ostream&
operator<< (
    std::ostream& ,
    TAOX11_IDL::traits< ::B>::ref_type);

// generated from c++11/templates/cli/hdr/valuetype_os.erb
std::ostream&
operator<< (
    std::ostream& ,
    TAOX11_IDL::traits< ::V>::ref_type);

// generated from c++11/templates/cli/hdr/post.erb
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testCP.h"
#endif

#include /**/ "ace/post.h"

#endif // __RIDL_TESTC_H_0_45410861461006546_INCLUDED__

// -*- END -*-
