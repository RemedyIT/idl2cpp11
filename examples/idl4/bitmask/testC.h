/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_TESTC_H_JJIHIJCE_INCLUDED__
#define __RIDL_TESTC_H_JJIHIJCE_INCLUDED__

#pragma once

#include /**/ "tao/x11/base/pre.h"
#include "tao/x11/base/stddef.h"
#include "tao/x11/base/basic_traits.h"
#include "tao/x11/corba.h"

#include /**/ "tao/x11/base/versionx11.h"

#if TAOX11_MAJOR_VERSION != 2 || TAOX11_MINOR_VERSION != 6 || TAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (2.6.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from c++11/templates/cli/hdr/bitmask
/// @copydoc test.idl::MyBitMask
class MyBitMask
{
public:
  enum _flags : uint8_t
  {
    /// @copydoc test.idl::MyBitMask::flag0
    flag0 = 0x01 << 0,
    /// @copydoc test.idl::MyBitMask::flag1
    flag1 = 0x01 << 1,
    /// @copydoc test.idl::MyBitMask::flag2
    flag2 = 0x01 << 2
  };
  MyBitMask () = default;
  ~MyBitMask () = default;
  MyBitMask (const ::MyBitMask&) = default;
  MyBitMask (::MyBitMask&&) = default;
  MyBitMask (uint8_t _v) : _value(_v) {}
  ::MyBitMask& operator= (const ::MyBitMask&) = default;
  ::MyBitMask& operator= (::MyBitMask&&) = default;
  operator uint8_t() const { return _value; }
  ::MyBitMask& operator |= (uint8_t _taox11_rhs) { _value |= _taox11_rhs; return *this; }
  ::MyBitMask& operator &= (uint8_t _taox11_rhs) { _value &= _taox11_rhs; return *this; }
  ::MyBitMask& operator ^= (uint8_t _taox11_rhs) { _value ^= _taox11_rhs; return *this; }
private:
  uint8_t _value {};
};  // MyBitMask


// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{

  // generated from c++11/templates/cli/hdr/bitmask_idl_traits
  template<>
  struct traits <::MyBitMask>
    : IDL::common_byval_traits<::MyBitMask>
  {
    /// Underlying type of the bitmask
    using underlying_type = uint8_t;

    /// bit_bound
    using bit_bound = std::integral_constant<uint8_t, 3>;

    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::MyBitMask, OStrm_>
  {
    inline OStrm_& operator ()(OStrm_& os_, const ::MyBitMask& val_)
    {
      bool first_ {true};
      if (val_ & ::MyBitMask::flag0)
      {
        if (!first_) os_ << "|";
        os_ << "MyBitMask::flag0";
        first_ = false;
      }
      if (val_ & ::MyBitMask::flag1)
      {
        if (!first_) os_ << "|";
        os_ << "MyBitMask::flag1";
        first_ = false;
      }
      if (val_ & ::MyBitMask::flag2)
      {
        if (!first_) os_ << "|";
        os_ << "MyBitMask::flag2";
        first_ = false;
      }
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::MyBitMask>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::MyBitMask>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::MyBitMask, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::MyBitMask>::write_on (os, w.val_, formatter_t ());
  }
} // namespace TAOX11_NAMESPACE::IDL

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{
} // namespace TAOX11_NAMESPACE::IDL

// generated from c++11/templates/cli/hdr/bitmask_os
inline std::ostream& operator<< (std::ostream& strm, const ::MyBitMask& _v)
{
  return IDL::traits<::MyBitMask>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/post
#if !defined (TAOX11_DISABLE_INCLUDE_STUB_PROXY_HDR) && defined (__TAOX11_INCLUDE_STUB_PROXY__) && __has_include("testCP.h")
# include "testCP.h"
#endif

#include /**/ "tao/x11/base/post.h"

#endif /* __RIDL_TESTC_H_JJIHIJCE_INCLUDED__ */

// -*- END -*-
