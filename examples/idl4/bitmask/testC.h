/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_TESTC_H_FEAEGECH_INCLUDED__
#define __RIDL_TESTC_H_FEAEGECH_INCLUDED__

#pragma once

#include /**/ "ace/pre.h"
#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/corba_ostream.h"

#include /**/ "tao/x11/versionx11.h"

#if TAOX11_MAJOR_VERSION != 1 || TAOX11_MINOR_VERSION != 9 || TAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (1.9.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from c++11/templates/cli/hdr/bitmask
/// @copydoc test.idl::MyBitMask
enum class MyBitMask : uint8_t
{
  /// @copydoc test.idl::MyBitMask::flag0
  flag0 = 1,
  /// @copydoc test.idl::MyBitMask::flag1
  flag1 = 2,
  /// @copydoc test.idl::MyBitMask::flag2
  flag2 = 4
};// MyBitMask

inline ::MyBitMask operator~ (const ::MyBitMask& _taox11_t) { return static_cast<MyBitMask>(~static_cast<uint8_t>(_taox11_t)); }
inline ::MyBitMask operator| (const ::MyBitMask& _taox11_t, const ::MyBitMask& _taox11_y) { return static_cast<MyBitMask>(static_cast<uint8_t>(_taox11_t) | static_cast<uint8_t>(_taox11_y)); }
inline ::MyBitMask operator^ (const ::MyBitMask& _taox11_t, const ::MyBitMask& _taox11_y) { return static_cast<MyBitMask>(static_cast<uint8_t>(_taox11_t) ^ static_cast<uint8_t>(_taox11_y)); }
inline ::MyBitMask operator& (const ::MyBitMask& _taox11_t, const ::MyBitMask& _taox11_y) { return static_cast<MyBitMask>(static_cast<uint8_t>(_taox11_t) & static_cast<uint8_t>(_taox11_y)); }
inline ::MyBitMask operator |= (::MyBitMask& _taox11_lhs, const ::MyBitMask& _taox11_rhs) { _taox11_lhs = _taox11_lhs | _taox11_rhs; return _taox11_lhs; }
inline ::MyBitMask operator &= (::MyBitMask& _taox11_lhs, const ::MyBitMask& _taox11_rhs) { _taox11_lhs = _taox11_lhs & _taox11_rhs; return _taox11_lhs; }
inline ::MyBitMask operator ^= (::MyBitMask& _taox11_lhs, const ::MyBitMask& _taox11_rhs) { _taox11_lhs = _taox11_lhs ^ _taox11_rhs; return _taox11_lhs; }


// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/bitmask_idl_traits
    template<>
    struct traits <::MyBitMask>
      : IDL::common_byval_traits<::MyBitMask>
    {
      /// Underlying type of the bitmask
      using underlying_type = uint8_t;

      /// bit_bound
      using bit_bound = std::integral_constant<uint32_t, 3>;

      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter<::MyBitMask, OStrm_>
    {
      inline OStrm_& operator ()(OStrm_& os_, const ::MyBitMask& val_)
      {
        switch (val_)
        {

    //      case ::MyBitMask::flag0: os_ << "MyBitMask::flag0"; break;

    //      case ::MyBitMask::flag1: os_ << "MyBitMask::flag1"; break;

    //      case ::MyBitMask::flag2: os_ << "MyBitMask::flag2"; break;
        }
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(OStrm_& os, IDL::traits<::MyBitMask>::__Writer<Fmt> w)
    {
      using writer_t = IDL::traits<::MyBitMask>::__Writer<Fmt>;
      using formatter_t = typename std::conditional<
                            std::is_same<
                              typename writer_t::formatter_t,
                              std::false_type>::value,
                            formatter<::MyBitMask, OStrm_>,
                            typename writer_t::formatter_t>::type;
      return IDL::traits<::MyBitMask>::write_on (os, w.val_, formatter_t ());
    }
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from c++11/templates/cli/hdr/post
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testCP.h"
#endif

#include /**/ "ace/post.h"

#endif /* __RIDL_TESTC_H_FEAEGECH_INCLUDED__ */

// -*- END -*-
