/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_TESTC_H_BEHGHBGA_INCLUDED__
#define __RIDL_TESTC_H_BEHGHBGA_INCLUDED__

#pragma once

#include /**/ "ace/pre.h"
#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/corba_ostream.h"

#include /**/ "tao/x11/versionx11.h"

#if TAOX11_MAJOR_VERSION != 2 || TAOX11_MINOR_VERSION != 6 || TAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (2.6.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from c++11/templates/cli/hdr/bitmask
/// @copydoc test.idl::MyBitMask
enum class MyBitMask : uint8_t
{
  /// @copydoc test.idl::MyBitMask::flag0
  flag0 = 0x01 << 0,
  /// @copydoc test.idl::MyBitMask::flag1
  flag1 = 0x01 << 1,
  /// @copydoc test.idl::MyBitMask::flag2
  flag2 = 0x01 << 2
};// MyBitMask

inline ::MyBitMask operator~ (const ::MyBitMask& _taox11_t) { return static_cast<MyBitMask>(~static_cast<uint8_t>(_taox11_t)); }
inline ::MyBitMask operator| (const ::MyBitMask& _taox11_t, const ::MyBitMask& _taox11_y) { return static_cast<MyBitMask>(static_cast<uint8_t>(_taox11_t) | static_cast<uint8_t>(_taox11_y)); }
inline ::MyBitMask operator^ (const ::MyBitMask& _taox11_t, const ::MyBitMask& _taox11_y) { return static_cast<MyBitMask>(static_cast<uint8_t>(_taox11_t) ^ static_cast<uint8_t>(_taox11_y)); }
inline ::MyBitMask operator& (const ::MyBitMask& _taox11_t, const ::MyBitMask& _taox11_y) { return static_cast<MyBitMask>(static_cast<uint8_t>(_taox11_t) & static_cast<uint8_t>(_taox11_y)); }
inline ::MyBitMask operator |= (::MyBitMask& _taox11_lhs, const ::MyBitMask& _taox11_rhs) { _taox11_lhs = _taox11_lhs | _taox11_rhs; return _taox11_lhs; }
inline ::MyBitMask operator &= (::MyBitMask& _taox11_lhs, const ::MyBitMask& _taox11_rhs) { _taox11_lhs = _taox11_lhs & _taox11_rhs; return _taox11_lhs; }
inline ::MyBitMask operator ^= (::MyBitMask& _taox11_lhs, const ::MyBitMask& _taox11_rhs) { _taox11_lhs = _taox11_lhs ^ _taox11_rhs; return _taox11_lhs; }


// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{

  // generated from c++11/templates/cli/hdr/bitmask_idl_traits
  template<>
  struct traits <::MyBitMask>
    : IDL::common_byval_traits<::MyBitMask>
  {
    /// Underlying type of the bitmask
    using underlying_type = uint8_t;

    /// bit_bound
    using bit_bound = std::integral_constant<uint8_t, 3>;

    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::MyBitMask, OStrm_>
  {
    inline OStrm_& operator ()(OStrm_& os_, const ::MyBitMask& val_)
    {
      bool first_ {true};
      if (static_cast<bool>(val_ & ::MyBitMask::flag0))
      {
        if (!first_) os_ << "|";
        os_ << "MyBitMask::flag0";
        first_ = false;
      }
      if (static_cast<bool>(val_ & ::MyBitMask::flag1))
      {
        if (!first_) os_ << "|";
        os_ << "MyBitMask::flag1";
        first_ = false;
      }
      if (static_cast<bool>(val_ & ::MyBitMask::flag2))
      {
        if (!first_) os_ << "|";
        os_ << "MyBitMask::flag2";
        first_ = false;
      }
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::MyBitMask>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::MyBitMask>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::MyBitMask, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::MyBitMask>::write_on (os, w.val_, formatter_t ());
  }
} // namespace TAOX11_NAMESPACE::IDL

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{
} // namespace TAOX11_NAMESPACE::IDL

// generated from c++11/templates/cli/hdr/bitmask_os
inline std::ostream& operator<< (std::ostream& strm, const ::MyBitMask& _v)
{
  return IDL::traits<::MyBitMask>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/post
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testCP.h"
#endif

#include /**/ "ace/post.h"

#endif /* __RIDL_TESTC_H_BEHGHBGA_INCLUDED__ */

// -*- END -*-
