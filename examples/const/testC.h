/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_TESTC_H_HBAEBBJE_INCLUDED__
#define __RIDL_TESTC_H_HBAEBBJE_INCLUDED__

#pragma once

#include /**/ "tao/x11/base/pre.h"
#include "tao/x11/base/stddef.h"
#include "tao/x11/base/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/orb.h"
#include "tao/x11/base/bounded_string_t.h"
#include "tao/x11/base/bounded_type_traits_t.h"
#include "tao/x11/fixed_t.h"
#include "tao/x11/object.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/object_ostream.h"

#include /**/ "tao/x11/base/versionx11.h"

#if TAOX11_MAJOR_VERSION != 2 || TAOX11_MINOR_VERSION != 6 || TAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (2.6.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from StubHeaderWriter#enter_module
/// @copydoc test.idl::Test
namespace Test
{

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::ch_val
  constexpr char ch_val {'a'};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::wch_val
  constexpr wchar_t wch_val {L'X'};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::oct_val
  constexpr uint8_t oct_val {123};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::sh_val
  constexpr int16_t sh_val {-1023};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::ush_val
  constexpr uint16_t ush_val {1023U};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::l_val
  constexpr int32_t l_val {-81234};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::ul_val
  constexpr uint32_t ul_val {81234UL};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::ll_val
  constexpr int64_t ll_val {-12345678LL};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::ull_val
  constexpr uint64_t ull_val {12345678ULL};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::f_val
  constexpr float f_val {1.23F};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::d_val
  constexpr double d_val {454.23};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::ld_val
  constexpr long double ld_val {678.91L};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::b_val
  constexpr bool b_val {true};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::s_val
  const std::string s_val {"text"};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::ws_val
  const std::wstring ws_val {L"widestring\n \xbf \xfe0e"};

  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Test::TCounter
  using TCounter = int32_t;

  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Test::TName
  using TName = TAOX11_IDL::bounded_string<30>;

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::count
  constexpr TCounter count {99};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::name
  const TName name {"wilco"};

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::double_count
  constexpr TCounter double_count = (::Test::count * 2);

  // generated from c++11/templates/cli/hdr/typedef
  /// @copydoc test.idl::Test::fixed_type
  using fixed_type = TAOX11_NAMESPACE::IDL::Fixed<10, 3>;

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::Test::pi2
  const fixed_type pi2 {3.14159};
} // namespace Test


// generated from StubHeaderWriter#enter_interface

// generated from c++11/templates/cli/hdr/interface_fwd
#if !defined (_INTF_A_FWD_)
#define _INTF_A_FWD_
class A;
class A_proxy;
using A_proxy_ptr = A_proxy*;
#endif // !_INTF_A_FWD_

// generated from c++11/templates/cli/hdr/interface_object_traits
#if !defined (_INTF_A_TRAITS_DECL_)
#define _INTF_A_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits<::A>::shared_ptr_type
    object_traits<::A>::lock_shared (::A* p);
    template<>
    object_traits<::A>::ref_type
    object_traits<::A>::narrow (object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits <::A> :
      public IDL::common_byval_traits <CORBA::object_reference <::A>>,
      public CORBA::object_traits <::A>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      using is_local = std::false_type;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      using is_abstract = std::false_type;

      template <typename OStrm_, typename Formatter = formatter<::A, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_A_TRAITS_DECL_

// generated from c++11/templates/cli/hdr/interface_pre
/// @copydoc test.idl::A
class A
  : public virtual TAOX11_NAMESPACE::CORBA::Object
{
public:
  template <typename T> friend struct TAOX11_CORBA::object_traits;

  /// @name Member types
  //@{
  using _traits_type = TAOX11_IDL::traits<A>;
  /// Strong reference type
  using _ref_type = TAOX11_IDL::traits<A>::ref_type;
  //@}

  // generated from StubHeaderWriter#visit_const
  /// @copydoc test.idl::A::pi
  static constexpr float pi {3.14159F};

  // generated from c++11/templates/cli/hdr/interface_post
protected:
  using _shared_ptr_type = std::shared_ptr<A>;

  template <typename _Tp1, typename, typename ...Args>
  friend constexpr TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

  explicit A (A_proxy_ptr p, bool inherited = false);
  /// Default constructor
  A () = default;
  /// Destructor
  ~A () override = default;

private:
  /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
  //@{
  A(const A&) = delete;
  A(A&&) = delete;
  A& operator=(const A&) = delete;
  A& operator=(A&&) = delete;
  //@}
  A_proxy_ptr a_proxy_ {};
}; // class A

// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{

  // generated from c++11/templates/cli/hdr/string_idl_traits
  // Unaliased type : TAOX11_IDL::bounded_string<30>
  // MD5            : 2D6CDB195D63B04182740C35A5402ABD
#if !defined(_ALIAS_2D6CDB195D63B04182740C35A5402ABD_TRAITS_DECL_)
#define _ALIAS_2D6CDB195D63B04182740C35A5402ABD_TRAITS_DECL_

  template<>
  struct traits <TAOX11_IDL::bounded_string<30>>
    : IDL::common_traits<TAOX11_IDL::bounded_string<30>>
    , IDL::bounded_traits<TAOX11_IDL::bounded_string<30>>
  {
    /// std::false_type or std::true_type type indicating whether
    /// this string is declared as bounded
    using is_bounded = std::true_type ;
    /// IDL::traits<> for the element of the string
    using element_traits = IDL::traits<char>;

    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(
        OStrm_& os_, in_type val_,
        Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(
      OStrm_& os,
      IDL::traits<TAOX11_IDL::bounded_string<30>>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<TAOX11_IDL::bounded_string<30>>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<TAOX11_IDL::bounded_string<30>, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<TAOX11_IDL::bounded_string<30>>::write_on (os, w.val_, formatter_t ());
  }

#endif

  // generated from c++11/templates/cli/hdr/fixed_idl_traits
  // Unaliased type : TAOX11_NAMESPACE::IDL::Fixed<10, 3>
  // MD5            : 205FCC16158E634BB28F64CB9540530A
#if !defined(_ALIAS_205FCC16158E634BB28F64CB9540530A_TRAITS_DECL_)
#define _ALIAS_205FCC16158E634BB28F64CB9540530A_TRAITS_DECL_

  template<>
  struct traits <TAOX11_NAMESPACE::IDL::Fixed<10, 3>>
    : IDL::common_traits<TAOX11_NAMESPACE::IDL::Fixed<10, 3>>
  {
    using digits = std::integral_constant<uint16_t, 10>;
    using scale = std::integral_constant<uint16_t, 3>;

    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<TAOX11_NAMESPACE::IDL::Fixed<10, 3>, OStrm_>
  {
    inline OStrm_& operator ()(OStrm_& os_, const TAOX11_NAMESPACE::IDL::Fixed<10, 3>& val_)
    {
      os_ << "IDL::Fixed<10, 3> " << val_.to_string ();
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(
      OStrm_& os,
      IDL::traits<TAOX11_NAMESPACE::IDL::Fixed<10, 3>>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<TAOX11_NAMESPACE::IDL::Fixed<10, 3>>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<TAOX11_NAMESPACE::IDL::Fixed<10, 3>, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<TAOX11_NAMESPACE::IDL::Fixed<10, 3>>::write_on (os, w.val_, formatter_t ());
  }

#endif

  // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_A_TRAITS_DECL_)
#define _INTF_FMT_A_TRAITS_DECL_
  template <typename OStrm_>
  struct formatter<::A, OStrm_>
  {
    OStrm_& operator ()(OStrm_& , IDL::traits<::A>::ref_type);
  };

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::A>::__Writer<Fmt>);
#endif // !_INTF_FMT_A_TRAITS_DECL_
} // namespace TAOX11_NAMESPACE::IDL

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{

  // generated from c++11/templates/cli/hdr/interface_idl_traits_def
  template <typename OStrm_>
  inline OStrm_&
  formatter<::A, OStrm_>::operator ()(OStrm_& os_, IDL::traits<::A>::ref_type val_)
  {
    os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (std::move (val_), "A");
    return os_;
  }

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::A>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::A>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::A, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::A>::write_on (os, w.val_, formatter_t ());
  }
} // namespace TAOX11_NAMESPACE::IDL

// generated from c++11/templates/cli/hdr/fixed_os
// Unaliased type : TAOX11_NAMESPACE::IDL::Fixed<10, 3>
// MD5            : 205FCC16158E634BB28F64CB9540530A
#if !defined (_ALIAS_OSTREAM_205FCC16158E634BB28F64CB9540530A_DECL_)
#define _ALIAS_OSTREAM_205FCC16158E634BB28F64CB9540530A_DECL_

inline std::ostream& operator<< (std::ostream& strm, const TAOX11_NAMESPACE::IDL::Fixed<10, 3>& _v)
{
  return IDL::traits<TAOX11_NAMESPACE::IDL::Fixed<10, 3>>::write_on (strm, _v);
}

#endif // _ALIAS_OSTREAM_205FCC16158E634BB28F64CB9540530A_DECL_

// generated from c++11/templates/cli/hdr/interface_os
inline std::ostream& operator<< (std::ostream& strm, IDL::traits<::A>::ref_type _v)
{
  return IDL::traits<::A>::write_on (strm, std::move(_v));
}

// generated from c++11/templates/cli/hdr/post
#if !defined (TAOX11_DISABLE_INCLUDE_STUB_PROXY_HDR) && defined (__TAOX11_INCLUDE_STUB_PROXY__) && __has_include("testCP.h")
# include "testCP.h"
#endif

#include /**/ "tao/x11/base/post.h"

#endif /* __RIDL_TESTC_H_HBAEBBJE_INCLUDED__ */

// -*- END -*-
