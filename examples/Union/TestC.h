// -*- C++ -*-
/*
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT
 *        Nijkerk, GLD
 *        The Netherlands
 *        http://www.remedy.nl \ http://www.theaceorb.nl
 */

#ifndef __RIDL_TESTC_H_INCLUDED__
#define __RIDL_TESTC_H_INCLUDED__

#include <tao/0x/stddef.h>
#include <tao/0x/corba.h>

using namespace corba_0x;

// generated from StubHeaderWriter#enter_module
namespace Test {

  // generated from c++/cli_hdr/enum.erb
  enum class DataType : uint32_t
  {
    dtEmpty,
    dtLong,
    dtShort,
    dtString
  }; // DataType

  // generated from c++/cli_hdr/union_pre.erb
  class Data
  {
  public:

    // generated from c++/cli_hdr/union_post.erb
    Data (void);
    Data (const Data&);
    Data (Data&&);
    ~Data (void);
    Data &operator= (const Data&);
    Data &operator= (Data&&);

    void _d (const DataType&);
    void _d (DataType&&);
    const DataType& _d (void) const;
    DataType& _d (void);

    void longData (const int32_t& _longData);
    void longData (int32_t&& _longData);
    const int32_t& longData (void) const;
    int32_t& longData (void);

    void shortData (const int16_t& _shortData);
    void shortData (int16_t&& _shortData);
    const int16_t& shortData (void) const;
    int16_t& shortData (void);

    void stringData (const std::string& _stringData);
    void stringData (std::string&& _stringData);
    const std::string& stringData (void) const;
    std::string& stringData (void);

    void _default (void);

    void swap (Data& s);

  private:
    DataType disc_;
    union
    {
      int32_t longData_;
      int16_t shortData_;
      std::string stringData_;
    } u_;
  }; // Data

  // generated from StubHeaderWriter#enter_interface

  // generated from c++/cli_hdr/interface_fwd.erb
  class Foo_stub;
  template <typename T> class Foo_ref;
  typedef Foo_ref <Foo_stub> Foo;

  class Foo_proxy;
  typedef Foo_proxy* Foo_proxy_ptr;

  // generated from c++/cli_hdr/interface_pre.erb
  class Foo_stub
    : public virtual corba_0x::CORBA::Object_stub
  {
  public:
    friend class Foo_ref <Foo_stub>;

    virtual const std::string& _interface_repository_id () const;

    // generated from c++/cli_hdr/operation.erb
    virtual bool pass_union (const Test::Data& s);

    // generated from c++/cli_hdr/operation.erb
    virtual Test::Data return_union (void);

    // generated from c++/cli_hdr/operation.erb
    virtual bool get_union (Test::Data& s);

    // generated from c++/cli_hdr/operation.erb
    virtual bool update_union (Test::Data& s);

    // generated from c++/cli_hdr/operation.erb
    virtual void shutdown (void);

    // generated from c++/cli_hdr/interface_post.erb
  protected:
    explicit Foo_stub (Foo_proxy_ptr p);
    static Foo_stub* narrow (corba_0x::CORBA::Object_stub* obj);

  private:
    Foo_stub (void) = delete;
    Foo_stub(const Foo_stub&) = delete;
    Foo_stub& operator=(const Foo_stub&) = delete;
    Foo_proxy_ptr foo_proxy_;
    static const std::string repo_id_;
  }; // Foo_stub


  // generated from c++/cli_hdr/interface_objref.erb
  template <typename T>
  class Foo_ref
    : public virtual corba_0x::CORBA::Object_ref<T>
  {
  public:
    explicit Foo_ref (T *s = 0);
    Foo_ref (const Foo_ref<T>& o);
    operator corba_0x::CORBA::Object_ref <corba_0x::CORBA::Object_stub> ();
    void operator=(std::nullptr_t t);
    static Foo narrow(corba_0x::CORBA::Object obj);
  };
}; // namespace Test


// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (Test::Data& m1, Test::Data& m2)
  {
    m1.swap (m2);
  }
}; // std

#include "TestC.inl"

#if defined (__TAO_0X_INCLUDE_STUB_PROXY__)
#include "TestP.h"
#endif

#endif // __RIDL_TESTC_H_INCLUDED__

// -*- END -*-
