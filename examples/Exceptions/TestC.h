// -*- C++ -*-
/*
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT
 *        Nijkerk, GLD
 *        The Netherlands
 *        http://www.remedy.nl \ http://www.theaceorb.nl
 */

#ifndef __RIDL_TESTC_H_INCLUDED__
#define __RIDL_TESTC_H_INCLUDED__

#include "ace/pre.h"

#include "tao/0x/stddef.h"
#include "tao/0x/corba.h"
#include "tao/0x/system_exception.h"
#include "tao/0x/user_exception.h"
#include "tao/0x/object_member_t.h"

using namespace corba_0x;

// generated from StubHeaderWriter#enter_module
namespace Test {
  
  // generated from c++/cli_hdr/except_pre.erb
  class FooEx
   : public corba_0x::CORBA::UserException
  {
  public:
  
    virtual const char* what() const throw ();
  
    virtual void _raise (void) const;
    
    static FooEx * _downcast (corba_0x::CORBA::Exception * x);
    static FooEx const * _downcast (corba_0x::CORBA::Exception const * x);
  
    virtual void _tao_encode (TAO_OutputCDR &cdr) const;
  
    virtual void _tao_decode (TAO_InputCDR &cdr);
  
    /// Deep copy
    virtual corba_0x::CORBA::Exception *_tao_duplicate (void) const;  

    // generated from c++/cli_hdr/except_post.erb
    FooEx (void);
    virtual ~FooEx (void) throw ();
    FooEx (const FooEx&) = default;
    FooEx (FooEx&&) = default;
    explicit FooEx (std::string message);
    FooEx& operator= (const FooEx& x);
    FooEx& operator= (FooEx&& x);

    void message (const std::string& _message);
    void message (std::string&& _message);
    const std::string& message (void) const;
    std::string& message (void);

  private:
    std::string message_;
  }; // FooEx
  
  // generated from c++/cli_hdr/except_pre.erb
  class BooEx
   : public corba_0x::CORBA::UserException
  {
  public:
  
    virtual const char* what() const throw ();
  
    virtual void _raise (void) const;
    
    static BooEx * _downcast (corba_0x::CORBA::Exception * x);
    static BooEx const * _downcast (corba_0x::CORBA::Exception const * x);
  
    virtual void _tao_encode (TAO_OutputCDR &cdr) const;
  
    virtual void _tao_decode (TAO_InputCDR &cdr);
  
    /// Deep copy
    virtual corba_0x::CORBA::Exception *_tao_duplicate (void) const;  

    // generated from c++/cli_hdr/except_post.erb
    BooEx (void);
    virtual ~BooEx (void) throw ();
    BooEx (const BooEx&) = default;
    BooEx (BooEx&&) = default;
    explicit BooEx (int32_t id);
    BooEx& operator= (const BooEx& x);
    BooEx& operator= (BooEx&& x);

    void id (const int32_t& _id);
    void id (int32_t&& _id);
    const int32_t& id (void) const;
    int32_t& id (void);

  private:
    int32_t id_;
  }; // BooEx

  // generated from StubHeaderWriter#enter_interface

  // generated from c++/cli_hdr/interface_fwd.erb
#if !defined (_INTF_TEST_FOO_FWD_)
#define _INTF_TEST_FOO_FWD_
  class Foo_stub;
  class Foo_skel;
  template <typename T> class Foo_ref;
  template <typename T> class Foo_srvref;
  typedef Foo_ref <Foo_stub> Foo;
  class Foo_proxy;
  typedef Foo_proxy* Foo_proxy_ptr;

  struct Foo_traits
  {
    typedef Foo_stub stub_type;
    typedef Foo ref_type;
    typedef ref_type* ptr_type;
    typedef const ref_type* const_ptr_type;
    typedef corba_0x::CORBA::ObjMember_T<Foo_traits, ref_type>  member_type;

    static ptr_type create (const_ptr_type copy_from = nullptr);
    static void destroy (ptr_type p);
    static void swap (ref_type& r1, ref_type& r2);
  };
#endif // !_INTF_TEST_FOO_FWD_

  // generated from c++/cli_hdr/interface_pre.erb
  class Foo_stub
    : public virtual corba_0x::CORBA::Object_stub
  {
  public:
    friend class Foo_ref <Foo_stub>;

    virtual const std::string& _interface_repository_id () const;

    // generated from c++/cli_hdr/operation.erb
    void do_it (void);

    // generated from c++/cli_hdr/attribute.erb
    int32_t a_number(void);

    // generated from c++/cli_hdr/attribute.erb
    std::string a_string(void);
    void a_string(const std::string& _v);

    // generated from c++/cli_hdr/operation.erb
    void shutdown (void);

    // generated from c++/cli_hdr/interface_post.erb
    explicit Foo_stub (Foo_proxy_ptr p);
  protected:
    static Foo_stub* narrow (corba_0x::CORBA::Object_stub* obj);

  private:
    Foo_stub (void) = delete;
    Foo_stub(const Foo_stub&) = delete;
    Foo_stub& operator=(const Foo_stub&) = delete;
    Foo_proxy_ptr foo_proxy_;
  }; // Foo_stub


  // generated from c++/cli_hdr/interface_objref.erb
  template <typename T>
  class Foo_ref : public corba_0x::CORBA::ObjRef_T<T>
  {
  public:
    explicit Foo_ref (T *s = nullptr);
    Foo_ref (std::shared_ptr <T> &t);
    template<typename _Tp1, typename = typename
      std::enable_if<std::is_convertible<typename _Tp1::ref_type*, T*>::value>::type>
      Foo_ref (_Tp1 obj) : corba_0x::CORBA::ObjRef_T<T> (obj.get()) {};
    void operator=(std::nullptr_t t);
    operator corba_0x::CORBA::Object_ref <corba_0x::CORBA::Object_stub> ();
    static Foo narrow(corba_0x::CORBA::Object obj);

    typedef Foo_srvref<Foo_skel> servant_type;
    typedef Foo_skel servant_base_type;
  };
}; // namespace Test


// generated from StubHeaderStdWriter#pre_visit
namespace std {
}; // std

#include "TestC.inl"

#if defined (__TAO_0X_INCLUDE_STUB_PROXY__)
#include "TestP.h"
#endif

#include "ace/post.h"

#endif // __RIDL_TESTC_H_INCLUDED__

// -*- END -*-
