/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_TESTC_H_BIJGBDGA_INCLUDED__
#define __RIDL_TESTC_H_BIJGBDGA_INCLUDED__

#pragma once

#include /**/ "ace/pre.h"
#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/object.h"
#include "tao/x11/corba_ostream.h"

#include /**/ "tao/x11/versionx11.h"

#if TAOX11_MAJOR_VERSION != 1 || TAOX11_MINOR_VERSION != 9 || TAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (1.9.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from c++11/templates/cli/hdr/struct_pre
/// @copydoc test.idl::Global
class Global
{
public:
  // generated from c++11/templates/cli/hdr/struct_post
  Global () = default;
  ~Global () = default;
  Global (const Global&) = default;
  Global (Global&&) = default;
  /// Constructor which accepts value for all members
  explicit inline Global (
    int32_t x);
  Global& operator= (const Global&) = default;
  Global& operator= (Global&&) = default;

  /// @copydoc test.idl::Global::x
  //@{
  inline void x (int32_t _x11_x) { this->x_ = _x11_x; }
  inline int32_t x () const { return this->x_; }
  inline int32_t& x () { return this->x_; }
  //@}

  /// Exchange the value of two structures in an efficient matter
  inline void swap (Global& s);

private:
  int32_t x_{};
};// Global

inline void swap (::Global& m1, ::Global& m2) { m1.swap (m2); }


// generated from StubHeaderWriter#enter_module
/// @copydoc test.idl::Test
namespace Test
{

  // generated from c++11/templates/cli/hdr/enum
  /// @copydoc test.idl::Test::DataType
  enum class DataType : uint32_t
  {
    /// @copydoc test.idl::Test::DataType::dtEmpty
    dtEmpty,
    /// @copydoc test.idl::Test::DataType::dtLong
    dtLong,
    /// @copydoc test.idl::Test::DataType::dtShort
    dtShort,
    /// @copydoc test.idl::Test::DataType::dtString
    dtString,
    /// @copydoc test.idl::Test::DataType::dtPoint
    dtPoint,
    /// @copydoc test.idl::Test::DataType::dtTrack
    dtTrack,
    /// @copydoc test.idl::Test::DataType::dtGlobal
    dtGlobal
  };// DataType


  // generated from c++11/templates/cli/hdr/struct_pre
  /// @copydoc test.idl::Test::Point
  class Point
  {
  public:
    // generated from c++11/templates/cli/hdr/struct_post
    Point () = default;
    ~Point () = default;
    Point (const Point&) = default;
    Point (Point&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Point (
      int32_t x,
      int32_t y);
    Point& operator= (const Point&) = default;
    Point& operator= (Point&&) = default;

    /// @copydoc test.idl::Test::Point::x
    //@{
    inline void x (int32_t _x11_x) { this->x_ = _x11_x; }
    inline int32_t x () const { return this->x_; }
    inline int32_t& x () { return this->x_; }
    //@}

    /// @copydoc test.idl::Test::Point::y
    //@{
    inline void y (int32_t _x11_y) { this->y_ = _x11_y; }
    inline int32_t y () const { return this->y_; }
    inline int32_t& y () { return this->y_; }
    //@}

    /// Exchange the value of two structures in an efficient matter
    inline void swap (Point& s);

  private:
    int32_t x_{};
    int32_t y_{};
  };// Point

  inline void swap (::Test::Point& m1, ::Test::Point& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/struct_pre
  /// @copydoc test.idl::Test::Track
  class Track
  {
  public:
    // generated from c++11/templates/cli/hdr/struct_post
    Track () = default;
    ~Track () = default;
    Track (const Track&) = default;
    Track (Track&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Track (
      int32_t id,
      ::Test::Point p);
    Track& operator= (const Track&) = default;
    Track& operator= (Track&&) = default;

    /// @copydoc test.idl::Test::Track::id
    //@{
    inline void id (int32_t _x11_id) { this->id_ = _x11_id; }
    inline int32_t id () const { return this->id_; }
    inline int32_t& id () { return this->id_; }
    //@}

    /// @copydoc test.idl::Test::Track::p
    //@{
    inline void p (const ::Test::Point& _x11_p) { this->p_ = _x11_p; }
    inline void p (::Test::Point&& _x11_p) { this->p_ = std::move (_x11_p); }
    inline const ::Test::Point& p () const { return this->p_; }
    inline ::Test::Point& p () { return this->p_; }
    //@}

    /// Exchange the value of two structures in an efficient matter
    inline void swap (Track& s);

  private:
    int32_t id_{};
    ::Test::Point p_{};
  };// Track

  inline void swap (::Test::Track& m1, ::Test::Track& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/union_pre
  /// @copydoc test.idl::Test::Data
  class Data
  {
  public:

    // generated from c++11/templates/cli/hdr/union_post
    /// Default constructor creating an union initialized to
    /// the default cause
    Data () = default;
    /// Copy constructor
    inline Data (const Data&);
    /// Move constructor
    inline Data (Data&&);
    /// Destructor
    inline ~Data ();
    /// Copy assignment operator
    inline Data &operator= (const Data&);
    /// Move assignment operator
    inline Data &operator= (Data&&);

    /// Set the discriminator. Only possible to set it to a
    /// value within the same current union member, otherwise
    /// a BAD_PARAM exception is thrown
    inline void _d (DataType);
    /// Get the discriminator
    inline DataType _d () const  { return this->disc_; }

    /// @copydoc test.idl::Test::Data::longData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void longData (int32_t _x11_longData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t longData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t& longData ();
    //@}

    /// @copydoc test.idl::Test::Data::shortData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void shortData (int16_t _x11_shortData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int16_t shortData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int16_t& shortData ();
    //@}

    /// @copydoc test.idl::Test::Data::stringData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void stringData (const std::string& _x11_stringData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void stringData (std::string&& _x11_stringData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const std::string& stringData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline std::string& stringData ();
    //@}

    /// @copydoc test.idl::Test::Data::pointData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void pointData (const ::Test::Point& _x11_pointData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void pointData (::Test::Point&& _x11_pointData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Test::Point& pointData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Test::Point& pointData ();
    //@}

    /// @copydoc test.idl::Test::Data::trackData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void trackData (const ::Test::Track& _x11_trackData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void trackData (::Test::Track&& _x11_trackData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Test::Track& trackData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Test::Track& trackData ();
    //@}

    /// @copydoc test.idl::Test::Data::globalData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void globalData (const ::Global& _x11_globalData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void globalData (::Global&& _x11_globalData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Global& globalData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Global& globalData ();
    //@}

    /// Modifier that sets the union to a legal default value
    inline void _default ();

    /// Exchange the value of two unions in an efficient matter
    inline void swap (Data& u);

  private:
    inline void _swap_u (Data& u);
    inline void _move_u (Data& u);
    inline void _clear ();

    DataType disc_ {::Test::DataType::dtEmpty};
    union u_type_
    {
#if defined (_MSC_VER) && (_MSC_VER < 1930)
      u_type_ ();
#else
      u_type_ () = default;
#endif
      ~u_type_ ();
#if defined (_MSC_VER) && (_MSC_VER < 1930)
      int32_t longData_;
#else
      int32_t longData_ {};
#endif
      int16_t shortData_;
      std::string stringData_;
      ::Test::Point pointData_;
      ::Test::Track trackData_;
      ::Global globalData_;
    } u_ {};
  }; // class Data

  inline void swap (::Test::Data& m1, ::Test::Data& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/struct_pre
  /// @copydoc test.idl::Test::S
  class S
  {
  public:
    // generated from c++11/templates/cli/hdr/struct_post
    S () = default;
    ~S () = default;
    S (const S&) = default;
    S (S&&) = default;
    /// Constructor which accepts value for all members
    explicit inline S (
      int32_t len);
    S& operator= (const S&) = default;
    S& operator= (S&&) = default;

    /// @copydoc test.idl::Test::S::len
    //@{
    inline void len (int32_t _x11_len) { this->len_ = _x11_len; }
    inline int32_t len () const { return this->len_; }
    inline int32_t& len () { return this->len_; }
    //@}

    /// Exchange the value of two structures in an efficient matter
    inline void swap (S& s);

  private:
    int32_t len_{};
  };// S

  inline void swap (::Test::S& m1, ::Test::S& m2) { m1.swap (m2); }


  // generated from c++11/templates/cli/hdr/interface_fwd
#if !defined (_INTF_TEST__A_FWD_)
#define _INTF_TEST__A_FWD_
  class A;
  class A_proxy;
  using A_proxy_ptr = A_proxy*;
#endif // !_INTF_TEST__A_FWD_
  // generated from Base::CodeWriter#at_global_scope
} // namespace Test
// entering Base::CodeWriter#at_global_scope

// generated from c++11/templates/cli/hdr/interface_object_traits
#if !defined (_INTF_TEST__A_TRAITS_DECL_)
#define _INTF_TEST__A_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits<::Test::A>::shared_ptr_type
    object_traits<::Test::A>::lock_shared (::Test::A* p);
    template<>
    object_traits<::Test::A>::ref_type
    object_traits<::Test::A>::narrow (object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits <::Test::A> :
      public IDL::common_byval_traits <CORBA::object_reference <::Test::A>>,
      public CORBA::object_traits <::Test::A>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      using is_local = std::false_type;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      using is_abstract = std::false_type;

      template <typename OStrm_, typename Formatter = formatter<::Test::A, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_TEST__A_TRAITS_DECL_

// leaving Base::CodeWriter#at_global_scope
namespace Test
{

  // generated from c++11/templates/cli/hdr/union_pre
  /// @copydoc test.idl::Test::U
  class U
  {
  public:

    // generated from c++11/templates/cli/hdr/union_post
    /// Default constructor creating an union initialized to
    /// the default cause
    U () = default;
    /// Copy constructor
    inline U (const U&);
    /// Move constructor
    inline U (U&&);
    /// Destructor
    inline ~U ();
    /// Copy assignment operator
    inline U &operator= (const U&);
    /// Move assignment operator
    inline U &operator= (U&&);

    /// Set the discriminator. Only possible to set it to a
    /// value within the same current union member, otherwise
    /// a BAD_PARAM exception is thrown
    inline void _d (int32_t);
    /// Get the discriminator
    inline int32_t _d () const  { return this->disc_; }

    /// @copydoc test.idl::Test::U::x
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void x (int32_t _x11_x);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t x () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t& x ();
    //@}

    /// @copydoc test.idl::Test::U::z
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void z (const std::string& _x11_z);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void z (std::string&& _x11_z);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const std::string& z () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline std::string& z ();
    //@}

    /// @copydoc test.idl::Test::U::w
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void w (const ::Test::S& _x11_w, int32_t _x11_disc = 3);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void w (::Test::S&& _x11_w, int32_t _x11_disc = 3);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Test::S& w () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Test::S& w ();
    //@}

    /// @copydoc test.idl::Test::U::obj
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void obj (IDL::traits<::Test::A>::ref_type _x11_obj, int32_t _x11_disc = (-2147483647-1));
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline IDL::traits<::Test::A>::ref_type obj () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline IDL::traits<::Test::A>::ref_type& obj ();
    //@}

    /// Exchange the value of two unions in an efficient matter
    inline void swap (U& u);

  private:
    inline void _swap_u (U& u);
    inline void _move_u (U& u);
    inline void _clear ();

    int32_t disc_ {(-2147483647-1)};
    union u_type_
    {
#if defined (_MSC_VER) && (_MSC_VER < 1930)
      u_type_ ();
#else
      u_type_ () = default;
#endif
      ~u_type_ ();
      int32_t x_;
      std::string z_;
      ::Test::S w_;
#if defined (_MSC_VER) && (_MSC_VER < 1930)
      IDL::traits<::Test::A>::ref_type obj_;
#else
      IDL::traits<::Test::A>::ref_type obj_ {};
#endif
    } u_ {};
  }; // class U

  inline void swap (::Test::U& m1, ::Test::U& m2) { m1.swap (m2); }


  // generated from StubHeaderWriter#enter_interface

  // generated from c++11/templates/cli/hdr/interface_fwd
#if !defined (_INTF_TEST__FOO_FWD_)
#define _INTF_TEST__FOO_FWD_
  class Foo;
  class Foo_proxy;
  using Foo_proxy_ptr = Foo_proxy*;
#endif // !_INTF_TEST__FOO_FWD_
  // generated from Base::CodeWriter#at_global_scope
} // namespace Test
// entering Base::CodeWriter#at_global_scope

// generated from c++11/templates/cli/hdr/interface_object_traits
#if !defined (_INTF_TEST__FOO_TRAITS_DECL_)
#define _INTF_TEST__FOO_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits<::Test::Foo>::shared_ptr_type
    object_traits<::Test::Foo>::lock_shared (::Test::Foo* p);
    template<>
    object_traits<::Test::Foo>::ref_type
    object_traits<::Test::Foo>::narrow (object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits <::Test::Foo> :
      public IDL::common_byval_traits <CORBA::object_reference <::Test::Foo>>,
      public CORBA::object_traits <::Test::Foo>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      using is_local = std::false_type;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      using is_abstract = std::false_type;

      template <typename OStrm_, typename Formatter = formatter<::Test::Foo, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_TEST__FOO_TRAITS_DECL_

// leaving Base::CodeWriter#at_global_scope
namespace Test
{

  // generated from c++11/templates/cli/hdr/interface_pre
  /// @copydoc test.idl::Test::Foo
  class Foo
    : public virtual TAOX11_NAMESPACE::CORBA::Object
  {
  public:
    template <typename T> friend struct TAOX11_CORBA::object_traits;

    /// @name Member types
    //@{
    using _traits_type = TAOX11_IDL::traits<Foo>;
    /// Strong reference type
    using _ref_type = TAOX11_IDL::traits<Foo>::ref_type;
    //@}

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::pass_union
    virtual bool
    pass_union (
        const ::Test::Data& s);

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::return_union
    virtual ::Test::Data
    return_union ();

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::get_union
    virtual bool
    get_union (
        ::Test::Data& s);

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::update_union
    virtual bool
    update_union (
        ::Test::Data& s);

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::shutdown
    virtual void
    shutdown ();

    // generated from c++11/templates/cli/hdr/interface_post
  protected:
    using _shared_ptr_type = std::shared_ptr<Foo>;

    template <typename _Tp1, typename, typename ...Args>
    friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

    explicit Foo (Foo_proxy_ptr p, bool inherited = false);
    /// Default constructor
    Foo () = default;
    /// Destructor
    ~Foo () override = default;

  private:
    /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    //@{
    Foo(const Foo&) = delete;
    Foo(Foo&&) = delete;
    Foo& operator=(const Foo&) = delete;
    Foo& operator=(Foo&&) = delete;
    //@}
    Foo_proxy_ptr foo_proxy_ {};
  }; // class Foo

  // generated from StubHeaderWriter#enter_interface

  // generated from c++11/templates/cli/hdr/interface_pre
  /// @copydoc test.idl::Test::A
  class A
    : public virtual TAOX11_NAMESPACE::CORBA::Object
  {
  public:
    template <typename T> friend struct TAOX11_CORBA::object_traits;

    /// @name Member types
    //@{
    using _traits_type = TAOX11_IDL::traits<A>;
    /// Strong reference type
    using _ref_type = TAOX11_IDL::traits<A>::ref_type;
    //@}

    // generated from c++11/templates/cli/hdr/interface_post
  protected:
    using _shared_ptr_type = std::shared_ptr<A>;

    template <typename _Tp1, typename, typename ...Args>
    friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

    explicit A (A_proxy_ptr p, bool inherited = false);
    /// Default constructor
    A () = default;
    /// Destructor
    ~A () override = default;

  private:
    /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    //@{
    A(const A&) = delete;
    A(A&&) = delete;
    A& operator=(const A&) = delete;
    A& operator=(A&&) = delete;
    //@}
    A_proxy_ptr a_proxy_ {};
  }; // class A
} // namespace Test


// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{

  // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_GLOBAL_TRAITS_)
#define _STRUCT_GLOBAL_TRAITS_
  template<>
  struct traits <::Global>
    : IDL::common_traits<::Global>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Global, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Global>::__Writer<Fmt>);
#endif // _STRUCT_GLOBAL_TRAITS_

  // generated from c++11/templates/cli/hdr/enum_idl_traits
  template<>
  struct traits <::Test::DataType>
    : IDL::common_byval_traits<::Test::DataType>
  {
    /// Underlying type of the enum
    using underlying_type = uint32_t;

    /// bit_bound
    using bit_bound = std::integral_constant<uint32_t, 32>;

    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::DataType, OStrm_>
  {
    inline OStrm_& operator ()(OStrm_& os_, ::Test::DataType val_)
    {
      switch (val_)
      {
        case ::Test::DataType::dtEmpty: os_ << "Test::DataType::dtEmpty"; break;
        case ::Test::DataType::dtLong: os_ << "Test::DataType::dtLong"; break;
        case ::Test::DataType::dtShort: os_ << "Test::DataType::dtShort"; break;
        case ::Test::DataType::dtString: os_ << "Test::DataType::dtString"; break;
        case ::Test::DataType::dtPoint: os_ << "Test::DataType::dtPoint"; break;
        case ::Test::DataType::dtTrack: os_ << "Test::DataType::dtTrack"; break;
        case ::Test::DataType::dtGlobal: os_ << "Test::DataType::dtGlobal"; break;
      }
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::DataType>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::DataType>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::DataType, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::DataType>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_TEST__POINT_TRAITS_)
#define _STRUCT_TEST__POINT_TRAITS_
  template<>
  struct traits <::Test::Point>
    : IDL::common_traits<::Test::Point>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::Point, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::Point>::__Writer<Fmt>);
#endif // _STRUCT_TEST__POINT_TRAITS_

  // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_TEST__TRACK_TRAITS_)
#define _STRUCT_TEST__TRACK_TRAITS_
  template<>
  struct traits <::Test::Track>
    : IDL::common_traits<::Test::Track>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::Track, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::Track>::__Writer<Fmt>);
#endif // _STRUCT_TEST__TRACK_TRAITS_

  // generated from c++11/templates/cli/hdr/union_idl_traits
#if !defined (_UNION_TEST__DATA_TRAITS_)
#define _UNION_TEST__DATA_TRAITS_
  template<>
  struct traits <::Test::Data>
    : IDL::common_traits<::Test::Data>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::Data, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::Data>::__Writer<Fmt>);
#endif // _UNION_TEST__DATA_TRAITS_

  // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_TEST__S_TRAITS_)
#define _STRUCT_TEST__S_TRAITS_
  template<>
  struct traits <::Test::S>
    : IDL::common_traits<::Test::S>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::S, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::S>::__Writer<Fmt>);
#endif // _STRUCT_TEST__S_TRAITS_

  // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_TEST__A_TRAITS_DECL_)
#define _INTF_FMT_TEST__A_TRAITS_DECL_
  template <typename OStrm_>
  struct formatter<::Test::A, OStrm_>
  {
    OStrm_& operator ()(OStrm_& , IDL::traits<::Test::A>::ref_type);
  };

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::A>::__Writer<Fmt>);
#endif // !_INTF_FMT_TEST__A_TRAITS_DECL_

  // generated from c++11/templates/cli/hdr/union_idl_traits
#if !defined (_UNION_TEST__U_TRAITS_)
#define _UNION_TEST__U_TRAITS_
  template<>
  struct traits <::Test::U>
    : IDL::common_traits<::Test::U>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::U, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::U>::__Writer<Fmt>);
#endif // _UNION_TEST__U_TRAITS_

  // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_TEST__FOO_TRAITS_DECL_)
#define _INTF_FMT_TEST__FOO_TRAITS_DECL_
  template <typename OStrm_>
  struct formatter<::Test::Foo, OStrm_>
  {
    OStrm_& operator ()(OStrm_& , IDL::traits<::Test::Foo>::ref_type);
  };

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::Foo>::__Writer<Fmt>);
#endif // !_INTF_FMT_TEST__FOO_TRAITS_DECL_

  // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_TEST__A_TRAITS_DECL_)
#define _INTF_FMT_TEST__A_TRAITS_DECL_
  template <typename OStrm_>
  struct formatter<::Test::A, OStrm_>
  {
    OStrm_& operator ()(OStrm_& , IDL::traits<::Test::A>::ref_type);
  };

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::A>::__Writer<Fmt>);
#endif // !_INTF_FMT_TEST__A_TRAITS_DECL_
} // namespace TAOX11_NAMESPACE::IDL

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{

  // generated from c++11/templates/cli/hdr/struct_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Global, OStrm_>
  {
    inline OStrm_& operator ()(
        OStrm_& os_,
        const ::Global& val_)
    {
      os_ << "Global"
          << '{'
          << "x=" << IDL::traits<int32_t>::write(val_.x ())
          << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Global>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Global>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Global, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Global>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/struct_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::Point, OStrm_>
  {
    inline OStrm_& operator ()(
        OStrm_& os_,
        const ::Test::Point& val_)
    {
      os_ << "Test::Point"
          << '{'
          << "x=" << IDL::traits<int32_t>::write(val_.x ())
          << ",y=" << IDL::traits<int32_t>::write(val_.y ())
          << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::Point>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::Point>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::Point, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::Point>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/struct_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::Track, OStrm_>
  {
    inline OStrm_& operator ()(
        OStrm_& os_,
        const ::Test::Track& val_)
    {
      os_ << "Test::Track"
          << '{'
          << "id=" << IDL::traits<int32_t>::write(val_.id ())
          << ",p=" << IDL::traits<::Test::Point>::write(val_.p ())
          << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::Track>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::Track>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::Track, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::Track>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/union_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::Data, OStrm_>
  {
    inline OStrm_& operator ()(OStrm_& os_, const ::Test::Data& val_)
    {
      os_ << "Test::Data {";
      switch (val_._d ())
      {
        case ::Test::DataType::dtLong:
        {
          os_ << "longData=" << IDL::traits<int32_t>::write (val_.longData ());
        }
        break;
        case ::Test::DataType::dtShort:
        {
          os_ << "shortData=" << IDL::traits<int16_t>::write (val_.shortData ());
        }
        break;
        case ::Test::DataType::dtString:
        {
          os_ << "stringData=" << IDL::traits<std::string>::write (val_.stringData ());
        }
        break;
        case ::Test::DataType::dtPoint:
        {
          os_ << "pointData=" << IDL::traits<::Test::Point>::write (val_.pointData ());
        }
        break;
        case ::Test::DataType::dtTrack:
        {
          os_ << "trackData=" << IDL::traits<::Test::Track>::write (val_.trackData ());
        }
        break;
        case ::Test::DataType::dtGlobal:
        {
          os_ << "globalData=" << IDL::traits<::Global>::write (val_.globalData ());
        }
        break;
        default:
        break;
      }
      os_ << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(
      OStrm_& os,
      IDL::traits<::Test::Data>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::Data>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::Data, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::Data>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/struct_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::S, OStrm_>
  {
    inline OStrm_& operator ()(
        OStrm_& os_,
        const ::Test::S& val_)
    {
      os_ << "Test::S"
          << '{'
          << "len=" << IDL::traits<int32_t>::write(val_.len ())
          << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::S>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::S>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::S, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::S>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/union_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::U, OStrm_>
  {
    inline OStrm_& operator ()(OStrm_& os_, const ::Test::U& val_)
    {
      os_ << "Test::U {";
      switch (val_._d ())
      {
        case 1:
        {
          os_ << "x=" << IDL::traits<int32_t>::write (val_.x ());
        }
        break;
        case 2:
        {
          os_ << "z=" << IDL::traits<std::string>::write (val_.z ());
        }
        break;
        case 3:
        case 4:
        {
          os_ << "w=" << IDL::traits<::Test::S>::write (val_.w ());
        }
        break;
        default:
        {
          os_ << "obj=" << IDL::traits<::Test::A>::write (val_.obj ());
        }
        break;
      }
      os_ << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(
      OStrm_& os,
      IDL::traits<::Test::U>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::U>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::U, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::U>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/interface_idl_traits_def
  template <typename OStrm_>
  inline OStrm_&
  formatter<::Test::Foo, OStrm_>::operator ()(OStrm_& os_, IDL::traits<::Test::Foo>::ref_type val_)
  {
    os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (std::move (val_), "Test::Foo");
    return os_;
  }

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::Foo>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::Foo>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::Foo, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::Foo>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/interface_idl_traits_def
  template <typename OStrm_>
  inline OStrm_&
  formatter<::Test::A, OStrm_>::operator ()(OStrm_& os_, IDL::traits<::Test::A>::ref_type val_)
  {
    os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (std::move (val_), "Test::A");
    return os_;
  }

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::A>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::A>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::A, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::A>::write_on (os, w.val_, formatter_t ());
  }
} // namespace TAOX11_NAMESPACE::IDL

// generated from c++11/templates/cli/inl/struct_inl
inline ::Global::Global (
  int32_t x)
  : x_ (std::move (x))
{
}

inline void ::Global::swap (::Global& s)
{
  std::swap (this->x_, s.x_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Test::Point::Point (
  int32_t x,
  int32_t y)
  : x_ (std::move (x))
  , y_ (std::move (y))
{
}

inline void ::Test::Point::swap (::Test::Point& s)
{
  std::swap (this->x_, s.x_);
  std::swap (this->y_, s.y_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Test::Track::Track (
  int32_t id,
  ::Test::Point p)
  : id_ (std::move (id))
  , p_ (std::move (p))
{
}

inline void ::Test::Track::swap (::Test::Track& s)
{
  std::swap (this->id_, s.id_);
  std::swap (this->p_, s.p_);
}
// generated from c++11/templates/cli/inl/union_inl
#if defined (_MSC_VER) && (_MSC_VER < 1930)
inline Test::Data::u_type_::u_type_ ()
  : longData_{}
{
}
#endif

inline Test::Data::u_type_::~u_type_ ()
{
}

inline Test::Data::~Data ()
{
  this->_clear ();
}

inline Test::Data::Data (const ::Test::Data& u)
  : disc_ (u.disc_)
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
    {
      this->u_.longData_ = u.u_.longData_;
    }
    break;
    case ::Test::DataType::dtShort:
    {
      this->u_.shortData_ = u.u_.shortData_;
    }
    break;
    case ::Test::DataType::dtString:
    {
      new (std::addressof(this->u_.stringData_)) std::string (u.u_.stringData_);
    }
    break;
    case ::Test::DataType::dtPoint:
    {
      new (std::addressof(this->u_.pointData_)) ::Test::Point (u.u_.pointData_);
    }
    break;
    case ::Test::DataType::dtTrack:
    {
      new (std::addressof(this->u_.trackData_)) ::Test::Track (u.u_.trackData_);
    }
    break;
    case ::Test::DataType::dtGlobal:
    {
      new (std::addressof(this->u_.globalData_)) ::Global (u.u_.globalData_);
    }
    break;
    default:
    break;
  }
}

inline Test::Data::Data (::Test::Data&& u)
  : disc_ (std::move (u.disc_))
{
  this->_move_u (u);
}

inline void Test::Data::_d (DataType discval)
{
  if (this->disc_ != discval)
  {
    switch (this->disc_)
    {
      case ::Test::DataType::dtLong:
      {
        switch (discval)
        {
          case ::Test::DataType::dtLong:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtShort:
      {
        switch (discval)
        {
          case ::Test::DataType::dtShort:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtString:
      {
        switch (discval)
        {
          case ::Test::DataType::dtString:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtPoint:
      {
        switch (discval)
        {
          case ::Test::DataType::dtPoint:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtTrack:
      {
        switch (discval)
        {
          case ::Test::DataType::dtTrack:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtGlobal:
      {
        switch (discval)
        {
          case ::Test::DataType::dtGlobal:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      default:
      {
        switch (discval)
        {
          case ::Test::DataType::dtLong:
          case ::Test::DataType::dtShort:
          case ::Test::DataType::dtString:
          case ::Test::DataType::dtPoint:
          case ::Test::DataType::dtTrack:
          case ::Test::DataType::dtGlobal:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
          default:
            break;
        }
      }
      break;
    }
    this->disc_ = discval;
  }
}

inline void Test::Data::longData (int32_t _x11_longData)
{
  if (this->disc_ != ::Test::DataType::dtLong)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtLong;
  }
  this->u_.longData_ = _x11_longData;
}

inline int32_t Test::Data::longData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.longData_;
}

inline int32_t& Test::Data::longData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.longData_;
}

inline void Test::Data::shortData (int16_t _x11_shortData)
{
  if (this->disc_ != ::Test::DataType::dtShort)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtShort;
  }
  this->u_.shortData_ = _x11_shortData;
}

inline int16_t Test::Data::shortData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtShort:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.shortData_;
}

inline int16_t& Test::Data::shortData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtShort:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.shortData_;
}

inline void Test::Data::stringData (const std::string& _x11_stringData)
{
  if (this->disc_ != ::Test::DataType::dtString)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtString;
    new (std::addressof(this->u_.stringData_)) std::string (_x11_stringData);
  }
  else
  {
    this->u_.stringData_ = _x11_stringData;
  }
}

inline void Test::Data::stringData (std::string&& _x11_stringData)
{
  if (this->disc_ != ::Test::DataType::dtString)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtString;
    new (std::addressof(this->u_.stringData_)) std::string (std::move (_x11_stringData));
  }
  else
  {
    this->u_.stringData_ = std::move (_x11_stringData);
  }
}

inline const std::string& Test::Data::stringData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtString:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.stringData_;
}

inline std::string& Test::Data::stringData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtString:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.stringData_;
}

inline void Test::Data::pointData (const ::Test::Point& _x11_pointData)
{
  if (this->disc_ != ::Test::DataType::dtPoint)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtPoint;
    new (std::addressof(this->u_.pointData_)) ::Test::Point (_x11_pointData);
  }
  else
  {
    this->u_.pointData_ = _x11_pointData;
  }
}

inline void Test::Data::pointData (::Test::Point&& _x11_pointData)
{
  if (this->disc_ != ::Test::DataType::dtPoint)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtPoint;
    new (std::addressof(this->u_.pointData_)) ::Test::Point (std::move (_x11_pointData));
  }
  else
  {
    this->u_.pointData_ = std::move (_x11_pointData);
  }
}

inline const ::Test::Point& Test::Data::pointData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtPoint:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.pointData_;
}

inline ::Test::Point& Test::Data::pointData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtPoint:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.pointData_;
}

inline void Test::Data::trackData (const ::Test::Track& _x11_trackData)
{
  if (this->disc_ != ::Test::DataType::dtTrack)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtTrack;
    new (std::addressof(this->u_.trackData_)) ::Test::Track (_x11_trackData);
  }
  else
  {
    this->u_.trackData_ = _x11_trackData;
  }
}

inline void Test::Data::trackData (::Test::Track&& _x11_trackData)
{
  if (this->disc_ != ::Test::DataType::dtTrack)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtTrack;
    new (std::addressof(this->u_.trackData_)) ::Test::Track (std::move (_x11_trackData));
  }
  else
  {
    this->u_.trackData_ = std::move (_x11_trackData);
  }
}

inline const ::Test::Track& Test::Data::trackData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtTrack:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.trackData_;
}

inline ::Test::Track& Test::Data::trackData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtTrack:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.trackData_;
}

inline void Test::Data::globalData (const ::Global& _x11_globalData)
{
  if (this->disc_ != ::Test::DataType::dtGlobal)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtGlobal;
    new (std::addressof(this->u_.globalData_)) ::Global (_x11_globalData);
  }
  else
  {
    this->u_.globalData_ = _x11_globalData;
  }
}

inline void Test::Data::globalData (::Global&& _x11_globalData)
{
  if (this->disc_ != ::Test::DataType::dtGlobal)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtGlobal;
    new (std::addressof(this->u_.globalData_)) ::Global (std::move (_x11_globalData));
  }
  else
  {
    this->u_.globalData_ = std::move (_x11_globalData);
  }
}

inline const ::Global& Test::Data::globalData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtGlobal:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.globalData_;
}

inline ::Global& Test::Data::globalData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtGlobal:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.globalData_;
}

inline ::Test::Data& Test::Data::operator= (const ::Test::Data& u)
{
  if (this != std::addressof(u))
  {
    ::Test::Data tmp (u);
    this->swap (tmp);
  }
  return *this;
}

inline ::Test::Data& Test::Data::operator= (::Test::Data&& u)
{
  if (this != std::addressof(u))
  {
    ::Test::Data tmp (std::move (u));
    this->swap (tmp);
  }
  return *this;
}

inline void Test::Data::swap (::Test::Data& u)
{
  if (this != std::addressof(u))
  {
    if (this->disc_ != u.disc_)
    {
      // different datatypes; so use move semantics to swap efficiently through intermediary
      ::Test::Data intermediate (std::move (*this));
      this->disc_ = std::move (u.disc_);
      this->_move_u (u);
      u.disc_ = std::move (intermediate.disc_);
      u._move_u (intermediate);
    }
    else
    {
      // same datatypes so swap directly
      this->_swap_u (u);
    }
  }
}

inline void Test::Data::_swap_u (::Test::Data& u)
{
  // u_ members have been guaranteed initialized identically so simply swap data
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
    {
      std::swap (this->u_.longData_, u.u_.longData_);
    }
    break;
    case ::Test::DataType::dtShort:
    {
      std::swap (this->u_.shortData_, u.u_.shortData_);
    }
    break;
    case ::Test::DataType::dtString:
    {
      std::swap (this->u_.stringData_, u.u_.stringData_);
    }
    break;
    case ::Test::DataType::dtPoint:
    {
      std::swap (this->u_.pointData_, u.u_.pointData_);
    }
    break;
    case ::Test::DataType::dtTrack:
    {
      std::swap (this->u_.trackData_, u.u_.trackData_);
    }
    break;
    case ::Test::DataType::dtGlobal:
    {
      std::swap (this->u_.globalData_, u.u_.globalData_);
    }
    break;
    default:
    {
      std::swap (this->u_.longData_, u.u_.longData_);
    }
    break;
  }
}

inline void Test::Data::_move_u (::Test::Data& u)
{
  // this->disc_ is guaranteed to be initialized with the value from u.disc_ so it's safe
  // to move/initialize the corresponding union members
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
    {
      this->u_.longData_ = std::move (u.u_.longData_);
    }
    break;
    case ::Test::DataType::dtShort:
    {
      this->u_.shortData_ = std::move (u.u_.shortData_);
    }
    break;
    case ::Test::DataType::dtString:
    {
      new (std::addressof(this->u_.stringData_)) std::string (std::move (u.u_.stringData_));
    }
    break;
    case ::Test::DataType::dtPoint:
    {
      new (std::addressof(this->u_.pointData_)) ::Test::Point (std::move (u.u_.pointData_));
    }
    break;
    case ::Test::DataType::dtTrack:
    {
      new (std::addressof(this->u_.trackData_)) ::Test::Track (std::move (u.u_.trackData_));
    }
    break;
    case ::Test::DataType::dtGlobal:
    {
      new (std::addressof(this->u_.globalData_)) ::Global (std::move (u.u_.globalData_));
    }
    break;
    default:
    {
      this->u_.longData_ = std::move (u.u_.longData_);
    }
    break;
  }
}

inline void Test::Data::_clear ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
    break;
    case ::Test::DataType::dtShort:
    break;
    case ::Test::DataType::dtString:
    {
#if defined __clang__ && __clang_major__ <= 10
      using std::string;
#endif /* __clang__ && __clang_major__ <= 10 */
      this->u_.stringData_.std::string::~string ();
    }
    break;
    case ::Test::DataType::dtPoint:
    {
#if defined __clang__ && __clang_major__ <= 10
      using ::Test::Point;
#endif /* __clang__ && __clang_major__ <= 10 */
      this->u_.pointData_.::Test::Point::~Point ();
    }
    break;
    case ::Test::DataType::dtTrack:
    {
#if defined __clang__ && __clang_major__ <= 10
      using ::Test::Track;
#endif /* __clang__ && __clang_major__ <= 10 */
      this->u_.trackData_.::Test::Track::~Track ();
    }
    break;
    case ::Test::DataType::dtGlobal:
    {
#if defined __clang__ && __clang_major__ <= 10
      using ::Global;
#endif /* __clang__ && __clang_major__ <= 10 */
      this->u_.globalData_.::Global::~Global ();
    }
    break;
    default:
    break;
  }
}

inline void Test::Data::_default ()
{
  this->_clear ();
  this->disc_ = ::Test::DataType::dtEmpty;
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Test::S::S (
  int32_t len)
  : len_ (std::move (len))
{
}

inline void ::Test::S::swap (::Test::S& s)
{
  std::swap (this->len_, s.len_);
}
// generated from c++11/templates/cli/inl/union_inl
#if defined (_MSC_VER) && (_MSC_VER < 1930)
inline Test::U::u_type_::u_type_ ()
  : obj_{}
{
}
#endif

inline Test::U::u_type_::~u_type_ ()
{
}

inline Test::U::~U ()
{
  this->_clear ();
}

inline Test::U::U (const ::Test::U& u)
  : disc_ (u.disc_)
{
  switch (this->disc_)
  {
    case 1:
    {
      this->u_.x_ = u.u_.x_;
    }
    break;
    case 2:
    {
      new (std::addressof(this->u_.z_)) std::string (u.u_.z_);
    }
    break;
    case 3:
    case 4:
    {
      new (std::addressof(this->u_.w_)) ::Test::S (u.u_.w_);
    }
    break;
    default:
    {
      new (std::addressof(this->u_.obj_)) IDL::traits<::Test::A>::ref_type (u.u_.obj_);
    }
    break;
  }
}

inline Test::U::U (::Test::U&& u)
  : disc_ (std::move (u.disc_))
{
  this->_move_u (u);
}

inline void Test::U::_d (int32_t discval)
{
  if (this->disc_ != discval)
  {
    switch (this->disc_)
    {
      case 1:
      {
        switch (discval)
        {
          case 1:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case 2:
      {
        switch (discval)
        {
          case 2:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case 3:
      case 4:
      {
        switch (discval)
        {
          case 3:
          case 4:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      default:
      {
        switch (discval)
        {
          case 1:
          case 2:
          case 3:
          case 4:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
          default:
            break;
        }
      }
      break;
    }
    this->disc_ = discval;
  }
}

inline void Test::U::x (int32_t _x11_x)
{
  if (this->disc_ != 1)
  {
    this->_clear ();
    this->disc_ = 1;
  }
  this->u_.x_ = _x11_x;
}

inline int32_t Test::U::x () const
{
  switch (this->disc_)
  {
    case 1:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.x_;
}

inline int32_t& Test::U::x ()
{
  switch (this->disc_)
  {
    case 1:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.x_;
}

inline void Test::U::z (const std::string& _x11_z)
{
  if (this->disc_ != 2)
  {
    this->_clear ();
    this->disc_ = 2;
    new (std::addressof(this->u_.z_)) std::string (_x11_z);
  }
  else
  {
    this->u_.z_ = _x11_z;
  }
}

inline void Test::U::z (std::string&& _x11_z)
{
  if (this->disc_ != 2)
  {
    this->_clear ();
    this->disc_ = 2;
    new (std::addressof(this->u_.z_)) std::string (std::move (_x11_z));
  }
  else
  {
    this->u_.z_ = std::move (_x11_z);
  }
}

inline const std::string& Test::U::z () const
{
  switch (this->disc_)
  {
    case 2:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.z_;
}

inline std::string& Test::U::z ()
{
  switch (this->disc_)
  {
    case 2:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.z_;
}

inline void Test::U::w (const ::Test::S& _x11_w, int32_t _x11_disc)
{
  // Check whether a valid discriminator value got passed
  switch (_x11_disc)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  if (this->disc_ != _x11_disc)
  {
    this->_clear ();
    this->disc_ = _x11_disc;
    new (std::addressof(this->u_.w_)) ::Test::S (_x11_w);
  }
  else
  {
    this->u_.w_ = _x11_w;
  }
}

inline void Test::U::w (::Test::S&& _x11_w, int32_t _x11_disc)
{
  // Check whether a valid discriminator value got passed
  switch (_x11_disc)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  if (this->disc_ != _x11_disc)
  {
    this->_clear ();
    this->disc_ = _x11_disc;
    new (std::addressof(this->u_.w_)) ::Test::S (std::move (_x11_w));
  }
  else
  {
    this->u_.w_ = std::move (_x11_w);
  }
}

inline const ::Test::S& Test::U::w () const
{
  switch (this->disc_)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.w_;
}

inline ::Test::S& Test::U::w ()
{
  switch (this->disc_)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.w_;
}

inline void Test::U::obj (IDL::traits<::Test::A>::ref_type _x11_obj, int32_t _x11_disc)
{
  // Check whether a valid discriminator value got passed
  switch (_x11_disc)
  {
    case 1:
    case 2:
    case 3:
    case 4:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
    default:
      break;
  }
  if (this->disc_ != _x11_disc)
  {
    this->_clear ();
    this->disc_ = _x11_disc;
    new (std::addressof(this->u_.obj_)) IDL::traits<::Test::A>::ref_type (_x11_obj);
  }
  else
  {
    this->u_.obj_ = _x11_obj;
  }
}

inline IDL::traits<::Test::A>::ref_type Test::U::obj () const
{
  switch (this->disc_)
  {
    case 1:
    case 2:
    case 3:
    case 4:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
    default:
      break;
  }
  return this->u_.obj_;
}

inline IDL::traits<::Test::A>::ref_type& Test::U::obj ()
{
  switch (this->disc_)
  {
    case 1:
    case 2:
    case 3:
    case 4:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
    default:
      break;
  }
  return this->u_.obj_;
}

inline ::Test::U& Test::U::operator= (const ::Test::U& u)
{
  if (this != std::addressof(u))
  {
    ::Test::U tmp (u);
    this->swap (tmp);
  }
  return *this;
}

inline ::Test::U& Test::U::operator= (::Test::U&& u)
{
  if (this != std::addressof(u))
  {
    ::Test::U tmp (std::move (u));
    this->swap (tmp);
  }
  return *this;
}

inline void Test::U::swap (::Test::U& u)
{
  if (this != std::addressof(u))
  {
    if (this->disc_ != u.disc_)
    {
      // different datatypes; so use move semantics to swap efficiently through intermediary
      ::Test::U intermediate (std::move (*this));
      this->disc_ = std::move (u.disc_);
      this->_move_u (u);
      u.disc_ = std::move (intermediate.disc_);
      u._move_u (intermediate);
    }
    else
    {
      // same datatypes so swap directly
      this->_swap_u (u);
    }
  }
}

inline void Test::U::_swap_u (::Test::U& u)
{
  // u_ members have been guaranteed initialized identically so simply swap data
  switch (this->disc_)
  {
    case 1:
    {
      std::swap (this->u_.x_, u.u_.x_);
    }
    break;
    case 2:
    {
      std::swap (this->u_.z_, u.u_.z_);
    }
    break;
    case 3:
    case 4:
    {
      std::swap (this->u_.w_, u.u_.w_);
    }
    break;
    default:
    {
      std::swap (this->u_.obj_, u.u_.obj_);
    }
    break;
  }
}

inline void Test::U::_move_u (::Test::U& u)
{
  // this->disc_ is guaranteed to be initialized with the value from u.disc_ so it's safe
  // to move/initialize the corresponding union members
  switch (this->disc_)
  {
    case 1:
    {
      this->u_.x_ = std::move (u.u_.x_);
    }
    break;
    case 2:
    {
      new (std::addressof(this->u_.z_)) std::string (std::move (u.u_.z_));
    }
    break;
    case 3:
    case 4:
    {
      new (std::addressof(this->u_.w_)) ::Test::S (std::move (u.u_.w_));
    }
    break;
    default:
    {
      new (std::addressof(this->u_.obj_)) IDL::traits<::Test::A>::ref_type (std::move (u.u_.obj_));
    }
    break;
  }
}

inline void Test::U::_clear ()
{
  switch (this->disc_)
  {
    case 1:
    break;
    case 2:
    {
#if defined __clang__ && __clang_major__ <= 10
      using std::string;
#endif /* __clang__ && __clang_major__ <= 10 */
      this->u_.z_.std::string::~string ();
    }
    break;
    case 3:
    case 4:
    {
#if defined __clang__ && __clang_major__ <= 10
      using ::Test::S;
#endif /* __clang__ && __clang_major__ <= 10 */
      this->u_.w_.::Test::S::~S ();
    }
    break;
    default:
    {
      this->u_.obj_.IDL::traits<::Test::A>::ref_type::~object_reference ();
    }
    break;
  }
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream& operator<< (std::ostream& strm, const ::Global& _v)
{
  return IDL::traits<::Global>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/enum_os
inline std::ostream& operator<< (std::ostream& strm, ::Test::DataType _v)
{
  return IDL::traits<::Test::DataType>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::Point& _v)
{
  return IDL::traits<::Test::Point>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::Track& _v)
{
  return IDL::traits<::Test::Track>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/union_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::Data& _v)
{
  return IDL::traits<::Test::Data>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::S& _v)
{
  return IDL::traits<::Test::S>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/union_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::U& _v)
{
  return IDL::traits<::Test::U>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/interface_os
inline std::ostream& operator<< (std::ostream& strm, IDL::traits<::Test::Foo>::ref_type _v)
{
  return IDL::traits<::Test::Foo>::write_on (strm, std::move(_v));
}

// generated from c++11/templates/cli/hdr/interface_os
inline std::ostream& operator<< (std::ostream& strm, IDL::traits<::Test::A>::ref_type _v)
{
  return IDL::traits<::Test::A>::write_on (strm, std::move(_v));
}

// generated from c++11/templates/cli/hdr/post
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testCP.h"
#endif

#include /**/ "ace/post.h"

#endif /* __RIDL_TESTC_H_BIJGBDGA_INCLUDED__ */

// -*- END -*-
