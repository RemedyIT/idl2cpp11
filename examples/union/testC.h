// -*- C++ -*-
/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT
 *        Nijkerk, GLD
 *        The Netherlands
 *        http://www.remedy.nl \ http://www.theaceorb.nl
 */

#ifndef __RIDL_TESTC_H_JACJIBBG_INCLUDED__
#define __RIDL_TESTC_H_JACJIBBG_INCLUDED__


#include /**/ "ace/pre.h"

#include "tao/x11/stddef.h"
#include "tao/x11/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/object.h"
#include "tao/x11/corba_ostream.h"

#include "tao/x11/versionx11.h"

#if TAOX11_MAJOR_VERSION != 1 || TAOX11_MINOR_VERSION != 4 || TAOX11_BETA_VERSION != 1
#error This file was generated with another RIDL C++11 backend version (1.4.1). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from c++11/templates/cli/hdr/struct_pre.erb

/// @copydoc Global
class Global
{
public:

  // generated from c++11/templates/cli/hdr/struct_post.erb
  /// Default constructor
  Global () = default;
  /// Destructor
  ~Global () = default;
  /// Copy constructor
  Global (const Global&) = default;
  /// Move constructor
  Global (Global&&) = default;
  /// Constructor which accepts value for all members
  explicit inline Global (
    int32_t x);
  /// Copy assignment operator
  Global& operator= (const Global&) = default;
  /// Move assignment operator
  Global& operator= (Global&&) = default;

  /// @copydoc Global::x
  //@{
  inline void x (int32_t _x);
  inline int32_t x () const;
  inline int32_t& x ();
  //@}

  /// Exchange the value of two structs in an efficient matter
  inline void swap (Global& s);

private:
  int32_t x_ {};
};// Global

// generated from StubHeaderWriter#enter_module
/// @copydoc Test
namespace Test
{

  // generated from c++11/templates/cli/hdr/enum.erb

  /// @copydoc Test::DataType
  enum class DataType : uint32_t
  {
    /// @copydoc Test::DataType::dtEmpty
    dtEmpty,
    /// @copydoc Test::DataType::dtLong
    dtLong,
    /// @copydoc Test::DataType::dtShort
    dtShort,
    /// @copydoc Test::DataType::dtString
    dtString,
    /// @copydoc Test::DataType::dtPoint
    dtPoint,
    /// @copydoc Test::DataType::dtTrack
    dtTrack,
    /// @copydoc Test::DataType::dtGlobal
    dtGlobal
  };// DataType


  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Test::Point
  class Point
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    Point () = default;
    /// Destructor
    ~Point () = default;
    /// Copy constructor
    Point (const Point&) = default;
    /// Move constructor
    Point (Point&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Point (
      int32_t x,
      int32_t y);
    /// Copy assignment operator
    Point& operator= (const Point&) = default;
    /// Move assignment operator
    Point& operator= (Point&&) = default;

    /// @copydoc Test::Point::x
    //@{
    inline void x (int32_t _x);
    inline int32_t x () const;
    inline int32_t& x ();
    //@}

    /// @copydoc Test::Point::y
    //@{
    inline void y (int32_t _y);
    inline int32_t y () const;
    inline int32_t& y ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (Point& s);

  private:
    int32_t x_ {};
    int32_t y_ {};
  };// Point

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Test::Track
  class Track
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    Track () = default;
    /// Destructor
    ~Track () = default;
    /// Copy constructor
    Track (const Track&) = default;
    /// Move constructor
    Track (Track&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Track (
      int32_t id,
      ::Test::Point p);
    /// Copy assignment operator
    Track& operator= (const Track&) = default;
    /// Move assignment operator
    Track& operator= (Track&&) = default;

    /// @copydoc Test::Track::id
    //@{
    inline void id (int32_t _id);
    inline int32_t id () const;
    inline int32_t& id ();
    //@}

    /// @copydoc Test::Track::p
    //@{
    inline void p (const ::Test::Point& _p);
    inline void p (::Test::Point&& _p);
    inline const ::Test::Point& p () const;
    inline ::Test::Point& p ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (Track& s);

  private:
    int32_t id_ {};
    ::Test::Point p_;
  };// Track

  // generated from c++11/templates/cli/hdr/union_pre.erb

  /// @copydoc Test::Data
  class Data
  {
  public:

    // generated from c++11/templates/cli/hdr/union_post.erb
    /// Default constructor creating an union initialized to
    /// the default cause
    inline Data ();
    /// Copy constructor
    inline Data (const Data&);
    /// Move constructor
    inline Data (Data&&);
    /// Destructor
    inline ~Data ();
    /// Copy assignment operator
    inline Data &operator= (const Data&);
    /// Move assignment operator
    inline Data &operator= (Data&&);

    /// Set the discriminator. Only possible to set it to a
    /// value within the same current union member, otherwise
    /// a BAD_PARAM exception is thrown
    inline void _d (DataType);
    /// Get the discriminator
    inline DataType _d () const;

    /// @copydoc Test::Data::longData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void longData (int32_t _longData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t longData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t& longData ();
    //@}

    /// @copydoc Test::Data::shortData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void shortData (int16_t _shortData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int16_t shortData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int16_t& shortData ();
    //@}

    /// @copydoc Test::Data::stringData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void stringData (const std::string& _stringData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void stringData (std::string&& _stringData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const std::string& stringData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline std::string& stringData ();
    //@}

    /// @copydoc Test::Data::pointData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void pointData (const ::Test::Point& _pointData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void pointData (::Test::Point&& _pointData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Test::Point& pointData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Test::Point& pointData ();
    //@}

    /// @copydoc Test::Data::trackData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void trackData (const ::Test::Track& _trackData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void trackData (::Test::Track&& _trackData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Test::Track& trackData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Test::Track& trackData ();
    //@}

    /// @copydoc Test::Data::globalData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void globalData (const ::Global& _globalData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void globalData (::Global&& _globalData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Global& globalData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Global& globalData ();
    //@}

    /// Modifier that sets the union to a legal default value
    inline void _default ();

    /// Exchange the value of two unions in an efficient matter
    inline void swap (Data& u);

  private:
    inline void _swap_u (Data& u);
    inline void _move_u (Data& u);
    inline void _clear ();

    DataType disc_ {::Test::DataType::dtEmpty};
    union u_type_
    {
      u_type_ ();
      ~u_type_ ();
      int32_t longData_;
      int16_t shortData_;
      std::string stringData_;
      ::Test::Point pointData_;
      ::Test::Track trackData_;
      ::Global globalData_;
    } u_ {};
  }; // Data

  // generated from c++11/templates/cli/hdr/struct_pre.erb

  /// @copydoc Test::S
  class S
  {
  public:

    // generated from c++11/templates/cli/hdr/struct_post.erb
    /// Default constructor
    S () = default;
    /// Destructor
    ~S () = default;
    /// Copy constructor
    S (const S&) = default;
    /// Move constructor
    S (S&&) = default;
    /// Constructor which accepts value for all members
    explicit inline S (
      int32_t len);
    /// Copy assignment operator
    S& operator= (const S&) = default;
    /// Move assignment operator
    S& operator= (S&&) = default;

    /// @copydoc Test::S::len
    //@{
    inline void len (int32_t _len);
    inline int32_t len () const;
    inline int32_t& len ();
    //@}

    /// Exchange the value of two structs in an efficient matter
    inline void swap (S& s);

  private:
    int32_t len_ {};
  };// S

  // generated from c++11/templates/cli/hdr/interface_fwd.erb
#if !defined (_INTF_TEST_A_FWD_)
#define _INTF_TEST_A_FWD_
  class A;
  class A_proxy;
  typedef A_proxy* A_proxy_ptr;
#endif // !_INTF_TEST_A_FWD_
  // generated from Base::CodeWriter#at_global_scope
} // namespace Test
// entering Base::CodeWriter#at_global_scope

// generated from c++11/templates/cli/hdr/interface_object_traits.erb
#if !defined (_INTF_TEST_A_TRAITS_DECL_)
#define _INTF_TEST_A_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits< ::Test::A>::shared_ptr_type
    object_traits< ::Test::A>::lock_shared (
        ::Test::A* p);
    template<>
    const Object_proxy*
    object_traits< ::Test::A>::to_proxy (
        object_traits< ::Test::A>::ref_type);
    template<>
    object_traits< ::Test::A>::ref_type
    object_traits< ::Test::A>::narrow (
       object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::Test::A> :
      public IDL::common_byval_traits <CORBA::object_reference < ::Test::A>>,
      public CORBA::object_traits < ::Test::A>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      typedef std::false_type is_local;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      typedef std::false_type is_abstract;

      template <typename OStrm_, typename Formatter = formatter< ::Test::A, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_TEST_A_TRAITS_DECL_

// leaving Base::CodeWriter#at_global_scope
namespace Test
{

  // generated from c++11/templates/cli/hdr/union_pre.erb

  /// @copydoc Test::U
  class U
  {
  public:

    // generated from c++11/templates/cli/hdr/union_post.erb
    /// Default constructor creating an union initialized to
    /// the default cause
    inline U ();
    /// Copy constructor
    inline U (const U&);
    /// Move constructor
    inline U (U&&);
    /// Destructor
    inline ~U ();
    /// Copy assignment operator
    inline U &operator= (const U&);
    /// Move assignment operator
    inline U &operator= (U&&);

    /// Set the discriminator. Only possible to set it to a
    /// value within the same current union member, otherwise
    /// a BAD_PARAM exception is thrown
    inline void _d (int32_t);
    /// Get the discriminator
    inline int32_t _d () const;

    /// @copydoc Test::U::x
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void x (int32_t _x);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t x () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t& x ();
    //@}

    /// @copydoc Test::U::z
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void z (const std::string& _z);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void z (std::string&& _z);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const std::string& z () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline std::string& z ();
    //@}

    /// @copydoc Test::U::w
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void w (const ::Test::S& _w);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void w (::Test::S&& _w);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Test::S& w () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Test::S& w ();
    //@}

    /// @copydoc Test::U::obj
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void obj (IDL::traits< ::Test::A>::ref_type _obj);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline IDL::traits< ::Test::A>::ref_type obj () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline IDL::traits< ::Test::A>::ref_type& obj ();
    //@}

    /// Exchange the value of two unions in an efficient matter
    inline void swap (U& u);

  private:
    inline void _swap_u (U& u);
    inline void _move_u (U& u);
    inline void _clear ();

    int32_t disc_ {(-2147483647-1)};
    union u_type_
    {
      u_type_ ();
      ~u_type_ ();
      int32_t x_;
      std::string z_;
      ::Test::S w_;
      IDL::traits< ::Test::A>::ref_type obj_;
    } u_ {};
  }; // U

  // generated from StubHeaderWriter#enter_interface

  // generated from c++11/templates/cli/hdr/interface_fwd.erb
#if !defined (_INTF_TEST_FOO_FWD_)
#define _INTF_TEST_FOO_FWD_
  class Foo;
  class Foo_proxy;
  typedef Foo_proxy* Foo_proxy_ptr;
#endif // !_INTF_TEST_FOO_FWD_
  // generated from Base::CodeWriter#at_global_scope
} // namespace Test
// entering Base::CodeWriter#at_global_scope

// generated from c++11/templates/cli/hdr/interface_object_traits.erb
#if !defined (_INTF_TEST_FOO_TRAITS_DECL_)
#define _INTF_TEST_FOO_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits< ::Test::Foo>::shared_ptr_type
    object_traits< ::Test::Foo>::lock_shared (
        ::Test::Foo* p);
    template<>
    const Object_proxy*
    object_traits< ::Test::Foo>::to_proxy (
        object_traits< ::Test::Foo>::ref_type);
    template<>
    object_traits< ::Test::Foo>::ref_type
    object_traits< ::Test::Foo>::narrow (
       object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits < ::Test::Foo> :
      public IDL::common_byval_traits <CORBA::object_reference < ::Test::Foo>>,
      public CORBA::object_traits < ::Test::Foo>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      typedef std::false_type is_local;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      typedef std::false_type is_abstract;

      template <typename OStrm_, typename Formatter = formatter< ::Test::Foo, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_TEST_FOO_TRAITS_DECL_

// leaving Base::CodeWriter#at_global_scope
namespace Test
{

  // generated from c++11/templates/cli/hdr/interface_pre.erb
  /// @copydoc Test::Foo
  class Foo
    : public virtual TAOX11_NAMESPACE::CORBA::Object
  {
  public:
    template <typename T> friend struct TAOX11_CORBA::object_traits;

    /// @name Member types
    //@{
    typedef TAOX11_IDL::traits< Foo>           _traits_type;
    /// Strong reference type
    typedef TAOX11_IDL::traits< Foo>::ref_type _ref_type;
    //@}

    // generated from c++11/templates/cli/hdr/operation.erb
    /// @copydoc Test::Foo::pass_union
    virtual
    bool
    pass_union (
        const ::Test::Data& s);

    // generated from c++11/templates/cli/hdr/operation.erb
    /// @copydoc Test::Foo::return_union
    virtual
    ::Test::Data
    return_union ();

    // generated from c++11/templates/cli/hdr/operation.erb
    /// @copydoc Test::Foo::get_union
    virtual
    bool
    get_union (
        ::Test::Data& s);

    // generated from c++11/templates/cli/hdr/operation.erb
    /// @copydoc Test::Foo::update_union
    virtual
    bool
    update_union (
        ::Test::Data& s);

    // generated from c++11/templates/cli/hdr/operation.erb
    /// @copydoc Test::Foo::shutdown
    virtual
    void
    shutdown ();

    // generated from c++11/templates/cli/hdr/interface_post.erb
  protected:
    typedef std::shared_ptr<Foo>   _shared_ptr_type;

    template <typename _Tp1, typename, typename ...Args>
    friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

    explicit Foo (Foo_proxy_ptr p);
    explicit Foo (Foo_proxy_ptr p, bool);
    /// Default constructor
    Foo () = default;
    /// Destructor
    ~Foo () = default;

  private:
    /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    //@{
    Foo(const Foo&) = delete;
    Foo(Foo&&) = delete;
    Foo& operator=(const Foo&) = delete;
    Foo& operator=(Foo&&) = delete;
    Foo_proxy_ptr foo_proxy_ {};
    //@}
  }; // Foo

  // generated from StubHeaderWriter#enter_interface

  // generated from c++11/templates/cli/hdr/interface_pre.erb
  /// @copydoc Test::A
  class A
    : public virtual TAOX11_NAMESPACE::CORBA::Object
  {
  public:
    template <typename T> friend struct TAOX11_CORBA::object_traits;

    /// @name Member types
    //@{
    typedef TAOX11_IDL::traits< A>           _traits_type;
    /// Strong reference type
    typedef TAOX11_IDL::traits< A>::ref_type _ref_type;
    //@}

    // generated from c++11/templates/cli/hdr/interface_post.erb
  protected:
    typedef std::shared_ptr<A>   _shared_ptr_type;

    template <typename _Tp1, typename, typename ...Args>
    friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

    explicit A (A_proxy_ptr p);
    explicit A (A_proxy_ptr p, bool);
    /// Default constructor
    A () = default;
    /// Destructor
    ~A () = default;

  private:
    /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    //@{
    A(const A&) = delete;
    A(A&&) = delete;
    A& operator=(const A&) = delete;
    A& operator=(A&&) = delete;
    A_proxy_ptr a_proxy_ {};
    //@}
  }; // A
} // namespace Test


// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_GLOBAL_TRAITS_)
#define _STRUCT_GLOBAL_TRAITS_
    template<>
    struct traits < ::Global>
      : IDL::common_traits< ::Global>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Global, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Global>::__Writer<Fmt>);
#endif // _STRUCT_GLOBAL_TRAITS_

    // generated from c++11/templates/cli/hdr/enum_idl_traits.erb
    template<>
    struct traits < ::Test::DataType>
      : IDL::common_traits< ::Test::DataType>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Test::DataType, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          ::Test::DataType val_)
      {
        switch (val_)
        {
          case Test::DataType::dtEmpty: os_ << "Test::DataType::dtEmpty"; break;
          case Test::DataType::dtLong: os_ << "Test::DataType::dtLong"; break;
          case Test::DataType::dtShort: os_ << "Test::DataType::dtShort"; break;
          case Test::DataType::dtString: os_ << "Test::DataType::dtString"; break;
          case Test::DataType::dtPoint: os_ << "Test::DataType::dtPoint"; break;
          case Test::DataType::dtTrack: os_ << "Test::DataType::dtTrack"; break;
          case Test::DataType::dtGlobal: os_ << "Test::DataType::dtGlobal"; break;
        }
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Test::DataType>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Test::DataType>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Test::DataType, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Test::DataType>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_TEST_POINT_TRAITS_)
#define _STRUCT_TEST_POINT_TRAITS_
    template<>
    struct traits < ::Test::Point>
      : IDL::common_traits< ::Test::Point>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Test::Point, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Test::Point>::__Writer<Fmt>);
#endif // _STRUCT_TEST_POINT_TRAITS_

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_TEST_TRACK_TRAITS_)
#define _STRUCT_TEST_TRACK_TRAITS_
    template<>
    struct traits < ::Test::Track>
      : IDL::common_traits< ::Test::Track>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Test::Track, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Test::Track>::__Writer<Fmt>);
#endif // _STRUCT_TEST_TRACK_TRAITS_

    // generated from c++11/templates/cli/hdr/union_idl_traits.erb
#if !defined (_UNION_TEST_DATA_TRAITS_)
#define _UNION_TEST_DATA_TRAITS_
    template<>
    struct traits < ::Test::Data>
      : IDL::common_traits< ::Test::Data>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Test::Data, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Test::Data>::__Writer<Fmt>);
#endif // _UNION_TEST_DATA_TRAITS_

    // generated from c++11/templates/cli/hdr/struct_idl_traits.erb
#if !defined (_STRUCT_TEST_S_TRAITS_)
#define _STRUCT_TEST_S_TRAITS_
    template<>
    struct traits < ::Test::S>
      : IDL::common_traits< ::Test::S>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Test::S, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Test::S>::__Writer<Fmt>);
#endif // _STRUCT_TEST_S_TRAITS_

    // generated from c++11/templates/cli/hdr/interface_idl_traits.erb
#if !defined (_INTF_FMT_TEST_A_TRAITS_DECL_)
#define _INTF_FMT_TEST_A_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::Test::A, OStrm_>
    {
      OStrm_& operator ()(
          OStrm_& ,
          IDL::traits< ::Test::A>::ref_type);
    };

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Test::A>::__Writer<Fmt>);
#endif // !_INTF_FMT_TEST_A_TRAITS_DECL_

    // generated from c++11/templates/cli/hdr/union_idl_traits.erb
#if !defined (_UNION_TEST_U_TRAITS_)
#define _UNION_TEST_U_TRAITS_
    template<>
    struct traits < ::Test::U>
      : IDL::common_traits< ::Test::U>
    {
      template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };

    template <typename OStrm_>
    struct formatter< ::Test::U, OStrm_>;

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Test::U>::__Writer<Fmt>);
#endif // _UNION_TEST_U_TRAITS_

    // generated from c++11/templates/cli/hdr/interface_idl_traits.erb
#if !defined (_INTF_FMT_TEST_FOO_TRAITS_DECL_)
#define _INTF_FMT_TEST_FOO_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::Test::Foo, OStrm_>
    {
      OStrm_& operator ()(
          OStrm_& ,
          IDL::traits< ::Test::Foo>::ref_type);
    };

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Test::Foo>::__Writer<Fmt>);
#endif // !_INTF_FMT_TEST_FOO_TRAITS_DECL_

    // generated from c++11/templates/cli/hdr/interface_idl_traits.erb
#if !defined (_INTF_FMT_TEST_A_TRAITS_DECL_)
#define _INTF_FMT_TEST_A_TRAITS_DECL_
    template <typename OStrm_>
    struct formatter< ::Test::A, OStrm_>
    {
      OStrm_& operator ()(
          OStrm_& ,
          IDL::traits< ::Test::A>::ref_type);
    };

    template <typename OStrm_, typename Fmt>
    OStrm_& operator <<(
        OStrm_&,
        IDL::traits< ::Test::A>::__Writer<Fmt>);
#endif // !_INTF_FMT_TEST_A_TRAITS_DECL_
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE
{
  namespace IDL
  {

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Global, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Global& val_)
      {
        os_ << "Global"
            << '{'
            << "x=" << IDL::traits< int32_t>::write(val_.x ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Global>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Global>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Global, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Global>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Test::Point, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Test::Point& val_)
      {
        os_ << "Test::Point"
            << '{'
            << "x=" << IDL::traits< int32_t>::write(val_.x ())
            << ",y=" << IDL::traits< int32_t>::write(val_.y ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Test::Point>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Test::Point>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Test::Point, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Test::Point>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Test::Track, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Test::Track& val_)
      {
        os_ << "Test::Track"
            << '{'
            << "id=" << IDL::traits< int32_t>::write(val_.id ())
            << ",p=" << IDL::traits< ::Test::Point>::write(val_.p ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Test::Track>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Test::Track>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Test::Track, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Test::Track>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/union_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Test::Data, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Test::Data& val_)
      {
        os_ << "Test::Data {";
        switch (val_._d ())
        {
          case ::Test::DataType::dtLong:
          {
            os_ << "longData=" << IDL::traits< int32_t>::write (val_.longData ());
          }
          break;
          case ::Test::DataType::dtShort:
          {
            os_ << "shortData=" << IDL::traits< int16_t>::write (val_.shortData ());
          }
          break;
          case ::Test::DataType::dtString:
          {
            os_ << "stringData=" << IDL::traits< std::string>::write (val_.stringData ());
          }
          break;
          case ::Test::DataType::dtPoint:
          {
            os_ << "pointData=" << IDL::traits< ::Test::Point>::write (val_.pointData ());
          }
          break;
          case ::Test::DataType::dtTrack:
          {
            os_ << "trackData=" << IDL::traits< ::Test::Track>::write (val_.trackData ());
          }
          break;
          case ::Test::DataType::dtGlobal:
          {
            os_ << "globalData=" << IDL::traits< ::Global>::write (val_.globalData ());
          }
          break;
          default:
          break;
        }
        os_ << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Test::Data>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Test::Data>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Test::Data, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Test::Data>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/struct_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Test::S, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Test::S& val_)
      {
        os_ << "Test::S"
            << '{'
            << "len=" << IDL::traits< int32_t>::write(val_.len ())
            << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Test::S>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Test::S>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Test::S, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Test::S>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/union_idl_traits_def.erb
    template <typename OStrm_>
    struct formatter< ::Test::U, OStrm_>
    {
      inline OStrm_& operator ()(
          OStrm_& os_,
          const ::Test::U& val_)
      {
        os_ << "Test::U {";
        switch (val_._d ())
        {
          case 1:
          {
            os_ << "x=" << IDL::traits< int32_t>::write (val_.x ());
          }
          break;
          case 2:
          {
            os_ << "z=" << IDL::traits< std::string>::write (val_.z ());
          }
          break;
          case 3:
          case 4:
          {
            os_ << "w=" << IDL::traits< ::Test::S>::write (val_.w ());
          }
          break;
          default:
          {
            os_ << "obj=" << IDL::traits< ::Test::A>::write (val_.obj ());
          }
          break;
        }
        os_ << '}';
        return os_;
      }
    };

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Test::U>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Test::U>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Test::U, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Test::U>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/interface_idl_traits_def.erb
    template <typename OStrm_>
    inline OStrm_&
    formatter< ::Test::Foo, OStrm_>::operator ()(
          OStrm_& os_,
          IDL::traits< ::Test::Foo>::ref_type val_)
    {
      os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (
               val_,
               "Test::Foo");
      return os_;
    }

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Test::Foo>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Test::Foo>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Test::Foo, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Test::Foo>::write_on (
          os, w.val_,
          formatter_t ());
    }

    // generated from c++11/templates/cli/hdr/interface_idl_traits_def.erb
    template <typename OStrm_>
    inline OStrm_&
    formatter< ::Test::A, OStrm_>::operator ()(
          OStrm_& os_,
          IDL::traits< ::Test::A>::ref_type val_)
    {
      os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (
               val_,
               "Test::A");
      return os_;
    }

    template <typename OStrm_, typename Fmt>
    inline OStrm_& operator <<(
        OStrm_& os,
        IDL::traits< ::Test::A>::__Writer<Fmt> w)
    {
      typedef IDL::traits< ::Test::A>::__Writer<Fmt> writer_t;
      typedef typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter< ::Test::A, OStrm_>,
                          typename writer_t::formatter_t>::type formatter_t;
      return IDL::traits< ::Test::A>::write_on (
          os, w.val_,
          formatter_t ());
    }
  } // namespace IDL
} // namespace TAOX11_NAMESPACE

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Global& m1, ::Global& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Test::Point& m1, ::Test::Point& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Test::Track& m1, ::Test::Track& m2);

  // generated from c++11/templates/cli/hdr/union_std.erb
  template <>
  void swap (::Test::Data& m1, ::Test::Data& m2);

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  void swap (::Test::S& m1, ::Test::S& m2);

  // generated from c++11/templates/cli/hdr/union_std.erb
  template <>
  void swap (::Test::U& m1, ::Test::U& m2);
} // namespace std

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Global::Global (
  int32_t x)
  : x_ (std::move (x))
{
}

inline void Global::x (int32_t _x) { this->x_ = _x; }
inline int32_t Global::x () const { return this->x_; }
inline int32_t& Global::x () { return this->x_; }

inline void Global::swap (::Global& s)
{
  std::swap (this->x_, s.x_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Test::Point::Point (
  int32_t x,
  int32_t y)
  : x_ (std::move (x))
  , y_ (std::move (y))
{
}

inline void Test::Point::x (int32_t _x) { this->x_ = _x; }
inline int32_t Test::Point::x () const { return this->x_; }
inline int32_t& Test::Point::x () { return this->x_; }

inline void Test::Point::y (int32_t _y) { this->y_ = _y; }
inline int32_t Test::Point::y () const { return this->y_; }
inline int32_t& Test::Point::y () { return this->y_; }

inline void Test::Point::swap (::Test::Point& s)
{
  std::swap (this->x_, s.x_);
  std::swap (this->y_, s.y_);
}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Test::Track::Track (
  int32_t id,
  ::Test::Point p)
  : id_ (std::move (id))
  , p_ (std::move (p))
{
}

inline void Test::Track::id (int32_t _id) { this->id_ = _id; }
inline int32_t Test::Track::id () const { return this->id_; }
inline int32_t& Test::Track::id () { return this->id_; }

inline void Test::Track::p (const ::Test::Point& _p) { this->p_ = _p; }
inline void Test::Track::p (::Test::Point&& _p) { this->p_ = std::move (_p); }
inline const ::Test::Point& Test::Track::p () const { return this->p_; }
inline ::Test::Point& Test::Track::p () { return this->p_; }

inline void Test::Track::swap (::Test::Track& s)
{
  std::swap (this->id_, s.id_);
  std::swap (this->p_, s.p_);
}
// generated from c++11/templates/cli/inl/union_inl.erb

inline Test::Data::u_type_::u_type_ ()
  : longData_ {}
{
}

inline Test::Data::u_type_::~u_type_ ()
{
}

inline Test::Data::Data ()
{
}

inline Test::Data::~Data ()
{
  this->_clear ();
}

inline Test::Data::Data (const ::Test::Data& u)
  : disc_ (u.disc_)
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
      {
        this->u_.longData_ = u.u_.longData_;
      }
    break;
    case ::Test::DataType::dtShort:
      {
        this->u_.shortData_ = u.u_.shortData_;
      }
    break;
    case ::Test::DataType::dtString:
      {
        new (&this->u_.stringData_) std::string (u.u_.stringData_);
      }
    break;
    case ::Test::DataType::dtPoint:
      {
        new (&this->u_.pointData_) ::Test::Point (u.u_.pointData_);
      }
    break;
    case ::Test::DataType::dtTrack:
      {
        new (&this->u_.trackData_) ::Test::Track (u.u_.trackData_);
      }
    break;
    case ::Test::DataType::dtGlobal:
      {
        new (&this->u_.globalData_) ::Global (u.u_.globalData_);
      }
    break;
    default:
    break;
  }
}

inline Test::Data::Data (::Test::Data&& u)
  : disc_ (std::move (u.disc_))
{
  this->_move_u (u);
}

inline void Test::Data::_d (DataType discval)
{
  if (this->disc_ != discval)
  {
    switch (this->disc_)
    {
      case ::Test::DataType::dtLong:
      {
        switch (discval)
        {
          case ::Test::DataType::dtLong:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtShort:
      {
        switch (discval)
        {
          case ::Test::DataType::dtShort:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtString:
      {
        switch (discval)
        {
          case ::Test::DataType::dtString:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtPoint:
      {
        switch (discval)
        {
          case ::Test::DataType::dtPoint:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtTrack:
      {
        switch (discval)
        {
          case ::Test::DataType::dtTrack:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtGlobal:
      {
        switch (discval)
        {
          case ::Test::DataType::dtGlobal:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      default:
      {
        switch (discval)
        {
          case ::Test::DataType::dtLong:
          case ::Test::DataType::dtShort:
          case ::Test::DataType::dtString:
          case ::Test::DataType::dtPoint:
          case ::Test::DataType::dtTrack:
          case ::Test::DataType::dtGlobal:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
          default:
            break;
        }
      }
      break;
    }
    this->disc_ = discval;
  }
}

inline ::Test::DataType Test::Data::_d () const
{
  return this->disc_;
}

inline void Test::Data::longData (int32_t _longData)
{
  if (this->disc_ != ::Test::DataType::dtLong)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtLong;
  }
  this->u_.longData_ = _longData;
}

inline int32_t Test::Data::longData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.longData_;
}

inline int32_t& Test::Data::longData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.longData_;
}

inline void Test::Data::shortData (int16_t _shortData)
{
  if (this->disc_ != ::Test::DataType::dtShort)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtShort;
  }
  this->u_.shortData_ = _shortData;
}

inline int16_t Test::Data::shortData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtShort:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.shortData_;
}

inline int16_t& Test::Data::shortData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtShort:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.shortData_;
}

inline void Test::Data::stringData (const std::string& _stringData)
{
  if (this->disc_ != ::Test::DataType::dtString)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtString;
    new (&this->u_.stringData_) std::string (_stringData);
  }
  else
  {
    this->u_.stringData_ = _stringData;
  }
}

inline void Test::Data::stringData (std::string&& _stringData)
{
  if (this->disc_ != ::Test::DataType::dtString)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtString;
    new (&this->u_.stringData_) std::string (std::move (_stringData));
  }
  else
  {
    this->u_.stringData_ = std::move (_stringData);
  }
}

inline const std::string& Test::Data::stringData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtString:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.stringData_;
}

inline std::string& Test::Data::stringData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtString:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.stringData_;
}

inline void Test::Data::pointData (const ::Test::Point& _pointData)
{
  if (this->disc_ != ::Test::DataType::dtPoint)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtPoint;
    new (&this->u_.pointData_) ::Test::Point (_pointData);
  }
  else
  {
    this->u_.pointData_ = _pointData;
  }
}

inline void Test::Data::pointData (::Test::Point&& _pointData)
{
  if (this->disc_ != ::Test::DataType::dtPoint)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtPoint;
    new (&this->u_.pointData_) ::Test::Point (std::move (_pointData));
  }
  else
  {
    this->u_.pointData_ = std::move (_pointData);
  }
}

inline const ::Test::Point& Test::Data::pointData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtPoint:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.pointData_;
}

inline ::Test::Point& Test::Data::pointData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtPoint:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.pointData_;
}

inline void Test::Data::trackData (const ::Test::Track& _trackData)
{
  if (this->disc_ != ::Test::DataType::dtTrack)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtTrack;
    new (&this->u_.trackData_) ::Test::Track (_trackData);
  }
  else
  {
    this->u_.trackData_ = _trackData;
  }
}

inline void Test::Data::trackData (::Test::Track&& _trackData)
{
  if (this->disc_ != ::Test::DataType::dtTrack)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtTrack;
    new (&this->u_.trackData_) ::Test::Track (std::move (_trackData));
  }
  else
  {
    this->u_.trackData_ = std::move (_trackData);
  }
}

inline const ::Test::Track& Test::Data::trackData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtTrack:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.trackData_;
}

inline ::Test::Track& Test::Data::trackData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtTrack:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.trackData_;
}

inline void Test::Data::globalData (const ::Global& _globalData)
{
  if (this->disc_ != ::Test::DataType::dtGlobal)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtGlobal;
    new (&this->u_.globalData_) ::Global (_globalData);
  }
  else
  {
    this->u_.globalData_ = _globalData;
  }
}

inline void Test::Data::globalData (::Global&& _globalData)
{
  if (this->disc_ != ::Test::DataType::dtGlobal)
  {
    this->_clear ();
    this->disc_ = ::Test::DataType::dtGlobal;
    new (&this->u_.globalData_) ::Global (std::move (_globalData));
  }
  else
  {
    this->u_.globalData_ = std::move (_globalData);
  }
}

inline const ::Global& Test::Data::globalData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtGlobal:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.globalData_;
}

inline ::Global& Test::Data::globalData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtGlobal:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.globalData_;
}

inline ::Test::Data& Test::Data::operator= (const ::Test::Data& u)
{
  if (this != &u)
  {
    ::Test::Data tmp (u);
    this->swap (tmp);
  }
  return *this;
}

inline ::Test::Data& Test::Data::operator= (::Test::Data&& u)
{
  if (this != &u)
  {
    ::Test::Data tmp (std::move (u));
    this->swap (tmp);
  }
  return *this;
}

inline void Test::Data::swap (::Test::Data& u)
{
  if (this != &u)
  {
    if (this->disc_ != u.disc_)
    {
      // different datatypes; so use move semantics to swap efficiently through intermediary
      ::Test::Data intermediate (std::move (*this));
      this->disc_ = std::move (u.disc_);
      this->_move_u (u);
      u.disc_ = std::move (intermediate.disc_);
      u._move_u (intermediate);
    }
    else
    {
      // same datatypes so swap directly
      this->_swap_u (u);
    }
  }
}

inline void Test::Data::_swap_u (::Test::Data& u)
{
  // u_ members have been guaranteed initialized identically so simply swap data
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
    {
      std::swap (this->u_.longData_, u.u_.longData_);
    }
    break;
    case ::Test::DataType::dtShort:
    {
      std::swap (this->u_.shortData_, u.u_.shortData_);
    }
    break;
    case ::Test::DataType::dtString:
    {
      std::swap (this->u_.stringData_, u.u_.stringData_);
    }
    break;
    case ::Test::DataType::dtPoint:
    {
      std::swap (this->u_.pointData_, u.u_.pointData_);
    }
    break;
    case ::Test::DataType::dtTrack:
    {
      std::swap (this->u_.trackData_, u.u_.trackData_);
    }
    break;
    case ::Test::DataType::dtGlobal:
    {
      std::swap (this->u_.globalData_, u.u_.globalData_);
    }
    break;
    default:
    {
      std::swap (this->u_.longData_, u.u_.longData_);
    }
    break;
  }
}

inline void Test::Data::_move_u (::Test::Data& u)
{
  // this->disc_ is guarenteed to be initialized with the value from u.disc_ so it's safe
  // to move/initialize the corresponding union members
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
    {
      this->u_.longData_ = std::move (u.u_.longData_);
    }
    break;
    case ::Test::DataType::dtShort:
    {
      this->u_.shortData_ = std::move (u.u_.shortData_);
    }
    break;
    case ::Test::DataType::dtString:
    {
      new (&this->u_.stringData_) std::string (std::move (u.u_.stringData_));
    }
    break;
    case ::Test::DataType::dtPoint:
    {
      new (&this->u_.pointData_) ::Test::Point (std::move (u.u_.pointData_));
    }
    break;
    case ::Test::DataType::dtTrack:
    {
      new (&this->u_.trackData_) ::Test::Track (std::move (u.u_.trackData_));
    }
    break;
    case ::Test::DataType::dtGlobal:
    {
      new (&this->u_.globalData_) ::Global (std::move (u.u_.globalData_));
    }
    break;
    default:
    {
      this->u_.longData_ = std::move (u.u_.longData_);
    }
    break;
  }
}

inline void Test::Data::_clear ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
    break;
    case ::Test::DataType::dtShort:
    break;
    case ::Test::DataType::dtString:
    {
      this->u_.stringData_.std::string::~string ();
    }
    break;
    case ::Test::DataType::dtPoint:
    {
      this->u_.pointData_.::Test::Point::~Point ();
    }
    break;
    case ::Test::DataType::dtTrack:
    {
      this->u_.trackData_.::Test::Track::~Track ();
    }
    break;
    case ::Test::DataType::dtGlobal:
    {
      this->u_.globalData_.::Global::~Global ();
    }
    break;
    default:
    break;
  }
}

inline void Test::Data::_default ()
{
  this->_clear ();
  this->disc_ = ::Test::DataType::dtEmpty;

}

// generated from c++11/templates/cli/inl/struct_inl.erb
inline Test::S::S (
  int32_t len)
  : len_ (std::move (len))
{
}

inline void Test::S::len (int32_t _len) { this->len_ = _len; }
inline int32_t Test::S::len () const { return this->len_; }
inline int32_t& Test::S::len () { return this->len_; }

inline void Test::S::swap (::Test::S& s)
{
  std::swap (this->len_, s.len_);
}
// generated from c++11/templates/cli/inl/union_inl.erb

inline Test::U::u_type_::u_type_ ()
  : obj_ {}
{
}

inline Test::U::u_type_::~u_type_ ()
{
}

inline Test::U::U ()
{
}

inline Test::U::~U ()
{
  this->_clear ();
}

inline Test::U::U (const ::Test::U& u)
  : disc_ (u.disc_)
{
  switch (this->disc_)
  {
    case 1:
      {
        this->u_.x_ = u.u_.x_;
      }
    break;
    case 2:
      {
        new (&this->u_.z_) std::string (u.u_.z_);
      }
    break;
    case 3:
    case 4:
      {
        new (&this->u_.w_) ::Test::S (u.u_.w_);
      }
    break;
    default:
      {
        new (&this->u_.obj_) IDL::traits< ::Test::A>::ref_type (u.u_.obj_);
      }
    break;
  }
}

inline Test::U::U (::Test::U&& u)
  : disc_ (std::move (u.disc_))
{
  this->_move_u (u);
}

inline void Test::U::_d (int32_t discval)
{
  if (this->disc_ != discval)
  {
    switch (this->disc_)
    {
      case 1:
      {
        switch (discval)
        {
          case 1:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case 2:
      {
        switch (discval)
        {
          case 2:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case 3:
      case 4:
      {
        switch (discval)
        {
          case 3:
          case 4:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      default:
      {
        switch (discval)
        {
          case 1:
          case 2:
          case 3:
          case 4:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
          default:
            break;
        }
      }
      break;
    }
    this->disc_ = discval;
  }
}

inline int32_t Test::U::_d () const
{
  return this->disc_;
}

inline void Test::U::x (int32_t _x)
{
  if (this->disc_ != 1)
  {
    this->_clear ();
    this->disc_ = 1;
  }
  this->u_.x_ = _x;
}

inline int32_t Test::U::x () const
{
  switch (this->disc_)
  {
    case 1:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.x_;
}

inline int32_t& Test::U::x ()
{
  switch (this->disc_)
  {
    case 1:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.x_;
}

inline void Test::U::z (const std::string& _z)
{
  if (this->disc_ != 2)
  {
    this->_clear ();
    this->disc_ = 2;
    new (&this->u_.z_) std::string (_z);
  }
  else
  {
    this->u_.z_ = _z;
  }
}

inline void Test::U::z (std::string&& _z)
{
  if (this->disc_ != 2)
  {
    this->_clear ();
    this->disc_ = 2;
    new (&this->u_.z_) std::string (std::move (_z));
  }
  else
  {
    this->u_.z_ = std::move (_z);
  }
}

inline const std::string& Test::U::z () const
{
  switch (this->disc_)
  {
    case 2:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.z_;
}

inline std::string& Test::U::z ()
{
  switch (this->disc_)
  {
    case 2:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.z_;
}

inline void Test::U::w (const ::Test::S& _w)
{
  if (this->disc_ != 3)
  {
    this->_clear ();
    this->disc_ = 3;
    new (&this->u_.w_) ::Test::S (_w);
  }
  else
  {
    this->u_.w_ = _w;
  }
}

inline void Test::U::w (::Test::S&& _w)
{
  if (this->disc_ != 3)
  {
    this->_clear ();
    this->disc_ = 3;
    new (&this->u_.w_) ::Test::S (std::move (_w));
  }
  else
  {
    this->u_.w_ = std::move (_w);
  }
}

inline const ::Test::S& Test::U::w () const
{
  switch (this->disc_)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.w_;
}

inline ::Test::S& Test::U::w ()
{
  switch (this->disc_)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.w_;
}

inline void Test::U::obj (IDL::traits< ::Test::A>::ref_type _obj)
{
  if (this->disc_ != (-2147483647-1))
  {
    this->_clear ();
    this->disc_ = (-2147483647-1);
    new (&this->u_.obj_) IDL::traits< ::Test::A>::ref_type (_obj);
  }
  else
  {
    this->u_.obj_ = _obj;
  }
}

inline IDL::traits< ::Test::A>::ref_type Test::U::obj () const
{
  switch (this->disc_)
  {
    case 1:
    case 2:
    case 3:
    case 4:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
    default:
      break;
  }
  return this->u_.obj_;
}

inline IDL::traits< ::Test::A>::ref_type& Test::U::obj ()
{
  switch (this->disc_)
  {
    case 1:
    case 2:
    case 3:
    case 4:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
    default:
      break;
  }
  return this->u_.obj_;
}

inline ::Test::U& Test::U::operator= (const ::Test::U& u)
{
  if (this != &u)
  {
    ::Test::U tmp (u);
    this->swap (tmp);
  }
  return *this;
}

inline ::Test::U& Test::U::operator= (::Test::U&& u)
{
  if (this != &u)
  {
    ::Test::U tmp (std::move (u));
    this->swap (tmp);
  }
  return *this;
}

inline void Test::U::swap (::Test::U& u)
{
  if (this != &u)
  {
    if (this->disc_ != u.disc_)
    {
      // different datatypes; so use move semantics to swap efficiently through intermediary
      ::Test::U intermediate (std::move (*this));
      this->disc_ = std::move (u.disc_);
      this->_move_u (u);
      u.disc_ = std::move (intermediate.disc_);
      u._move_u (intermediate);
    }
    else
    {
      // same datatypes so swap directly
      this->_swap_u (u);
    }
  }
}

inline void Test::U::_swap_u (::Test::U& u)
{
  // u_ members have been guaranteed initialized identically so simply swap data
  switch (this->disc_)
  {
    case 1:
    {
      std::swap (this->u_.x_, u.u_.x_);
    }
    break;
    case 2:
    {
      std::swap (this->u_.z_, u.u_.z_);
    }
    break;
    case 3:
    case 4:
    {
      std::swap (this->u_.w_, u.u_.w_);
    }
    break;
    default:
    {
      std::swap (this->u_.obj_, u.u_.obj_);
    }
    break;
  }
}

inline void Test::U::_move_u (::Test::U& u)
{
  // this->disc_ is guarenteed to be initialized with the value from u.disc_ so it's safe
  // to move/initialize the corresponding union members
  switch (this->disc_)
  {
    case 1:
    {
      this->u_.x_ = std::move (u.u_.x_);
    }
    break;
    case 2:
    {
      new (&this->u_.z_) std::string (std::move (u.u_.z_));
    }
    break;
    case 3:
    case 4:
    {
      new (&this->u_.w_) ::Test::S (std::move (u.u_.w_));
    }
    break;
    default:
    {
      new (&this->u_.obj_) IDL::traits< ::Test::A>::ref_type (std::move (u.u_.obj_));
    }
    break;
  }
}

inline void Test::U::_clear ()
{
  switch (this->disc_)
  {
    case 1:
    break;
    case 2:
    {
      this->u_.z_.std::string::~string ();
    }
    break;
    case 3:
    case 4:
    {
      this->u_.w_.::Test::S::~S ();
    }
    break;
    default:
    {
      this->u_.obj_.IDL::traits< ::Test::A>::ref_type::~object_reference ();
    }
    break;
  }
}

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Global& m1, ::Global& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Test::Point& m1, ::Test::Point& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Test::Track& m1, ::Test::Track& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/union_std.erb
  template <>
  inline void swap (::Test::Data& m1, ::Test::Data& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/struct_std.erb
  template <>
  inline void swap (::Test::S& m1, ::Test::S& m2)
  {
    m1.swap (m2);
  }

  // generated from c++11/templates/cli/hdr/union_std.erb
  template <>
  inline void swap (::Test::U& m1, ::Test::U& m2)
  {
    m1.swap (m2);
  }
} // namespace std

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Global& _v)
{
  return IDL::traits< ::Global>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/enum_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    ::Test::DataType _v)
{
  return IDL::traits< ::Test::DataType>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Test::Point& _v)
{
  return IDL::traits< ::Test::Point>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Test::Track& _v)
{
  return IDL::traits< ::Test::Track>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/union_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Test::Data& _v)
{
  return IDL::traits< ::Test::Data>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os.erb
inline std::ostream&
operator<< (
    std::ostream& strm,
    const ::Test::S& _v)
{
  return IDL::traits< ::Test::S>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/union_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    const ::Test::U& _v)
{
  return IDL::traits< ::Test::U>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/interface_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    IDL::traits< ::Test::Foo>::ref_type _v)
{
  return IDL::traits< ::Test::Foo>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/interface_os.erb
inline std::ostream& operator<< (
    std::ostream& strm,
    IDL::traits< ::Test::A>::ref_type _v)
{
  return IDL::traits< ::Test::A>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/post.erb
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testCP.h"
#endif

#include /**/ "ace/post.h"

#endif /* __RIDL_TESTC_H_JACJIBBG_INCLUDED__ */

// -*- END -*-
