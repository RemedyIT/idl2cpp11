/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_TESTC_H_DCICGJCA_INCLUDED__
#define __RIDL_TESTC_H_DCICGJCA_INCLUDED__

#pragma once

#include /**/ "tao/x11/base/pre.h"
#include "tao/x11/base/stddef.h"
#include "tao/x11/base/basic_traits.h"
#include "tao/x11/corba.h"
#include "variant"
#include "tao/x11/orb.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/object.h"
#include "tao/x11/object_ostream.h"

#include /**/ "tao/x11/base/versionx11.h"

#if TAOX11_MAJOR_VERSION != 2 || TAOX11_MINOR_VERSION != 7 || TAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (2.7.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from c++11/templates/cli/hdr/struct_pre
/// @copydoc test.idl::Global
class Global
{
public:
  // generated from c++11/templates/cli/hdr/struct_post
  Global () = default;
  ~Global () = default;
  Global (const Global&) = default;
  Global (Global&&) = default;
  /// Constructor which accepts value for all members
  explicit inline Global (
    int32_t x);
  Global& operator= (const Global&) = default;
  Global& operator= (Global&&) = default;

  /// @copydoc test.idl::Global::x
  //@{
  inline void x (int32_t _x11_x) { this->x_ = _x11_x; }
  [[nodiscard]] inline int32_t x () const { return this->x_; }
  [[nodiscard]] inline int32_t& x () { return this->x_; }
  //@}

  /// Exchange the value of two structures in an efficient matter
  inline void swap (Global& s);

private:
  int32_t x_{};
};// Global

inline void swap (::Global& m1, ::Global& m2) { m1.swap (m2); }

// generated from StubHeaderWriter#enter_module
/// @copydoc test.idl::Test
namespace Test
{

  // generated from c++11/templates/cli/hdr/enum
  /// @copydoc test.idl::Test::DataType
  enum class DataType : uint32_t
  {
    /// @copydoc test.idl::Test::DataType::dtEmpty
    dtEmpty,
    /// @copydoc test.idl::Test::DataType::dtLong
    dtLong,
    /// @copydoc test.idl::Test::DataType::dtShort
    dtShort,
    /// @copydoc test.idl::Test::DataType::dtString
    dtString,
    /// @copydoc test.idl::Test::DataType::dtPoint
    dtPoint,
    /// @copydoc test.idl::Test::DataType::dtTrack
    dtTrack,
    /// @copydoc test.idl::Test::DataType::dtGlobal
    dtGlobal
  };// DataType


  // generated from c++11/templates/cli/hdr/struct_pre
  /// @copydoc test.idl::Test::Point
  class Point
  {
  public:
    // generated from c++11/templates/cli/hdr/struct_post
    Point () = default;
    ~Point () = default;
    Point (const Point&) = default;
    Point (Point&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Point (
      int32_t x,
      int32_t y);
    Point& operator= (const Point&) = default;
    Point& operator= (Point&&) = default;

    /// @copydoc test.idl::Test::Point::x
    //@{
    inline void x (int32_t _x11_x) { this->x_ = _x11_x; }
    [[nodiscard]] inline int32_t x () const { return this->x_; }
    [[nodiscard]] inline int32_t& x () { return this->x_; }
    //@}

    /// @copydoc test.idl::Test::Point::y
    //@{
    inline void y (int32_t _x11_y) { this->y_ = _x11_y; }
    [[nodiscard]] inline int32_t y () const { return this->y_; }
    [[nodiscard]] inline int32_t& y () { return this->y_; }
    //@}

    /// Exchange the value of two structures in an efficient matter
    inline void swap (Point& s);

  private:
    int32_t x_{};
    int32_t y_{};
  };// Point

  inline void swap (::Test::Point& m1, ::Test::Point& m2) { m1.swap (m2); }

  // generated from c++11/templates/cli/hdr/struct_pre
  /// @copydoc test.idl::Test::Track
  class Track
  {
  public:
    // generated from c++11/templates/cli/hdr/struct_post
    Track () = default;
    ~Track () = default;
    Track (const Track&) = default;
    Track (Track&&) = default;
    /// Constructor which accepts value for all members
    explicit inline Track (
      int32_t id,
      ::Test::Point p);
    Track& operator= (const Track&) = default;
    Track& operator= (Track&&) = default;

    /// @copydoc test.idl::Test::Track::id
    //@{
    inline void id (int32_t _x11_id) { this->id_ = _x11_id; }
    [[nodiscard]] inline int32_t id () const { return this->id_; }
    [[nodiscard]] inline int32_t& id () { return this->id_; }
    //@}

    /// @copydoc test.idl::Test::Track::p
    //@{
    inline void p (const ::Test::Point& _x11_p) { this->p_ = _x11_p; }
    inline void p (::Test::Point&& _x11_p) { this->p_ = std::move (_x11_p); }
    [[nodiscard]] inline const ::Test::Point& p () const { return this->p_; }
    [[nodiscard]] inline ::Test::Point& p () { return this->p_; }
    //@}

    /// Exchange the value of two structures in an efficient matter
    inline void swap (Track& s);

  private:
    int32_t id_{};
    ::Test::Point p_{};
  };// Track

  inline void swap (::Test::Track& m1, ::Test::Track& m2) { m1.swap (m2); }

  // generated from c++11/templates/cli/hdr/union_pre
  /// @copydoc test.idl::Test::Data
  class Data
  {
  public:
    // generated from c++11/templates/cli/hdr/union_post
    /// Default constructor creating an union initialized to
    /// the default cause
    inline Data ();
    /// Copy constructor
    Data (const Data&) = default;
    /// Move constructor
    Data (Data&&) = default;
    /// Destructor
    ~Data () = default;
    /// Copy assignment operator
    Data &operator= (const Data&) = default;
    /// Move assignment operator
    Data &operator= (Data&&) = default;

    /// Set the discriminator. Only possible to set it to a
    /// value within the same current union member, otherwise
    /// a BAD_PARAM exception is thrown
    inline void _d (DataType);
    /// Get the discriminator
    inline DataType _d () const  { return this->disc_; }

    /// @copydoc test.idl::Test::Data::longData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void longData (int32_t _x11_longData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t longData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t& longData ();
    //@}

    /// @copydoc test.idl::Test::Data::shortData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void shortData (int16_t _x11_shortData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int16_t shortData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int16_t& shortData ();
    //@}

    /// @copydoc test.idl::Test::Data::stringData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void stringData (const std::string& _x11_stringData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void stringData (std::string&& _x11_stringData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const std::string& stringData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline std::string& stringData ();
    //@}

    /// @copydoc test.idl::Test::Data::pointData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void pointData (const ::Test::Point& _x11_pointData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void pointData (::Test::Point&& _x11_pointData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Test::Point& pointData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Test::Point& pointData ();
    //@}

    /// @copydoc test.idl::Test::Data::trackData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void trackData (const ::Test::Track& _x11_trackData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void trackData (::Test::Track&& _x11_trackData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Test::Track& trackData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Test::Track& trackData ();
    //@}

    /// @copydoc test.idl::Test::Data::globalData
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void globalData (const ::Global& _x11_globalData);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void globalData (::Global&& _x11_globalData);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Global& globalData () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Global& globalData ();
    //@}

    /// Modifier that sets the union to a legal default value
    inline void _default ();

    /// Exchange the value of two unions in an efficient matter
    inline void swap (Data& u);

  private:
    DataType disc_ {::Test::DataType::dtEmpty};
    using u_type_ = std::variant<int32_t, int16_t, std::string, ::Test::Point, ::Test::Track, ::Global>;
    u_type_ u_ {std::in_place_index<0>};
  }; // class Data

  inline void swap (::Test::Data& m1, ::Test::Data& m2) { m1.swap (m2); }

  // generated from c++11/templates/cli/hdr/struct_pre
  /// @copydoc test.idl::Test::S
  class S
  {
  public:
    // generated from c++11/templates/cli/hdr/struct_post
    S () = default;
    ~S () = default;
    S (const S&) = default;
    S (S&&) = default;
    /// Constructor which accepts value for all members
    explicit inline S (
      int32_t len);
    S& operator= (const S&) = default;
    S& operator= (S&&) = default;

    /// @copydoc test.idl::Test::S::len
    //@{
    inline void len (int32_t _x11_len) { this->len_ = _x11_len; }
    [[nodiscard]] inline int32_t len () const { return this->len_; }
    [[nodiscard]] inline int32_t& len () { return this->len_; }
    //@}

    /// Exchange the value of two structures in an efficient matter
    inline void swap (S& s);

  private:
    int32_t len_{};
  };// S

  inline void swap (::Test::S& m1, ::Test::S& m2) { m1.swap (m2); }

  // generated from c++11/templates/cli/hdr/interface_fwd
#if !defined (_INTF_TEST__A_FWD_)
#define _INTF_TEST__A_FWD_
  class A;
  class A_proxy;
  using A_proxy_ptr = A_proxy*;
#endif // !_INTF_TEST__A_FWD_
  // generated from Base::CodeWriter#at_global_scope
} // namespace Test
// entering Base::CodeWriter#at_global_scope

// generated from c++11/templates/cli/hdr/interface_object_traits
#if !defined (_INTF_TEST__A_TRAITS_DECL_)
#define _INTF_TEST__A_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits<::Test::A>::shared_ptr_type
    object_traits<::Test::A>::lock_shared (::Test::A* p);
    template<>
    object_traits<::Test::A>::ref_type
    object_traits<::Test::A>::narrow (object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits <::Test::A> :
      public IDL::common_byval_traits <CORBA::object_reference <::Test::A>>,
      public CORBA::object_traits <::Test::A>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      using is_local = std::false_type;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      using is_abstract = std::false_type;

      template <typename OStrm_, typename Formatter = formatter<::Test::A, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_TEST__A_TRAITS_DECL_

// leaving Base::CodeWriter#at_global_scope
namespace Test
{

  // generated from c++11/templates/cli/hdr/union_pre
  /// @copydoc test.idl::Test::U
  class U
  {
  public:
    // generated from c++11/templates/cli/hdr/union_post
    /// Default constructor creating an union initialized to
    /// the default cause
    inline U ();
    /// Copy constructor
    U (const U&) = default;
    /// Move constructor
    U (U&&) = default;
    /// Destructor
    ~U () = default;
    /// Copy assignment operator
    U &operator= (const U&) = default;
    /// Move assignment operator
    U &operator= (U&&) = default;

    /// Set the discriminator. Only possible to set it to a
    /// value within the same current union member, otherwise
    /// a BAD_PARAM exception is thrown
    inline void _d (int32_t);
    /// Get the discriminator
    inline int32_t _d () const  { return this->disc_; }

    /// @copydoc test.idl::Test::U::x
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void x (int32_t _x11_x);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t x () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline int32_t& x ();
    //@}

    /// @copydoc test.idl::Test::U::z
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void z (const std::string& _x11_z);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void z (std::string&& _x11_z);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const std::string& z () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline std::string& z ();
    //@}

    /// @copydoc test.idl::Test::U::w
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void w (const ::Test::S& _x11_w, int32_t _x11_disc = 3);
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void w (::Test::S&& _x11_w, int32_t _x11_disc = 3);
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline const ::Test::S& w () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline ::Test::S& w ();
    //@}

    /// @copydoc test.idl::Test::U::obj
    //@{
    /// Set the value of the union, the discriminator is automatically
    /// set to the correct value
    inline void obj (IDL::traits<::Test::A>::ref_type _x11_obj, int32_t _x11_disc = (-2147483647-1));
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline IDL::traits<::Test::A>::ref_type obj () const;
    /// Get the value of the union, if the discriminator doesn't match a
    /// BAD_PARAM exception is thrown
    inline IDL::traits<::Test::A>::ref_type& obj ();
    //@}

    /// Exchange the value of two unions in an efficient matter
    inline void swap (U& u);

  private:
    int32_t disc_ {(-2147483647-1)};
    using u_type_ = std::variant<int32_t, std::string, ::Test::S, IDL::traits<::Test::A>::ref_type>;
    u_type_ u_ {std::in_place_index<3>};
  }; // class U

  inline void swap (::Test::U& m1, ::Test::U& m2) { m1.swap (m2); }

  // generated from StubHeaderWriter#enter_interface

  // generated from c++11/templates/cli/hdr/interface_fwd
#if !defined (_INTF_TEST__FOO_FWD_)
#define _INTF_TEST__FOO_FWD_
  class Foo;
  class Foo_proxy;
  using Foo_proxy_ptr = Foo_proxy*;
#endif // !_INTF_TEST__FOO_FWD_
  // generated from Base::CodeWriter#at_global_scope
} // namespace Test
// entering Base::CodeWriter#at_global_scope

// generated from c++11/templates/cli/hdr/interface_object_traits
#if !defined (_INTF_TEST__FOO_TRAITS_DECL_)
#define _INTF_TEST__FOO_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits<::Test::Foo>::shared_ptr_type
    object_traits<::Test::Foo>::lock_shared (::Test::Foo* p);
    template<>
    object_traits<::Test::Foo>::ref_type
    object_traits<::Test::Foo>::narrow (object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  } // namespace CORBA

  namespace IDL
  {
    template<>
    struct traits <::Test::Foo> :
      public IDL::common_byval_traits <CORBA::object_reference <::Test::Foo>>,
      public CORBA::object_traits <::Test::Foo>
    {
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as local
      using is_local = std::false_type;
      /// std::false_type or std::true_type type indicating whether
      /// this interface is declared as abstract
      using is_abstract = std::false_type;

      template <typename OStrm_, typename Formatter = formatter<::Test::Foo, OStrm_>>
      static inline OStrm_& write_on(
          OStrm_& os_, in_type val_,
          Formatter fmt_ = Formatter ())
      {
        return fmt_ (os_, val_);
      }

      template <typename Formatter = std::false_type>
      static inline __Writer<Formatter> write (in_type val) { return {val}; }
    };
  } // namespace IDL
} // namespace TAOX11_NAMESPACE
#endif // !_INTF_TEST__FOO_TRAITS_DECL_

// leaving Base::CodeWriter#at_global_scope
namespace Test
{

  // generated from c++11/templates/cli/hdr/interface_pre
  /// @copydoc test.idl::Test::Foo
  class Foo
    : public virtual TAOX11_NAMESPACE::CORBA::Object
  {
  public:
    template <typename T> friend struct TAOX11_CORBA::object_traits;

    /// @name Member types
    //@{
    using _traits_type = TAOX11_IDL::traits<Foo>;
    /// Strong reference type
    using _ref_type = TAOX11_IDL::traits<Foo>::ref_type;
    //@}

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::pass_union
    virtual bool
    pass_union (
        const ::Test::Data& s);

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::return_union
    virtual ::Test::Data
    return_union ();

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::get_union
    virtual bool
    get_union (
        ::Test::Data& s);

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::update_union
    virtual bool
    update_union (
        ::Test::Data& s);

    // generated from c++11/templates/cli/hdr/operation
    /// @copydoc test.idl::Test::Foo::shutdown
    virtual void
    shutdown ();

    // generated from c++11/templates/cli/hdr/interface_post
  protected:
    using _shared_ptr_type = std::shared_ptr<Foo>;

    template <typename _Tp1, typename, typename ...Args>
    friend constexpr TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

    explicit Foo (Foo_proxy_ptr p, bool inherited = false);
    /// Default constructor
    Foo () = default;
    /// Destructor
    ~Foo () override = default;

  private:
    /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    //@{
    Foo(const Foo&) = delete;
    Foo(Foo&&) = delete;
    Foo& operator=(const Foo&) = delete;
    Foo& operator=(Foo&&) = delete;
    //@}
    Foo_proxy_ptr foo_proxy_ {};
  }; // class Foo

  // generated from StubHeaderWriter#enter_interface

  // generated from c++11/templates/cli/hdr/interface_pre
  /// @copydoc test.idl::Test::A
  class A
    : public virtual TAOX11_NAMESPACE::CORBA::Object
  {
  public:
    template <typename T> friend struct TAOX11_CORBA::object_traits;

    /// @name Member types
    //@{
    using _traits_type = TAOX11_IDL::traits<A>;
    /// Strong reference type
    using _ref_type = TAOX11_IDL::traits<A>::ref_type;
    //@}

    // generated from c++11/templates/cli/hdr/interface_post
  protected:
    using _shared_ptr_type = std::shared_ptr<A>;

    template <typename _Tp1, typename, typename ...Args>
    friend constexpr TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

    explicit A (A_proxy_ptr p, bool inherited = false);
    /// Default constructor
    A () = default;
    /// Destructor
    ~A () override = default;

  private:
    /** @name Illegal to be called. Deleted explicitly to let the compiler detect any violation */
    //@{
    A(const A&) = delete;
    A(A&&) = delete;
    A& operator=(const A&) = delete;
    A& operator=(A&&) = delete;
    //@}
    A_proxy_ptr a_proxy_ {};
  }; // class A
} // namespace Test


// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{

  // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_GLOBAL_TRAITS_)
#define _STRUCT_GLOBAL_TRAITS_
  template<>
  struct traits <::Global>
    : IDL::common_traits<::Global>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Global, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Global>::__Writer<Fmt>);
#endif // _STRUCT_GLOBAL_TRAITS_

  // generated from c++11/templates/cli/hdr/enum_idl_traits
  template<>
  struct traits <::Test::DataType>
    : IDL::common_byval_traits<::Test::DataType>
  {
    /// Underlying type of the enum
    using underlying_type = uint32_t;

    /// bit_bound
    using bit_bound = std::integral_constant<uint8_t, 32>;

    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::DataType, OStrm_>
  {
    inline OStrm_& operator ()(OStrm_& os_, ::Test::DataType val_)
    {
      switch (val_)
      {
        case ::Test::DataType::dtEmpty: os_ << "Test::DataType::dtEmpty"; break;
        case ::Test::DataType::dtLong: os_ << "Test::DataType::dtLong"; break;
        case ::Test::DataType::dtShort: os_ << "Test::DataType::dtShort"; break;
        case ::Test::DataType::dtString: os_ << "Test::DataType::dtString"; break;
        case ::Test::DataType::dtPoint: os_ << "Test::DataType::dtPoint"; break;
        case ::Test::DataType::dtTrack: os_ << "Test::DataType::dtTrack"; break;
        case ::Test::DataType::dtGlobal: os_ << "Test::DataType::dtGlobal"; break;
      }
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::DataType>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::DataType>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::DataType, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::DataType>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_TEST__POINT_TRAITS_)
#define _STRUCT_TEST__POINT_TRAITS_
  template<>
  struct traits <::Test::Point>
    : IDL::common_traits<::Test::Point>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::Point, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::Point>::__Writer<Fmt>);
#endif // _STRUCT_TEST__POINT_TRAITS_

  // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_TEST__TRACK_TRAITS_)
#define _STRUCT_TEST__TRACK_TRAITS_
  template<>
  struct traits <::Test::Track>
    : IDL::common_traits<::Test::Track>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::Track, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::Track>::__Writer<Fmt>);
#endif // _STRUCT_TEST__TRACK_TRAITS_

  // generated from c++11/templates/cli/hdr/union_idl_traits
#if !defined (_UNION_TEST__DATA_TRAITS_)
#define _UNION_TEST__DATA_TRAITS_
  template<>
  struct traits <::Test::Data>
    : IDL::common_traits<::Test::Data>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::Data, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::Data>::__Writer<Fmt>);
#endif // _UNION_TEST__DATA_TRAITS_

  // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_TEST__S_TRAITS_)
#define _STRUCT_TEST__S_TRAITS_
  template<>
  struct traits <::Test::S>
    : IDL::common_traits<::Test::S>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::S, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::S>::__Writer<Fmt>);
#endif // _STRUCT_TEST__S_TRAITS_

  // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_TEST__A_TRAITS_DECL_)
#define _INTF_FMT_TEST__A_TRAITS_DECL_
  template <typename OStrm_>
  struct formatter<::Test::A, OStrm_>
  {
    OStrm_& operator ()(OStrm_& , IDL::traits<::Test::A>::ref_type);
  };

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::A>::__Writer<Fmt>);
#endif // !_INTF_FMT_TEST__A_TRAITS_DECL_

  // generated from c++11/templates/cli/hdr/union_idl_traits
#if !defined (_UNION_TEST__U_TRAITS_)
#define _UNION_TEST__U_TRAITS_
  template<>
  struct traits <::Test::U>
    : IDL::common_traits<::Test::U>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::Test::U, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::U>::__Writer<Fmt>);
#endif // _UNION_TEST__U_TRAITS_

  // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_TEST__FOO_TRAITS_DECL_)
#define _INTF_FMT_TEST__FOO_TRAITS_DECL_
  template <typename OStrm_>
  struct formatter<::Test::Foo, OStrm_>
  {
    OStrm_& operator ()(OStrm_& , IDL::traits<::Test::Foo>::ref_type);
  };

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::Foo>::__Writer<Fmt>);
#endif // !_INTF_FMT_TEST__FOO_TRAITS_DECL_

  // generated from c++11/templates/cli/hdr/interface_idl_traits
#if !defined (_INTF_FMT_TEST__A_TRAITS_DECL_)
#define _INTF_FMT_TEST__A_TRAITS_DECL_
  template <typename OStrm_>
  struct formatter<::Test::A, OStrm_>
  {
    OStrm_& operator ()(OStrm_& , IDL::traits<::Test::A>::ref_type);
  };

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::Test::A>::__Writer<Fmt>);
#endif // !_INTF_FMT_TEST__A_TRAITS_DECL_
} // namespace TAOX11_NAMESPACE::IDL

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{

  // generated from c++11/templates/cli/hdr/struct_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Global, OStrm_>
  {
    inline OStrm_& operator ()(
        OStrm_& os_,
        const ::Global& val_)
    {
      os_ << "Global"
          << '{'
          << "x=" << IDL::traits<int32_t>::write(val_.x ())
          << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Global>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Global>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Global, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Global>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/struct_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::Point, OStrm_>
  {
    inline OStrm_& operator ()(
        OStrm_& os_,
        const ::Test::Point& val_)
    {
      os_ << "Test::Point"
          << '{'
          << "x=" << IDL::traits<int32_t>::write(val_.x ())
          << ",y=" << IDL::traits<int32_t>::write(val_.y ())
          << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::Point>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::Point>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::Point, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::Point>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/struct_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::Track, OStrm_>
  {
    inline OStrm_& operator ()(
        OStrm_& os_,
        const ::Test::Track& val_)
    {
      os_ << "Test::Track"
          << '{'
          << "id=" << IDL::traits<int32_t>::write(val_.id ())
          << ",p=" << IDL::traits<::Test::Point>::write(val_.p ())
          << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::Track>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::Track>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::Track, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::Track>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/union_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::Data, OStrm_>
  {
    inline OStrm_& operator ()(OStrm_& os_, const ::Test::Data& val_)
    {
      os_ << "Test::Data {";
      switch (val_._d ())
      {
        case ::Test::DataType::dtLong:
        {
          os_ << "longData=" << IDL::traits<int32_t>::write (val_.longData ());
        }
        break;
        case ::Test::DataType::dtShort:
        {
          os_ << "shortData=" << IDL::traits<int16_t>::write (val_.shortData ());
        }
        break;
        case ::Test::DataType::dtString:
        {
          os_ << "stringData=" << IDL::traits<std::string>::write (val_.stringData ());
        }
        break;
        case ::Test::DataType::dtPoint:
        {
          os_ << "pointData=" << IDL::traits<::Test::Point>::write (val_.pointData ());
        }
        break;
        case ::Test::DataType::dtTrack:
        {
          os_ << "trackData=" << IDL::traits<::Test::Track>::write (val_.trackData ());
        }
        break;
        case ::Test::DataType::dtGlobal:
        {
          os_ << "globalData=" << IDL::traits<::Global>::write (val_.globalData ());
        }
        break;
        default:
        break;
      }
      os_ << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(
      OStrm_& os,
      IDL::traits<::Test::Data>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::Data>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::Data, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::Data>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/struct_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::S, OStrm_>
  {
    inline OStrm_& operator ()(
        OStrm_& os_,
        const ::Test::S& val_)
    {
      os_ << "Test::S"
          << '{'
          << "len=" << IDL::traits<int32_t>::write(val_.len ())
          << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::S>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::S>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::S, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::S>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/union_idl_traits_def
  template <typename OStrm_>
  struct formatter<::Test::U, OStrm_>
  {
    inline OStrm_& operator ()(OStrm_& os_, const ::Test::U& val_)
    {
      os_ << "Test::U {";
      switch (val_._d ())
      {
        case 1:
        {
          os_ << "x=" << IDL::traits<int32_t>::write (val_.x ());
        }
        break;
        case 2:
        {
          os_ << "z=" << IDL::traits<std::string>::write (val_.z ());
        }
        break;
        case 3:
        case 4:
        {
          os_ << "w=" << IDL::traits<::Test::S>::write (val_.w ());
        }
        break;
        default:
        {
          os_ << "obj=" << IDL::traits<::Test::A>::write (val_.obj ());
        }
        break;
      }
      os_ << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(
      OStrm_& os,
      IDL::traits<::Test::U>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::U>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::U, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::U>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/interface_idl_traits_def
  template <typename OStrm_>
  inline OStrm_&
  formatter<::Test::Foo, OStrm_>::operator ()(OStrm_& os_, IDL::traits<::Test::Foo>::ref_type val_)
  {
    os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (std::move (val_), "Test::Foo");
    return os_;
  }

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::Foo>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::Foo>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::Foo, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::Foo>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/interface_idl_traits_def
  template <typename OStrm_>
  inline OStrm_&
  formatter<::Test::A, OStrm_>::operator ()(OStrm_& os_, IDL::traits<::Test::A>::ref_type val_)
  {
    os_ << IDL::traits<TAOX11_CORBA::Object>::_dump (std::move (val_), "Test::A");
    return os_;
  }

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::Test::A>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::Test::A>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::Test::A, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::Test::A>::write_on (os, w.val_, formatter_t ());
  }
} // namespace TAOX11_NAMESPACE::IDL

// generated from c++11/templates/cli/inl/struct_inl
inline ::Global::Global (
  int32_t x)
  : x_ (std::move (x))
{
}

inline void ::Global::swap (::Global& s)
{
  std::swap (this->x_, s.x_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Test::Point::Point (
  int32_t x,
  int32_t y)
  : x_ (std::move (x))
  , y_ (std::move (y))
{
}

inline void ::Test::Point::swap (::Test::Point& s)
{
  std::swap (this->x_, s.x_);
  std::swap (this->y_, s.y_);
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Test::Track::Track (
  int32_t id,
  ::Test::Point p)
  : id_ (std::move (id))
  , p_ (std::move (p))
{
}

inline void ::Test::Track::swap (::Test::Track& s)
{
  std::swap (this->id_, s.id_);
  std::swap (this->p_, s.p_);
}
// generated from c++11/templates/cli/inl/union_inl
inline Test::Data::Data ()
{
}

inline void Test::Data::_d (DataType discval)
{
  if (this->disc_ != discval)
  {
    switch (this->disc_)
    {
      case ::Test::DataType::dtLong:
      {
        switch (discval)
        {
          case ::Test::DataType::dtLong:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtShort:
      {
        switch (discval)
        {
          case ::Test::DataType::dtShort:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtString:
      {
        switch (discval)
        {
          case ::Test::DataType::dtString:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtPoint:
      {
        switch (discval)
        {
          case ::Test::DataType::dtPoint:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtTrack:
      {
        switch (discval)
        {
          case ::Test::DataType::dtTrack:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case ::Test::DataType::dtGlobal:
      {
        switch (discval)
        {
          case ::Test::DataType::dtGlobal:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      default:
      {
        switch (discval)
        {
          case ::Test::DataType::dtLong:
          case ::Test::DataType::dtShort:
          case ::Test::DataType::dtString:
          case ::Test::DataType::dtPoint:
          case ::Test::DataType::dtTrack:
          case ::Test::DataType::dtGlobal:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
          default:
            break;
        }
      }
      break;
    }
    this->disc_ = discval;
  }
}

inline void Test::Data::longData (int32_t _x11_longData)
{
  this->disc_ = ::Test::DataType::dtLong;
  this->u_.emplace<0>(_x11_longData);
}

inline int32_t Test::Data::longData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<0>(this->u_);
}

inline int32_t& Test::Data::longData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtLong:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<0>(this->u_);
}

inline void Test::Data::shortData (int16_t _x11_shortData)
{
  this->disc_ = ::Test::DataType::dtShort;
  this->u_.emplace<1>(_x11_shortData);
}

inline int16_t Test::Data::shortData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtShort:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<1>(this->u_);
}

inline int16_t& Test::Data::shortData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtShort:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<1>(this->u_);
}

inline void Test::Data::stringData (const std::string& _x11_stringData)
{
  this->disc_ = ::Test::DataType::dtString;
  this->u_.emplace<2>(_x11_stringData);
}

inline void Test::Data::stringData (std::string&& _x11_stringData)
{
  this->disc_ = ::Test::DataType::dtString;
  this->u_.emplace<2>(std::move (_x11_stringData));
}

inline const std::string& Test::Data::stringData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtString:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<2>(this->u_);
}

inline std::string& Test::Data::stringData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtString:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<2>(this->u_);
}

inline void Test::Data::pointData (const ::Test::Point& _x11_pointData)
{
  this->disc_ = ::Test::DataType::dtPoint;
  this->u_.emplace<3>(_x11_pointData);
}

inline void Test::Data::pointData (::Test::Point&& _x11_pointData)
{
  this->disc_ = ::Test::DataType::dtPoint;
  this->u_.emplace<3>(std::move (_x11_pointData));
}

inline const ::Test::Point& Test::Data::pointData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtPoint:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<3>(this->u_);
}

inline ::Test::Point& Test::Data::pointData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtPoint:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<3>(this->u_);
}

inline void Test::Data::trackData (const ::Test::Track& _x11_trackData)
{
  this->disc_ = ::Test::DataType::dtTrack;
  this->u_.emplace<4>(_x11_trackData);
}

inline void Test::Data::trackData (::Test::Track&& _x11_trackData)
{
  this->disc_ = ::Test::DataType::dtTrack;
  this->u_.emplace<4>(std::move (_x11_trackData));
}

inline const ::Test::Track& Test::Data::trackData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtTrack:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<4>(this->u_);
}

inline ::Test::Track& Test::Data::trackData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtTrack:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<4>(this->u_);
}

inline void Test::Data::globalData (const ::Global& _x11_globalData)
{
  this->disc_ = ::Test::DataType::dtGlobal;
  this->u_.emplace<5>(_x11_globalData);
}

inline void Test::Data::globalData (::Global&& _x11_globalData)
{
  this->disc_ = ::Test::DataType::dtGlobal;
  this->u_.emplace<5>(std::move (_x11_globalData));
}

inline const ::Global& Test::Data::globalData () const
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtGlobal:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<5>(this->u_);
}

inline ::Global& Test::Data::globalData ()
{
  switch (this->disc_)
  {
    case ::Test::DataType::dtGlobal:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<5>(this->u_);
}

inline void Test::Data::swap (::Test::Data& u)
{
  std::swap (this->disc_, u.disc_);
  std::swap (this->u_, u.u_);
}

inline void Test::Data::_default ()
{
  this->disc_ = ::Test::DataType::dtEmpty;
  this->u_.emplace<0>(int32_t{});
}

// generated from c++11/templates/cli/inl/struct_inl
inline ::Test::S::S (
  int32_t len)
  : len_ (std::move (len))
{
}

inline void ::Test::S::swap (::Test::S& s)
{
  std::swap (this->len_, s.len_);
}
// generated from c++11/templates/cli/inl/union_inl
inline Test::U::U ()
{
}

inline void Test::U::_d (int32_t discval)
{
  if (this->disc_ != discval)
  {
    switch (this->disc_)
    {
      case 1:
      {
        switch (discval)
        {
          case 1:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case 2:
      {
        switch (discval)
        {
          case 2:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case 3:
      case 4:
      {
        switch (discval)
        {
          case 3:
          case 4:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      default:
      {
        switch (discval)
        {
          case 1:
          case 2:
          case 3:
          case 4:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
          default:
            break;
        }
      }
      break;
    }
    this->disc_ = discval;
  }
}

inline void Test::U::x (int32_t _x11_x)
{
  this->disc_ = 1;
  this->u_.emplace<0>(_x11_x);
}

inline int32_t Test::U::x () const
{
  switch (this->disc_)
  {
    case 1:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<0>(this->u_);
}

inline int32_t& Test::U::x ()
{
  switch (this->disc_)
  {
    case 1:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<0>(this->u_);
}

inline void Test::U::z (const std::string& _x11_z)
{
  this->disc_ = 2;
  this->u_.emplace<1>(_x11_z);
}

inline void Test::U::z (std::string&& _x11_z)
{
  this->disc_ = 2;
  this->u_.emplace<1>(std::move (_x11_z));
}

inline const std::string& Test::U::z () const
{
  switch (this->disc_)
  {
    case 2:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<1>(this->u_);
}

inline std::string& Test::U::z ()
{
  switch (this->disc_)
  {
    case 2:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<1>(this->u_);
}

inline void Test::U::w (const ::Test::S& _x11_w, int32_t _x11_disc)
{
  // Check whether a valid discriminator value got passed
  switch (_x11_disc)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  this->disc_ = _x11_disc;
  this->u_.emplace<2>(_x11_w);
}

inline void Test::U::w (::Test::S&& _x11_w, int32_t _x11_disc)
{
  // Check whether a valid discriminator value got passed
  switch (_x11_disc)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  this->disc_ = _x11_disc;
  this->u_.emplace<2>(std::move (_x11_w));
}

inline const ::Test::S& Test::U::w () const
{
  switch (this->disc_)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<2>(this->u_);
}

inline ::Test::S& Test::U::w ()
{
  switch (this->disc_)
  {
    case 3:
    case 4:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return std::get<2>(this->u_);
}

inline void Test::U::obj (IDL::traits<::Test::A>::ref_type _x11_obj, int32_t _x11_disc)
{
  // Check whether a valid discriminator value got passed
  switch (_x11_disc)
  {
    case 1:
    case 2:
    case 3:
    case 4:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
    default:
      break;
  }
  this->disc_ = _x11_disc;
  this->u_.emplace<3>(_x11_obj);
}

inline IDL::traits<::Test::A>::ref_type Test::U::obj () const
{
  switch (this->disc_)
  {
    case 1:
    case 2:
    case 3:
    case 4:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
    default:
      break;
  }
  return std::get<3>(this->u_);
}

inline IDL::traits<::Test::A>::ref_type& Test::U::obj ()
{
  switch (this->disc_)
  {
    case 1:
    case 2:
    case 3:
    case 4:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
    default:
      break;
  }
  return std::get<3>(this->u_);
}

inline void Test::U::swap (::Test::U& u)
{
  std::swap (this->disc_, u.disc_);
  std::swap (this->u_, u.u_);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream& operator<< (std::ostream& strm, const ::Global& _v)
{
  return IDL::traits<::Global>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/enum_os
inline std::ostream& operator<< (std::ostream& strm, ::Test::DataType _v)
{
  return IDL::traits<::Test::DataType>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::Point& _v)
{
  return IDL::traits<::Test::Point>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::Track& _v)
{
  return IDL::traits<::Test::Track>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/union_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::Data& _v)
{
  return IDL::traits<::Test::Data>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::S& _v)
{
  return IDL::traits<::Test::S>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/union_os
inline std::ostream& operator<< (std::ostream& strm, const ::Test::U& _v)
{
  return IDL::traits<::Test::U>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/interface_os
inline std::ostream& operator<< (std::ostream& strm, IDL::traits<::Test::Foo>::ref_type _v)
{
  return IDL::traits<::Test::Foo>::write_on (strm, std::move(_v));
}

// generated from c++11/templates/cli/hdr/interface_os
inline std::ostream& operator<< (std::ostream& strm, IDL::traits<::Test::A>::ref_type _v)
{
  return IDL::traits<::Test::A>::write_on (strm, std::move(_v));
}

// generated from c++11/templates/cli/hdr/post
#if !defined (TAOX11_DISABLE_INCLUDE_STUB_PROXY_HDR) && defined (__TAOX11_INCLUDE_STUB_PROXY__) && __has_include("testCP.h")
# include "testCP.h"
#endif

#include /**/ "tao/x11/base/post.h"

#endif /* __RIDL_TESTC_H_DCICGJCA_INCLUDED__ */

// -*- END -*-
