// -*- C++ -*-
/*
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT
 *        Nijkerk, GLD
 *        The Netherlands
 *        http://www.remedy.nl \ http://www.theaceorb.nl
 */

#ifndef __RIDL_TESTC_H_INCLUDED__
#define __RIDL_TESTC_H_INCLUDED__


#include /**/ "ace/pre.h"

#include "tao/x11/stddef.h"
#include "tao/x11/corba.h"
#include "tao/x11/system_exception.h"
#include "tao/x11/orb.h"
#include "tao/x11/object.h"

using namespace TAOX11_NAMESPACE;

// generated from c++/cli_hdr/struct_pre.erb
class Global final
{
public:

  // generated from c++/cli_hdr/struct_post.erb
  Global (void);
  ~Global (void) = default;
  Global (const Global&) = default;
  Global (Global&&) = default;
  explicit Global (int32_t x);
  Global& operator= (const Global& x);
  Global& operator= (Global&& x);

  void x (int32_t _x);
  int32_t x (void) const;
  int32_t& x (void);

  void swap (Global& s);

private:
  int32_t x_;
}; // Global

// generated from StubHeaderWriter#enter_module
namespace Test
{

  // generated from c++/cli_hdr/enum.erb
  enum class DataType : uint32_t
  {
    dtEmpty,
    dtLong,
    dtShort,
    dtString,
    dtPoint,
    dtTrack,
    dtGlobal
  }; // DataType

  // generated from c++/cli_hdr/struct_pre.erb
  class Point final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    Point (void);
    ~Point (void) = default;
    Point (const Point&) = default;
    Point (Point&&) = default;
    explicit Point (int32_t x,
                    int32_t y);
    Point& operator= (const Point& x);
    Point& operator= (Point&& x);

    void x (int32_t _x);
    int32_t x (void) const;
    int32_t& x (void);

    void y (int32_t _y);
    int32_t y (void) const;
    int32_t& y (void);

    void swap (Point& s);

  private:
    int32_t x_;
    int32_t y_;
  }; // Point

  // generated from c++/cli_hdr/struct_pre.erb
  class Track final
  {
  public:

    // generated from c++/cli_hdr/struct_post.erb
    Track (void);
    ~Track (void) = default;
    Track (const Track&) = default;
    Track (Track&&) = default;
    explicit Track (int32_t id,
                    ::Test::Point p);
    Track& operator= (const Track& x);
    Track& operator= (Track&& x);

    void id (int32_t _id);
    int32_t id (void) const;
    int32_t& id (void);

    void p (const ::Test::Point& _p);
    void p (::Test::Point&& _p);
    const ::Test::Point& p (void) const;
    ::Test::Point& p (void);

    void swap (Track& s);

  private:
    int32_t id_;
    ::Test::Point p_;
  }; // Track

  // generated from c++/cli_hdr/union_pre.erb
  class Data final
  {
  public:

    // generated from c++/cli_hdr/union_post.erb
    Data (void);
    Data (const Data&);
    Data (Data&&);
    ~Data (void);
    Data &operator= (const Data&);
    Data &operator= (Data&&);

    void _d (DataType);
    DataType _d (void) const;

    void longData (int32_t _longData);
    int32_t longData (void) const;
    int32_t& longData (void);

    void shortData (int16_t _shortData);
    int16_t shortData (void) const;
    int16_t& shortData (void);

    void stringData (const std::string& _stringData);
    void stringData (std::string&& _stringData);
    const std::string& stringData (void) const;
    std::string& stringData (void);

    void pointData (const ::Test::Point& _pointData);
    void pointData (::Test::Point&& _pointData);
    const ::Test::Point& pointData (void) const;
    ::Test::Point& pointData (void);

    void trackData (const ::Test::Track& _trackData);
    void trackData (::Test::Track&& _trackData);
    const ::Test::Track& trackData (void) const;
    ::Test::Track& trackData (void);

    void globalData (const ::Global& _globalData);
    void globalData (::Global&& _globalData);
    const ::Global& globalData (void) const;
    ::Global& globalData (void);

    void _default (void);

    void swap (Data& s);

  private:
    void _swap_u (Data& s);
    void _clear (void);

    DataType disc_;
    union u_type_
    {
      u_type_ (void);
      ~u_type_ (void);
      int32_t longData_;
      int16_t shortData_;
      std::string stringData_;
      ::Test::Point pointData_;
      ::Test::Track trackData_;
      ::Global globalData_;
    } u_;
  }; // Data

  // generated from StubHeaderWriter#enter_interface

  // generated from c++/cli_hdr/interface_fwd.erb
#if !defined (_INTF_TEST_FOO_FWD_)
#define _INTF_TEST_FOO_FWD_
  class Foo;
  class Foo_proxy;
  typedef Foo_proxy* Foo_proxy_ptr;
  namespace POA
  {
    class Foo;
  };
#endif // !_INTF_TEST_FOO_FWD_
  // generated from CxxWriterBase#at_global_scope
}; // Test
// entering CxxWriterBase#at_global_scope

// generated from c++/cli_hdr/interface_object_traits.erb
#if !defined (_INTF_TEST_FOO_TRAITS_DECL_)
#define _INTF_TEST_FOO_TRAITS_DECL_
namespace TAOX11_NAMESPACE
{
  namespace CORBA
  {
    template<>
    object_traits< ::Test::Foo>::shared_ptr_type
    object_traits< ::Test::Foo>::lock_shared (
        ::Test::Foo*);
    template<>
    const Object_proxy*
    object_traits< ::Test::Foo>::to_proxy (
        object_traits< ::Test::Foo>::ref_type);
    template<>
    object_traits< ::Test::Foo>::ref_type object_traits< ::Test::Foo>::narrow (
       object_traits<TAOX11_NAMESPACE::CORBA::Object>::ref_type);
  };
};
#endif // !_INTF_TEST_FOO_TRAITS_DECL_

// leaving CxxWriterBase#at_global_scope
namespace Test
{

  // generated from c++/cli_hdr/interface_pre.erb
  class Foo
    : public virtual TAOX11_NAMESPACE::CORBA::Object
  {
  public:
    template <typename T> friend struct TAOX11_CORBA::object_traits;

    typedef TAOX11_CORBA::object_traits< Foo> _traits_type;
    typedef TAOX11_CORBA::object_reference< Foo> _ref_type;

    virtual const std::string& _interface_repository_id () const override;

    // generated from c++/cli_hdr/operation.erb
    /// @copybrief Test::Foo::pass_union
    virtual bool pass_union (const ::Test::Data& s);

    // generated from c++/cli_hdr/operation.erb
    /// @copybrief Test::Foo::return_union
    virtual ::Test::Data return_union (void);

    // generated from c++/cli_hdr/operation.erb
    /// @copybrief Test::Foo::get_union
    virtual bool get_union (::Test::Data& s);

    // generated from c++/cli_hdr/operation.erb
    /// @copybrief Test::Foo::update_union
    virtual bool update_union (::Test::Data& s);

    // generated from c++/cli_hdr/operation.erb
    /// @copybrief Test::Foo::shutdown
    virtual void shutdown (void);

    // generated from c++/cli_hdr/interface_post.erb
    static TAOX11_CORBA::object_reference< Foo> _narrow (
        TAOX11_CORBA::object_reference<TAOX11_NAMESPACE::CORBA::Object> obj)
    {
      return TAOX11_CORBA::object_traits< Foo>::narrow (obj);
    }

  protected:
    typedef std::shared_ptr<Foo>   _shared_ptr_type;

    template <typename _Tp1, typename, typename ...Args>
    friend TAOX11_CORBA::object_reference<_Tp1> TAOX11_CORBA::make_reference(Args&& ...args);

    explicit Foo (Foo_proxy_ptr p);
    explicit Foo (Foo_proxy_ptr p, bool);
    Foo (void);
    ~Foo (void) = default;

  private:
    Foo(const Foo&) = delete;
    Foo(Foo&&) = delete;
    Foo& operator=(const Foo&) = delete;
    Foo& operator=(Foo&&) = delete;
    Foo_proxy_ptr foo_proxy_;
  }; // Foo
}; // namespace Test


// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Global& m1, ::Global& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Test::Point& m1, ::Test::Point& m2);

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  void swap (::Test::Track& m1, ::Test::Track& m2);

  // generated from c++/cli_hdr/union_std.erb
  template <>
  void swap (::Test::Data& m1, ::Test::Data& m2);
}; // std

// generated from c++/cli_inl/struct_inl.erb
inline Global::Global ()
           : x_ (0)
{
}
inline Global::Global (int32_t x)
           : x_ (std::move (x))
{
}

inline void Global::x (int32_t _x) { this->x_ = _x; }
inline int32_t Global::x (void) const { return this->x_; }
inline int32_t& Global::x (void) { return this->x_; }

inline ::Global& Global::operator= (const ::Global& x)
{
  if (this != &x) {
    this->x_ = x.x_;
  }
  return *this;
}
inline ::Global& Global::operator= (::Global&& x)
{
  this->x_ = std::move (x.x_);
  return *this;
}

inline void Global::swap (::Global& s)
{
  std::swap (this->x_, s.x_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Test::Point::Point ()
           : x_ (0)
           , y_ (0)
{
}
inline Test::Point::Point (int32_t x,
                           int32_t y)
           : x_ (std::move (x))
           , y_ (std::move (y))
{
}

inline void Test::Point::x (int32_t _x) { this->x_ = _x; }
inline int32_t Test::Point::x (void) const { return this->x_; }
inline int32_t& Test::Point::x (void) { return this->x_; }

inline void Test::Point::y (int32_t _y) { this->y_ = _y; }
inline int32_t Test::Point::y (void) const { return this->y_; }
inline int32_t& Test::Point::y (void) { return this->y_; }

inline ::Test::Point& Test::Point::operator= (const ::Test::Point& x)
{
  if (this != &x) {
    this->x_ = x.x_;
    this->y_ = x.y_;
  }
  return *this;
}
inline ::Test::Point& Test::Point::operator= (::Test::Point&& x)
{
  this->x_ = std::move (x.x_);
  this->y_ = std::move (x.y_);
  return *this;
}

inline void Test::Point::swap (::Test::Point& s)
{
  std::swap (this->x_, s.x_);
  std::swap (this->y_, s.y_);
}

// generated from c++/cli_inl/struct_inl.erb
inline Test::Track::Track ()
           : id_ (0)
           , p_ (::Test::Point ())
{
}
inline Test::Track::Track (int32_t id,
                           ::Test::Point p)
           : id_ (std::move (id))
           , p_ (std::move (p))
{
}

inline void Test::Track::id (int32_t _id) { this->id_ = _id; }
inline int32_t Test::Track::id (void) const { return this->id_; }
inline int32_t& Test::Track::id (void) { return this->id_; }

inline void Test::Track::p (const ::Test::Point& _p) { this->p_ = _p; }
inline void Test::Track::p (::Test::Point&& _p) { this->p_ = std::move (_p); }
inline const ::Test::Point& Test::Track::p (void) const { return this->p_; }
inline ::Test::Point& Test::Track::p (void) { return this->p_; }

inline ::Test::Track& Test::Track::operator= (const ::Test::Track& x)
{
  if (this != &x) {
    this->id_ = x.id_;
    this->p_ = x.p_;
  }
  return *this;
}
inline ::Test::Track& Test::Track::operator= (::Test::Track&& x)
{
  this->id_ = std::move (x.id_);
  this->p_ = std::move (x.p_);
  return *this;
}

inline void Test::Track::swap (::Test::Track& s)
{
  std::swap (this->id_, s.id_);
  std::swap (this->p_, s.p_);
}
// generated from c++/cli_inl/union_inl.erb

inline Test::Data::u_type_::u_type_ (void)
{
}

inline Test::Data::u_type_::~u_type_ (void)
{
}

inline Test::Data::Data (void)
  : disc_ (::Test::DataType::dtEmpty)
{
}

inline Test::Data::~Data (void)
{
  this->_clear ();
}

inline Test::Data::Data (const ::Test::Data& u)
  : disc_ (u.disc_)
{
  switch (this->disc_)
  {
    case Test::DataType::dtLong:
      {
        this->u_.longData_ = u.u_.longData_;
      }
    break;
    case Test::DataType::dtShort:
      {
        this->u_.shortData_ = u.u_.shortData_;
      }
    break;
    case Test::DataType::dtString:
      {
        new (&this->u_.stringData_) std::string;
        this->u_.stringData_ = u.u_.stringData_;
      }
    break;
    case Test::DataType::dtPoint:
      {
        new (&this->u_.pointData_) ::Test::Point;
        this->u_.pointData_ = u.u_.pointData_;
      }
    break;
    case Test::DataType::dtTrack:
      {
        new (&this->u_.trackData_) ::Test::Track;
        this->u_.trackData_ = u.u_.trackData_;
      }
    break;
    case Test::DataType::dtGlobal:
      {
        new (&this->u_.globalData_) ::Global;
        this->u_.globalData_ = u.u_.globalData_;
      }
    break;
    default:
    break;
  }
}

inline Test::Data::Data (::Test::Data&& u)
  : disc_ (std::move (u.disc_))
{
  switch (this->disc_)
  {
  case Test::DataType::dtLong:
    {
      this->u_.longData_ = std::move (u.u_.longData_);
    }
    break;
  case Test::DataType::dtShort:
    {
      this->u_.shortData_ = std::move (u.u_.shortData_);
    }
    break;
  case Test::DataType::dtString:
    {
      new (&this->u_.stringData_) std::string (std::move (u.u_.stringData_));
    }
    break;
  case Test::DataType::dtPoint:
    {
      new (&this->u_.pointData_) ::Test::Point (std::move (u.u_.pointData_));
    }
    break;
  case Test::DataType::dtTrack:
    {
      new (&this->u_.trackData_) ::Test::Track (std::move (u.u_.trackData_));
    }
    break;
  case Test::DataType::dtGlobal:
    {
      new (&this->u_.globalData_) ::Global (std::move (u.u_.globalData_));
    }
    break;
  default:
    break;
  }
}

inline void Test::Data::_d (DataType discval)
{
  if (this->disc_ != discval)
  {
    switch (this->disc_)
    {
      case Test::DataType::dtLong:
      {
        switch (discval)
        {
          case Test::DataType::dtLong:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case Test::DataType::dtShort:
      {
        switch (discval)
        {
          case Test::DataType::dtShort:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case Test::DataType::dtString:
      {
        switch (discval)
        {
          case Test::DataType::dtString:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case Test::DataType::dtPoint:
      {
        switch (discval)
        {
          case Test::DataType::dtPoint:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case Test::DataType::dtTrack:
      {
        switch (discval)
        {
          case Test::DataType::dtTrack:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      case Test::DataType::dtGlobal:
      {
        switch (discval)
        {
          case Test::DataType::dtGlobal:
            break;
          default:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
        }
      }
      break;
      default:
      {
        switch (discval)
        {
          case Test::DataType::dtLong:
          case Test::DataType::dtShort:
          case Test::DataType::dtString:
          case Test::DataType::dtPoint:
          case Test::DataType::dtTrack:
          case Test::DataType::dtGlobal:
            throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
          default:
            break;
        }
      }
      break;
    }
    this->disc_ = discval;
  }
}
inline ::Test::DataType Test::Data::_d (void) const
{
  return this->disc_;
}

inline void Test::Data::longData (int32_t _longData)
{
  if (this->disc_ != Test::DataType::dtLong)
  {
    this->_clear ();
  }
  this->u_.longData_ = _longData;
  this->disc_ = Test::DataType::dtLong;
}
inline int32_t Test::Data::longData (void) const
{
  switch (this->disc_)
  {
    case Test::DataType::dtLong:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.longData_;
}
inline int32_t& Test::Data::longData (void)
{
  switch (this->disc_)
  {
    case Test::DataType::dtLong:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.longData_;
}

inline void Test::Data::shortData (int16_t _shortData)
{
  if (this->disc_ != Test::DataType::dtShort)
  {
    this->_clear ();
  }
  this->u_.shortData_ = _shortData;
  this->disc_ = Test::DataType::dtShort;
}
inline int16_t Test::Data::shortData (void) const
{
  switch (this->disc_)
  {
    case Test::DataType::dtShort:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.shortData_;
}
inline int16_t& Test::Data::shortData (void)
{
  switch (this->disc_)
  {
    case Test::DataType::dtShort:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.shortData_;
}

inline void Test::Data::stringData (const std::string& _stringData)
{
  if (this->disc_ != Test::DataType::dtString)
  {
    this->_clear ();
    new (&this->u_.stringData_) std::string (_stringData);
  }
  else
  {
    this->u_.stringData_ = _stringData;
  }
  this->disc_ = Test::DataType::dtString;
}
inline void Test::Data::stringData (std::string&& _stringData)
{
  if (this->disc_ != Test::DataType::dtString)
  {
    this->_clear ();
    new (&this->u_.stringData_) std::string (std::move (_stringData));
  }
  else
  {
    this->u_.stringData_ = std::move (_stringData);
  }
  this->disc_ = Test::DataType::dtString;
}
inline const std::string& Test::Data::stringData (void) const
{
  switch (this->disc_)
  {
    case Test::DataType::dtString:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.stringData_;
}
inline std::string& Test::Data::stringData (void)
{
  switch (this->disc_)
  {
    case Test::DataType::dtString:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.stringData_;
}

inline void Test::Data::pointData (const ::Test::Point& _pointData)
{
  if (this->disc_ != Test::DataType::dtPoint)
  {
    this->_clear ();
    new (&this->u_.pointData_) ::Test::Point (_pointData);
  }
  else
  {
    this->u_.pointData_ = _pointData;
  }
  this->disc_ = Test::DataType::dtPoint;
}
inline void Test::Data::pointData (::Test::Point&& _pointData)
{
  if (this->disc_ != Test::DataType::dtPoint)
  {
    this->_clear ();
    new (&this->u_.pointData_) ::Test::Point (std::move (_pointData));
  }
  else
  {
    this->u_.pointData_ = std::move (_pointData);
  }
  this->disc_ = Test::DataType::dtPoint;
}
inline const ::Test::Point& Test::Data::pointData (void) const
{
  switch (this->disc_)
  {
    case Test::DataType::dtPoint:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.pointData_;
}
inline ::Test::Point& Test::Data::pointData (void)
{
  switch (this->disc_)
  {
    case Test::DataType::dtPoint:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.pointData_;
}

inline void Test::Data::trackData (const ::Test::Track& _trackData)
{
  if (this->disc_ != Test::DataType::dtTrack)
  {
    this->_clear ();
    new (&this->u_.trackData_) ::Test::Track (_trackData);
  }
  else
  {
    this->u_.trackData_ = _trackData;
  }
  this->disc_ = Test::DataType::dtTrack;
}
inline void Test::Data::trackData (::Test::Track&& _trackData)
{
  if (this->disc_ != Test::DataType::dtTrack)
  {
    this->_clear ();
    new (&this->u_.trackData_) ::Test::Track (std::move (_trackData));
  }
  else
  {
    this->u_.trackData_ = std::move (_trackData);
  }
  this->disc_ = Test::DataType::dtTrack;
}
inline const ::Test::Track& Test::Data::trackData (void) const
{
  switch (this->disc_)
  {
    case Test::DataType::dtTrack:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.trackData_;
}
inline ::Test::Track& Test::Data::trackData (void)
{
  switch (this->disc_)
  {
    case Test::DataType::dtTrack:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.trackData_;
}

inline void Test::Data::globalData (const ::Global& _globalData)
{
  if (this->disc_ != Test::DataType::dtGlobal)
  {
    this->_clear ();
    new (&this->u_.globalData_) ::Global (_globalData);
  }
  else
  {
    this->u_.globalData_ = _globalData;
  }
  this->disc_ = Test::DataType::dtGlobal;
}
inline void Test::Data::globalData (::Global&& _globalData)
{
  if (this->disc_ != Test::DataType::dtGlobal)
  {
    this->_clear ();
    new (&this->u_.globalData_) ::Global (std::move (_globalData));
  }
  else
  {
    this->u_.globalData_ = std::move (_globalData);
  }
  this->disc_ = Test::DataType::dtGlobal;
}
inline const ::Global& Test::Data::globalData (void) const
{
  switch (this->disc_)
  {
    case Test::DataType::dtGlobal:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.globalData_;
}
inline ::Global& Test::Data::globalData (void)
{
  switch (this->disc_)
  {
    case Test::DataType::dtGlobal:
      break;
    default:
      throw TAOX11_NAMESPACE::CORBA::BAD_PARAM ();
  }
  return this->u_.globalData_;
}

inline ::Test::Data& Test::Data::operator= (const ::Test::Data& u)
{
  if (this != &u)
  {
    this->_clear ();
    this->disc_ = u.disc_;
    switch (this->disc_)
    {
    case Test::DataType::dtLong:
      {
        this->u_.longData_ = u.u_.longData_;
      }
      break;
    case Test::DataType::dtShort:
      {
        this->u_.shortData_ = u.u_.shortData_;
      }
      break;
    case Test::DataType::dtString:
      {
        new (&this->u_.stringData_) std::string (u.u_.stringData_);
      }
      break;
    case Test::DataType::dtPoint:
      {
        new (&this->u_.pointData_) ::Test::Point (u.u_.pointData_);
      }
      break;
    case Test::DataType::dtTrack:
      {
        new (&this->u_.trackData_) ::Test::Track (u.u_.trackData_);
      }
      break;
    case Test::DataType::dtGlobal:
      {
        new (&this->u_.globalData_) ::Global (u.u_.globalData_);
      }
      break;
    default:
      break;
    }
  }
  return *this;
}

inline ::Test::Data& Test::Data::operator= (::Test::Data&& u)
{
  if (this != &u)
  {
    this->_clear ();
    this->disc_ = std::move (u.disc_);
    switch (this->disc_)
    {
    case Test::DataType::dtLong:
      {
        this->u_.longData_ = std::move (u.u_.longData_);
      }
      break;
    case Test::DataType::dtShort:
      {
        this->u_.shortData_ = std::move (u.u_.shortData_);
      }
      break;
    case Test::DataType::dtString:
      {
        new (&this->u_.stringData_) std::string (std::move (u.u_.stringData_));
      }
      break;
    case Test::DataType::dtPoint:
      {
        new (&this->u_.pointData_) ::Test::Point (std::move (u.u_.pointData_));
      }
      break;
    case Test::DataType::dtTrack:
      {
        new (&this->u_.trackData_) ::Test::Track (std::move (u.u_.trackData_));
      }
      break;
    case Test::DataType::dtGlobal:
      {
        new (&this->u_.globalData_) ::Global (std::move (u.u_.globalData_));
      }
      break;
    default:
      break;
    }
  }
  return *this;
}

inline void Test::Data::swap (::Test::Data& s)
{
  if (this != &s)
  {
    if (this->disc_ != s.disc_)
    {
      // different datatypes; so use move semantics to swap efficiently through intermediary
      ::Test::Data intermediate (std::move (*this));
      (*this) = std::move (s);
      s = std::move (intermediate);
    }
    else
    {
      // same datatypes so swap directly
      this->_swap_u (s);
    }
  }
}

inline void Test::Data::_swap_u (::Test::Data& s)
{
  // u_ members have been guaranteed initialized identically so simply swap data
  switch (this->disc_)
  {
    case Test::DataType::dtLong:
    {
      std::swap (this->u_.longData_, s.u_.longData_);
    }
    break;
    case Test::DataType::dtShort:
    {
      std::swap (this->u_.shortData_, s.u_.shortData_);
    }
    break;
    case Test::DataType::dtString:
    {
      std::swap (this->u_.stringData_, s.u_.stringData_);
    }
    break;
    case Test::DataType::dtPoint:
    {
      std::swap (this->u_.pointData_, s.u_.pointData_);
    }
    break;
    case Test::DataType::dtTrack:
    {
      std::swap (this->u_.trackData_, s.u_.trackData_);
    }
    break;
    case Test::DataType::dtGlobal:
    {
      std::swap (this->u_.globalData_, s.u_.globalData_);
    }
    break;
    default:
    break;
  }
}

inline void Test::Data::_clear (void)
{
  switch (this->disc_)
  {
  case Test::DataType::dtLong:
    {
    }
    break;
  case Test::DataType::dtShort:
    {
    }
    break;
  case Test::DataType::dtString:
    {
      this->u_.stringData_.std::string::~string ();
    }
    break;
  case Test::DataType::dtPoint:
    {
      this->u_.pointData_.::Test::Point::~Point ();
    }
    break;
  case Test::DataType::dtTrack:
    {
      this->u_.trackData_.::Test::Track::~Track ();
    }
    break;
  case Test::DataType::dtGlobal:
    {
      this->u_.globalData_.::Global::~Global ();
    }
    break;
  default:
    break;
  }
}

inline void Test::Data::_default (void)
{
  this->_clear ();
  this->disc_ = ::Test::DataType::dtEmpty;
}

// generated from StubHeaderStdWriter#pre_visit
namespace std {

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Global& m1, ::Global& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Test::Point& m1, ::Test::Point& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/struct_std.erb
  template <>
  inline void swap (::Test::Track& m1, ::Test::Track& m2)
  {
    m1.swap (m2);
  }

  // generated from c++/cli_hdr/union_std.erb
  template <>
  inline void swap (::Test::Data& m1, ::Test::Data& m2)
  {
    m1.swap (m2);
  }
}; // std

// generated from c++/cli_hdr/post.erb
#if defined (__TAOX11_INCLUDE_STUB_PROXY__)
#include "testP.h"
#endif

#include /**/ "ace/post.h"

#endif // __RIDL_TESTC_H_INCLUDED__

// -*- END -*-
